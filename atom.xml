<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Marong&#39;s Note</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-02T01:41:35.911Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Marong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTP图解</title>
    <link href="http://yoursite.com/2022/09/30/book/2022/HTTP%E5%9B%BE%E8%A7%A3/"/>
    <id>http://yoursite.com/2022/09/30/book/2022/HTTP%E5%9B%BE%E8%A7%A3/</id>
    <published>2022-09-30T02:00:00.000Z</published>
    <updated>2022-10-02T01:41:35.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、网络基础"><a href="#一、网络基础" class="headerlink" title="一、网络基础"></a>一、网络基础</h1><h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><ul><li>网络基础，互联 网相关的各类协议族的总称</li><li>应用层(FTP)、传输层(TCP  UDP)、网络层(数据包IP)、数据链路层(网卡NIC)</li><li>URI统一资源标识符  URL统一资源定位符 </li></ul><h1 id="二、HTTP协议"><a href="#二、HTTP协议" class="headerlink" title="二、HTTP协议"></a>二、HTTP协议</h1><ul><li>http协议用于客户端和服务器端之间的通信</li><li>通过请求和响应的交换达成通信 </li><li>HTTP是不保存状态的协议，stateless无状态协议，不做持久化处理</li><li>通过请求URI定位资源</li><li>HTTP方法：GET请求访问已被URI识别的资源 POST用来传输实体的主体 DELETE删除指定资源 PUT传输文件 OPTIONS询问支持的方法  TRACE追踪路径（不常用，经常被跨站追踪）  CONNECT要求用隧道协议连接代理进行TPC通信（主要使用SSL  TSL）</li><li>持久连接：减少流量  keep-alive；使得多数请求管线化方法同时并行发送多个请求。</li><li>cookie管理状态：请求、响应报文都会协带 </li></ul><h1 id="三、报文内的HTTP信息"><a href="#三、报文内的HTTP信息" class="headerlink" title="三、报文内的HTTP信息"></a>三、报文内的HTTP信息</h1><ul><li>HTTP报文分为 报文首部 和 报文主体</li><li>首部：请求行、状态行、首部字段</li><li>主体：报文message  8位组字节流 + 实体entity （有效载荷数据，包括实体首部+实体主体）</li><li>压缩传输的内容编码：gzip / compress / deflate / identity</li><li>分割发送的分块传输编码</li><li>发送多种数据的多部份对象集合：multipart/form-data    multipart/byteranges</li><li>获取部份内容的范围请求 Range: bytes=5001-10000</li><li>内容协商返回最合适的内容：服务器驱动协商 Server-driven Negotiation 客户端驱动协商 Agent-driven Negotiation 透明协商 Transparent Negotiation</li></ul><h1 id="四、状态码"><a href="#四、状态码" class="headerlink" title="四、状态码"></a>四、状态码</h1><ul><li>1XX  信息性状态码  接收 的请求正在处理</li><li>2XX 成功状态码 请求正常处理完结<ul><li>200  成功处理</li><li>204 NOT Content 服务器接收的请求已成功处理，但在返回响应报文中不含实体的主体部份</li><li>206 Partial Content 客户端进行了范围请求Content-Range，服务器成功执行了这个部份的请求。</li></ul></li><li>3XX 重定向状态码 需要进行附加操作以完成请求<ul><li>301 Moved Permanently 永久性重定向</li><li>302 Found 临时性重定向</li><li>303 See Other 由于请求对应的资源存在着另一个URI，应该使用GET定向获取请求资源</li><li>304 Not Modified 服务器资源未改变，可直接使用客户端未过期的缓存</li><li>307 Temporary Redirect 临时重定向</li></ul></li><li>4XX 客户端错误状态码 服务器无法处理请求<ul><li>401 Unauthorized 请求未通过HTTP认证</li><li>403 Forbidden 对请求资源的访问被服务器拒绝了。未获得文件系统的访问权限。服务器不说明原因。</li><li>404 Not Found 服务器上无法找到请求的资源。服务器不说明原因。</li></ul></li><li>5XX 服务器错误状态码 服务器处理请求出错<ul><li>500 Internal Server Error 临时性故障，在执行请求时发生了错误</li><li>503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，无法处理请求</li></ul></li></ul><h1 id="五、与HTTP协作的WEB服务器"><a href="#五、与HTTP协作的WEB服务器" class="headerlink" title="五、与HTTP协作的WEB服务器"></a>五、与HTTP协作的WEB服务器</h1><ul><li>用单台虚拟机可以实现绑定多个域名</li><li>通信数据转发程序：<ul><li>代理（一种有转发功能的应用程序，扮演中间人）<ul><li>缓存代理：会预先将资源的副本缓存在代理服务器上</li><li>透明代理：不对报文做任何加工</li><li>非透明代理：对报文做加工处理后再转发</li></ul></li><li>网关（转发其它服务器通信数据的服务器）：具有一定安全信</li><li>隧道（相隔甚远的客户端和服务器两者之间进行中转，保持双方通信连接的应用程序）：更安全，使用SSL，本身不会解析HTTP，保持原样直接转发</li></ul></li><li>保存资源的缓存<ul><li>节省通信流量和时间</li><li>缓存有效期限</li><li>客户端缓存</li></ul></li></ul><h1 id="六、HTTP首部"><a href="#六、HTTP首部" class="headerlink" title="六、HTTP首部"></a>六、HTTP首部</h1><ul><li>HTTP报文首部<ul><li>请求报文：方法、URI、HTTP版本、HTTP首部字段</li><li>响应报文：HTTP版本、状态码、HTTP首部字段</li></ul></li><li>HTTP首部字段<ul><li>HTTP首部字段传递重要信息</li><li>HTTP首部字段结构：（字段名:字段值）</li><li>HTTP首部字段类型：通用首部字段、请求首部字段、响应首部字段、实体首部字段</li><li>非HTTP/1.1首部字段：还有Cookie / Set-Cookie / Content-Disposition</li><li>HTTP首部字段将定义成缓存代理和非缓存代理的行为<ul><li>端到端End-to-end首部：会转发给请求、响应对应的最终接收目标，必须被转发。除以下8个逐跳首部，其它都是端到端。</li><li>逐跳Hop-by-hop首部：只对单次转发有效，会因通过缓存或代理不再转发<ul><li>Connection\Keep-Alive\Proxy-Authenticate\Proxy-Authorization\Trailer\TE\Transfer-Encodeing\Upgrade</li></ul></li></ul></li></ul></li><li>HTTP/1.1通用首部字段<ul><li>Cache-Control 控制缓存行为</li><li>Connection 逐跳首部、连接的管理</li><li>Date 创建报文的日期时间</li><li>Piagma 报文指令</li><li>Trailer 报文末端的首部一览</li><li>Transfer-Encoding 指定报文主体的传输编码方式</li><li>Upgrade 升级为其他协议 </li><li>Via 代理服务器的相关信息</li><li>Warning 错误通知</li></ul></li><li>请求首部字段<ul><li>Accept 用户代理可处理的媒体类型</li><li>Accept-Charset 优先的字符集</li><li>Accept-Encoding 优先的内容编码</li><li>Accept-Language 优先的语言</li><li>Authorization 认证信息</li><li>Expect 期待服务器的特定行为</li><li>From 用户的电子邮箱地址</li><li>Host 请求资源所在的服务器</li><li>If-Match 比较实体标记 ETag</li><li>If-Modified-Since 比较资源的更新时间</li><li>If-None-Match 比较实体标记 与If-Match相反</li><li>If-Range 资源未更新时发送实体Byte的范围请求</li><li>If-Unmodified-Since 比较资源的更新时间 与上面相反</li><li>Max-Forward 最大传输逐跳数</li><li>Proxy-Authorization 代理服务器要求客户端的认证信息</li><li>Range 实体的字节范围请求</li><li>Referer 对请求中的URI的原始获取方</li><li>TE 传输编码的优先级</li><li>User-Agent HTTP客户端的程序信息</li></ul></li><li>响应首部字段<ul><li>Accept-Ranges 是否接受字节范围的请求</li><li>Age 推算资源创建经过的时间</li><li>ETag 资源的匹配信息</li><li>Location 令客户端重定向至指定URI</li><li>Proxy-Authenticate 代理服务器对客户端的认证信息</li><li>Retry-After 对再次发起请求的时机要求</li><li>Server HTTP服务器的安装信息</li><li>Vary 代理服务器缓存的管理信息</li><li>WWW-Authenticate 服务器对客户端的认证信息</li></ul></li><li>实体首部字段<ul><li>Allow 资源可支持的HTTP方法</li><li>Content-Encoding 实体主体适用的编码方式</li><li>Content-Language 实体主体的自然语言</li><li>Content-Length 实体主体的大小 </li><li>Content-Location 替代对应资源的URI</li><li>Content-Md5 实体主体的报文摘要</li><li>Content-Range 实体主体的位置范围</li><li>Content-Type 实体主体的媒体类型</li><li>Expires 实体主体过期 的日期时间</li><li>Last-Modified 资源最后修改的日期旱</li></ul></li><li>为Cookie服务的首部字段<ul><li>Set-Cookie 服务器准备开始管理客户端状态时，会事先告知各种信息</li><li>Cookie</li></ul></li><li>其它首部字段<ul><li>X-Frame-Options 属于响应首部 用于控制网站内容在其它WEB的Frame标签内的显示问题，防止点击劫持</li><li>X-XSS-protechtion 属于响应首部 针对 跨站脚本 攻击XSS的一种对策</li><li>DNT 属于请求首部 拒绝个人信息被收集，拒绝被精准广告追踪的一种方法</li><li>P3P 属于响应首部 个人隐私变成一种仅供程序可理解的形式，达到保护用户隐私</li></ul></li></ul><h1 id="七、确保WEB安全的HTTPS"><a href="#七、确保WEB安全的HTTPS" class="headerlink" title="七、确保WEB安全的HTTPS"></a>七、确保WEB安全的HTTPS</h1><ul><li>HTTP信息窃听（使用明文）身份伪装（不验证通信方身份）篡改（无法证明报文完整性）等安全问题</li><li>防止窃听：使用加密方式<ul><li>通信加密SSL + TLS</li><li>内容加密</li></ul></li><li>防止伪装：查明对方证书</li><li>防止篡改：散列值校验MD5  SHA-1  或 数字签名RSA</li><li>HTTP+加密+认证+完整性保护=HTTPS(混合加密)</li></ul><h1 id="八、确认访问用户身份的认证"><a href="#八、确认访问用户身份的认证" class="headerlink" title="八、确认访问用户身份的认证"></a>八、确认访问用户身份的认证</h1><ul><li>HTTP使用认证方式 <ul><li>BASIC认证（基本认证）</li><li>DIGEST认证（摘要认证）</li><li>SSL客户端认证</li><li>FormBase认证（基于表单认证）：Cookie管理Session会话</li></ul></li></ul><h1 id="九、基于HTTP的功能追加协议"><a href="#九、基于HTTP的功能追加协议" class="headerlink" title="九、基于HTTP的功能追加协议"></a>九、基于HTTP的功能追加协议</h1><ul><li>消除HTTP瓶颈的SPDY，GOOOGLE在2010发布的，缩短WEB页面加载时间50%</li><li>虽然相继出现AJAX，COMET等解决方法</li><li>SPDY的设计，未完全改写HTTP协议，以会话层形式加入，控制对数据的流动，采用HTTP建立通信连接<ul><li>多路复用流</li><li>赋予请求优先级</li><li>压缩HTTP首部</li><li>推送功能</li><li>服务器提示功能</li></ul></li><li>使用浏览器进行全双工通信的WEBSOCKET<ul><li>推送功能</li><li>减少通信量</li></ul></li><li>HTTP/2.0</li></ul><h1 id="十、WEB的攻击技术"><a href="#十、WEB的攻击技术" class="headerlink" title="十、WEB的攻击技术"></a>十、WEB的攻击技术</h1><ul><li>因输出值转义不完全引发的安全漏洞<ul><li>跨站脚本攻击</li><li>SQL注入攻击</li><li>OS命令注入攻击</li><li>HTTP首部注入攻击</li><li>邮件首部注入攻击</li><li>目录遍历攻击</li><li>远程文件 包含漏洞</li></ul></li><li>因设置或设计上的缺陷引发的安全漏洞<ul><li>强制浏览</li><li>不正确的错误消息处理</li><li>开放重定向</li></ul></li><li>因会话管理疏忽引发的安全漏洞<ul><li>会话劫持</li><li>会话固定攻击</li><li>跨站点请求伪造</li></ul></li><li>其它安全漏洞<ul><li>密码破解</li><li>点击劫持</li><li>DOS攻击</li><li>后门程序</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、网络基础&quot;&gt;&lt;a href=&quot;#一、网络基础&quot; class=&quot;headerlink&quot; title=&quot;一、网络基础&quot;&gt;&lt;/a&gt;一、网络基础&lt;/h1&gt;&lt;h4 id=&quot;TCP-IP&quot;&gt;&lt;a href=&quot;#TCP-IP&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2022-05】</title>
    <link href="http://yoursite.com/2022/05/30/weeks/2022/2022-05/"/>
    <id>http://yoursite.com/2022/05/30/weeks/2022/2022-05/</id>
    <published>2022-05-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.975Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/nEBp9YYUYFLP8O3xJfbm9A" target="_blank" rel="noopener">8 种技巧让你编写更简洁的 JavaScript 代码</a></p><p><a href="https://juejin.cn/post/7096695346239111199" target="_blank" rel="noopener">1.4w字总结带你重学TypeScript</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/nEBp9YYUYFLP8O3xJfbm9A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;8 种技巧让你编写更简洁的 JavaScript 代码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href
      
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2022-04】</title>
    <link href="http://yoursite.com/2022/04/30/weeks/2022/2022-04/"/>
    <id>http://yoursite.com/2022/04/30/weeks/2022/2022-04/</id>
    <published>2022-04-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.975Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7085145274200358949" target="_blank" rel="noopener">86张脑图，一口气看完 React </a></p><p><a href="https://juejin.cn/post/7085542534943883301" target="_blank" rel="noopener">2022 年的 React 生态</a></p><p><a href="https://juejin.cn/post/7067342513920540686#comment" target="_blank" rel="noopener">扔掉 Electron，拥抱基于 Rust 开发的 Tauri</a></p><p><a href="https://juejin.cn/post/7079447275755274254" target="_blank" rel="noopener">50 多个提高前端人效率的工具、网站和书籍整理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7085145274200358949&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;86张脑图，一口气看完 React &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin
      
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>小灰算法</title>
    <link href="http://yoursite.com/2022/04/22/book/2022/%E5%B0%8F%E7%81%B0%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2022/04/22/book/2022/%E5%B0%8F%E7%81%B0%E7%AE%97%E6%B3%95/</id>
    <published>2022-04-22T02:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、算法概述"><a href="#一、算法概述" class="headerlink" title="一、算法概述"></a>一、算法概述</h1><h2 id="1-1-算法algorithm和数据结构"><a href="#1-1-算法algorithm和数据结构" class="headerlink" title="1.1 算法algorithm和数据结构"></a>1.1 算法algorithm和数据结构</h2><p>数据结构：线性结构（数组、链表、栈、队列、哈希表）、树、图、其它类型</p><h2 id="1-2-时间复杂度-time-complexity"><a href="#1-2-时间复杂度-time-complexity" class="headerlink" title="1.2 时间复杂度 time complexity"></a>1.2 时间复杂度 time complexity</h2><p>运行时间 ms<br>基本操作执行次数T(n) n是规模</p><ul><li>执行次数是线性的 T(n)=3n  T(n)=O(n)</li><li>执行次数是对数计算的 T(n)=5logn  T(n)=O(logn)</li><li>执行次数是常量 T(n)=2  T(n)=O(1)</li><li>执行次数是多项式 T(n)=0.5n² + 0.5n  T(n)=O(n²)</li></ul><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(n²)</p><h2 id="1-3-空间复杂度-space-complexity"><a href="#1-3-空间复杂度-space-complexity" class="headerlink" title="1.3 空间复杂度 space complexity"></a>1.3 空间复杂度 space complexity</h2><p>占用空间MB</p><ul><li><p>常量空间 O(1) </p></li><li><p>线性空间 O(n)</p></li><li><p>二维空间 O(n²)</p></li><li><p>递归空间 方法调用栈 进栈 出栈 递归深度为n  空间复杂度为O(n)</p></li><li><h1 id="二、数据结构基础"><a href="#二、数据结构基础" class="headerlink" title="二、数据结构基础"></a>二、数据结构基础</h1><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2></li><li><p>有限个相同类型的变量所组成的有序集合</p></li><li><p>在内存中顺序存储</p></li><li><p>读取、更新、插入、删除</p></li><li><p>扩容</p><h2 id="2-2-链表"><a href="#2-2-链表" class="headerlink" title="2.2 链表"></a>2.2 链表</h2></li><li><p>在内存中随机存储</p></li><li><p>单向链表-每一个节点包含两部分，一部分是存放数据的变量data，一部分是指向下一个节点的指针next</p></li><li><p>双向链表-还多一个指向前置节点的pre指针</p></li><li><p>查找、更新、插入 首尾中间、删除 首尾中间</p></li></ul><h2 id="2-3-栈和队列"><a href="#2-3-栈和队列" class="headerlink" title="2.3 栈和队列"></a>2.3 栈和队列</h2><ul><li>栈 ： 线性数据结构；先入后出、最后入栈顶、最先入为栈底；出栈、入栈、只有栈顶才能出栈；</li><li>队列：单行隧道；先入先出、出口叫队头、入口叫队尾；入队、出队</li></ul><h2 id="2-4-散列表"><a href="#2-4-散列表" class="headerlink" title="2.4 散列表"></a>2.4 散列表</h2><ul><li>散列表也叫做哈希表 提供了键key值value;写操作put；读操作get；扩容resize</li></ul><h1 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h1><h2 id="3-1-树和二叉树"><a href="#3-1-树和二叉树" class="headerlink" title="3.1 树和二叉树"></a>3.1 树和二叉树</h2><p>树：是n个节点的有限集，有且仅有一个特定的称为根的节点。</p><p>二叉树：每个节点最多有2个孩子 的节点。左孩子，右孩子 ，顺序固定。</p><p>满二叉树：所有非叶子节点都存在左右孩子 ，并且所有叶子节点都在同一层级上。（满二叉树每个分支都是满的）</p><p>完全二叉树：对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同。</p><p>二叉树存储方式：链式存储结构和数组</p><h2 id="3-2-二叉树遍历"><a href="#3-2-二叉树遍历" class="headerlink" title="3.2 二叉树遍历"></a>3.2 二叉树遍历</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>前序遍历：根节点、左子树、右子树</p><p>中序遍历：左子树、根节点、右子树</p><p>后序遍历：左子树、右子树、根节点</p><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>层序遍历：一层层的遍历</p><h2 id="3-3-二叉堆（完全二叉树）"><a href="#3-3-二叉堆（完全二叉树）" class="headerlink" title="3.3 二叉堆（完全二叉树）"></a>3.3 二叉堆（完全二叉树）</h2><p>最大堆：任何一个父节点的值，都大于或等于它的左右孩子节点的值。</p><p>最小堆：任何一个父节点的值，都小于或等于它的左右孩子节点的值。</p><p>二叉堆的根节点叫做堆顶。最大堆的堆顶是最大元素，最小堆的堆顶是最小元素。</p><h2 id="3-4-优先队列"><a href="#3-4-优先队列" class="headerlink" title="3.4 优先队列"></a>3.4 优先队列</h2><p>二叉堆是实现优先队列的基础，队列先进先出。</p><p>入队列，将新元素置于队尾。出队列，队头元素最先被移除。</p><p>最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队。</p><p>最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队。</p><h1 id="四、排序算法"><a href="#四、排序算法" class="headerlink" title="四、排序算法"></a>四、排序算法</h1><h2 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h2><p>定义：把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</p><ul><li>一种稳定排序</li><li>每一轮都要遍历所有元素，总共遍历无数数量 -1 轮</li><li>平均时间复杂度为O(n2)</li></ul><h3 id="鸡尾酒排序"><a href="#鸡尾酒排序" class="headerlink" title="鸡尾酒排序"></a>鸡尾酒排序</h3><p>冒泡排序每一轮都是从左到右来比较元素，进行单向的位置交换的。</p><p>鸡尾酒排序的元素比较和交换过程是双向的。</p><h2 id="4-2-快速排序（交换排序）"><a href="#4-2-快速排序（交换排序）" class="headerlink" title="4.2 快速排序（交换排序）"></a>4.2 快速排序（交换排序）</h2><p>定义：在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部份。(分治法)</p><ul><li>选择基准元素</li><li>元素的交换：双边循环法、单边循环法</li><li>非递归实现</li></ul><h2 id="4-3-堆排序"><a href="#4-3-堆排序" class="headerlink" title="4.3 堆排序"></a>4.3 堆排序</h2><p>1、把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。</p><p>2、循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。</p><h2 id="4-4-计数排序和桶排序"><a href="#4-4-计数排序和桶排序" class="headerlink" title="4.4 计数排序和桶排序"></a>4.4 计数排序和桶排序</h2><p>线性时间的排序</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>…</p><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><ol><li>创建这些桶并确定每个桶的区间范围</li><li>遍历原始数列，把元素对号入座放入各个桶中。</li><li>对每个树内部的元素分别进行排序。（显然只有第一个桶需要排序）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、算法概述&quot;&gt;&lt;a href=&quot;#一、算法概述&quot; class=&quot;headerlink&quot; title=&quot;一、算法概述&quot;&gt;&lt;/a&gt;一、算法概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-算法algorithm和数据结构&quot;&gt;&lt;a href=&quot;#1-1-算法algorithm和数
      
    
    </summary>
    
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="小灰" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%81%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何成为一个会学习的人</title>
    <link href="http://yoursite.com/2022/04/22/book/2022/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BA%BA/"/>
    <id>http://yoursite.com/2022/04/22/book/2022/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BA%BA/</id>
    <published>2022-04-22T02:00:00.000Z</published>
    <updated>2022-06-05T14:29:00.903Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全身心投入"><a href="#全身心投入" class="headerlink" title="全身心投入"></a>全身心投入</h1><blockquote><p> 将专注力应用学习的好处</p></blockquote><ul><li>能在短时间内取得成果</li><li>能把一天变成72小时</li><li>不再为了努力而努力</li></ul><blockquote><p>找到学习令人沉迷的要点</p></blockquote><ul><li>能够快速获得成就感</li></ul><blockquote><p>要重视“全身心投入”而非“效率”</p></blockquote><h1 id="一、学习停不下来！磨炼“专注力”！"><a href="#一、学习停不下来！磨炼“专注力”！" class="headerlink" title="一、学习停不下来！磨炼“专注力”！"></a>一、学习停不下来！磨炼“专注力”！</h1><h3 id="只有喜欢，才能擅长"><a href="#只有喜欢，才能擅长" class="headerlink" title="只有喜欢，才能擅长"></a>只有喜欢，才能擅长</h3><p>因为喜欢才全身心投入，并一直坚持下去的结果。<br>无论是学习还是兴趣爱好，我都认为“只有喜欢，才能擅长”。<br>即使做不到，也不要怕丢人，重要的是大胆地迈出第一步。<br>只要始终保持喜欢的心态，就一定能够不断精进。</p><h3 id="大家热衷的事情，要尝试去做"><a href="#大家热衷的事情，要尝试去做" class="headerlink" title="大家热衷的事情，要尝试去做"></a>大家热衷的事情，要尝试去做</h3><h3 id="只需增加“天线”，信息就会纷至沓来"><a href="#只需增加“天线”，信息就会纷至沓来" class="headerlink" title="只需增加“天线”，信息就会纷至沓来"></a>只需增加“天线”，信息就会纷至沓来</h3><h3 id="善于倾听才能善于学习"><a href="#善于倾听才能善于学习" class="headerlink" title="善于倾听才能善于学习"></a>善于倾听才能善于学习</h3><h3 id="经常带着问号，锻炼逻辑思维"><a href="#经常带着问号，锻炼逻辑思维" class="headerlink" title="经常带着问号，锻炼逻辑思维"></a>经常带着问号，锻炼逻辑思维</h3><h3 id="“遇到困难”更有利于吸取知识"><a href="#“遇到困难”更有利于吸取知识" class="headerlink" title="“遇到困难”更有利于吸取知识"></a>“遇到困难”更有利于吸取知识</h3><h3 id="不顺利的时候毫不犹豫地妥协"><a href="#不顺利的时候毫不犹豫地妥协" class="headerlink" title="不顺利的时候毫不犹豫地妥协"></a>不顺利的时候毫不犹豫地妥协</h3><p>有时候需要妥协，放松自己。这才是持续下去的秘诀</p><h3 id="利用“付出金钱就希望收回成本”的潜意识"><a href="#利用“付出金钱就希望收回成本”的潜意识" class="headerlink" title="利用“付出金钱就希望收回成本”的潜意识"></a>利用“付出金钱就希望收回成本”的潜意识</h3><h3 id="先尝试着去做，机会才能到来"><a href="#先尝试着去做，机会才能到来" class="headerlink" title="先尝试着去做，机会才能到来"></a>先尝试着去做，机会才能到来</h3><h1 id="二、同时提高逻辑思维能力、记忆力、专注力的学习术"><a href="#二、同时提高逻辑思维能力、记忆力、专注力的学习术" class="headerlink" title="二、同时提高逻辑思维能力、记忆力、专注力的学习术"></a>二、同时提高逻辑思维能力、记忆力、专注力的学习术</h1><h3 id="五分钟回顾学习法"><a href="#五分钟回顾学习法" class="headerlink" title="五分钟回顾学习法"></a>五分钟回顾学习法</h3><ul><li>每1-2页回顾一次</li><li>每个项目总结一次</li><li>每个章节重新审视</li></ul><p>迅速提高逻辑思维能力的“立场转换法“，反复论证AB角色<br>提高记忆力、专注力的“散步锻炼法”<br>随时随地能够自动复习的“自问自答法”<br>通过音乐提升情绪的“自我动力转换法”<br>一张A4纸就能飞速提高记忆固化率的“睡前检查法”<br>体验成就感，稳定进步的“音效激励法”<br>背诵复杂内容的“反复诵读法”<br>打造超专注空间的“秘密基地法” - 狭小空间、消除诱惑<br>轻松提高阅读速度的“速读捕获法“ - 词组</p><h1 id="三、把“做不到”变成“做得到”！把不擅长的领域变成擅长的领域"><a href="#三、把“做不到”变成“做得到”！把不擅长的领域变成擅长的领域" class="headerlink" title="三、把“做不到”变成“做得到”！把不擅长的领域变成擅长的领域"></a>三、把“做不到”变成“做得到”！把不擅长的领域变成擅长的领域</h1><h3 id="把学会的项目写出来、可视化"><a href="#把学会的项目写出来、可视化" class="headerlink" title="把学会的项目写出来、可视化"></a>把学会的项目写出来、可视化</h3><h3 id="只要遵守三个规则，就一定能全身心投入"><a href="#只要遵守三个规则，就一定能全身心投入" class="headerlink" title="只要遵守三个规则，就一定能全身心投入"></a>只要遵守三个规则，就一定能全身心投入</h3><ul><li>快速反馈</li><li>可以控制</li><li>保持平衡<h3 id="轻松了解自己学习能力的方法"><a href="#轻松了解自己学习能力的方法" class="headerlink" title="轻松了解自己学习能力的方法"></a>轻松了解自己学习能力的方法</h3></li><li>一点也不会</li><li>并不知道答案</li><li>看完答案解析就懂了</li><li>一定程度上了解<h3 id="想象“做”“不做”“实现”"><a href="#想象“做”“不做”“实现”" class="headerlink" title="想象“做”“不做”“实现”"></a>想象“做”“不做”“实现”</h3><h3 id="想办法“享受”学习"><a href="#想办法“享受”学习" class="headerlink" title="想办法“享受”学习"></a>想办法“享受”学习</h3><h3 id="战胜睡魔的五个方法"><a href="#战胜睡魔的五个方法" class="headerlink" title="战胜睡魔的五个方法"></a>战胜睡魔的五个方法</h3>深呼吸、营造沐浴晨光的环境、睡前泡个澡、做伸展运动、防蓝光</li></ul><h3 id="改变饮食习惯-提升专注力"><a href="#改变饮食习惯-提升专注力" class="headerlink" title="改变饮食习惯 提升专注力"></a>改变饮食习惯 提升专注力</h3><p>柠檬、葡萄糖、红茶</p><h2 id="把无趣的世界变得有趣的承诺合同"><a href="#把无趣的世界变得有趣的承诺合同" class="headerlink" title="把无趣的世界变得有趣的承诺合同"></a>把无趣的世界变得有趣的承诺合同</h2><h1 id="四、只有聪明之人才有的快乐学习的习惯"><a href="#四、只有聪明之人才有的快乐学习的习惯" class="headerlink" title="四、只有聪明之人才有的快乐学习的习惯"></a>四、只有聪明之人才有的快乐学习的习惯</h1><h3 id="专注学习需要养成某些习惯"><a href="#专注学习需要养成某些习惯" class="headerlink" title="专注学习需要养成某些习惯"></a>专注学习需要养成某些习惯</h3><h3 id="做让人赞叹不已的事"><a href="#做让人赞叹不已的事" class="headerlink" title="做让人赞叹不已的事"></a>做让人赞叹不已的事</h3><p>被称赞、数字化目标、时间轴</p><h3 id="给自己制造良好的反馈"><a href="#给自己制造良好的反馈" class="headerlink" title="给自己制造良好的反馈"></a>给自己制造良好的反馈</h3><h3 id="把看似毫无关系的事务联系起来，无论何时何地都在学习"><a href="#把看似毫无关系的事务联系起来，无论何时何地都在学习" class="headerlink" title="把看似毫无关系的事务联系起来，无论何时何地都在学习"></a>把看似毫无关系的事务联系起来，无论何时何地都在学习</h3><h3 id="把时间和金钱赚回来"><a href="#把时间和金钱赚回来" class="headerlink" title="把时间和金钱赚回来"></a>把时间和金钱赚回来</h3><h3 id="从略感兴趣到乐此不疲"><a href="#从略感兴趣到乐此不疲" class="headerlink" title="从略感兴趣到乐此不疲"></a>从略感兴趣到乐此不疲</h3><h3 id="必须要做的事情，要在最短时间内完成"><a href="#必须要做的事情，要在最短时间内完成" class="headerlink" title="必须要做的事情，要在最短时间内完成"></a>必须要做的事情，要在最短时间内完成</h3><h3 id="坚持本身就会产生成就感-朴实-X-脚踏实地-成就感"><a href="#坚持本身就会产生成就感-朴实-X-脚踏实地-成就感" class="headerlink" title="坚持本身就会产生成就感 朴实 X 脚踏实地 = 成就感"></a>坚持本身就会产生成就感 朴实 X 脚踏实地 = 成就感</h3><h3 id="有针对性的改造学习"><a href="#有针对性的改造学习" class="headerlink" title="有针对性的改造学习"></a>有针对性的改造学习</h3><h1 id="六个学习方法"><a href="#六个学习方法" class="headerlink" title="六个学习方法"></a>六个学习方法</h1><ul><li>费曼学习法</li><li>番茄工作法</li><li>金字塔原理</li><li>多元思维模型</li><li>5W2H分析思考法</li><li>康奈尔5R笔记法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全身心投入&quot;&gt;&lt;a href=&quot;#全身心投入&quot; class=&quot;headerlink&quot; title=&quot;全身心投入&quot;&gt;&lt;/a&gt;全身心投入&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 将专注力应用学习的好处&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;能在短时间
      
    
    </summary>
    
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="学习" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2022-03】</title>
    <link href="http://yoursite.com/2022/03/30/weeks/2022/2022-03/"/>
    <id>http://yoursite.com/2022/03/30/weeks/2022/2022-03/</id>
    <published>2022-03-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/hsxmYKSzZiURKmrq6Bo3jg" target="_blank" rel="noopener">深度：跨端技术的本质与现状</a></p><p><a href="https://mp.weixin.qq.com/s/H_uI_uuAOnjrmWuWDyQPCg" target="_blank" rel="noopener">重构知识的供给模式 ——《数据平台》从思考到落地</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/hsxmYKSzZiURKmrq6Bo3jg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;深度：跨端技术的本质与现状&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.w
      
    
    </summary>
    
    
    
      <category term="跨端" scheme="http://yoursite.com/tags/%E8%B7%A8%E7%AB%AF/"/>
    
      <category term="数据平台" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>构建高性能WEB站点</title>
    <link href="http://yoursite.com/2022/03/10/book/2022/%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BDWEB%E7%AB%99%E7%82%B9/"/>
    <id>http://yoursite.com/2022/03/10/book/2022/%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BDWEB%E7%AB%99%E7%82%B9/</id>
    <published>2022-03-10T02:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、绪论"><a href="#一、绪论" class="headerlink" title="一、绪论"></a>一、绪论</h1><p>了解等待的真相</p><p>查找瓶颈在哪里</p><p>增加带宽</p><p>减少网页中的HTTP请求数量</p><p>加快服务器脚本计算速度</p><p>使用动态内容缓存</p><p>将动态内容静态化</p><p>更换WEB服务器软件</p><p>页面组建分离</p><p>合理部署服务器</p><p>使用负载均衡</p><p>优化数据哭</p><p>考虑可扩展性</p><p>减少视觉等待</p><h1 id="二、数据的网络传输"><a href="#二、数据的网络传输" class="headerlink" title="二、数据的网络传输"></a>二、数据的网络传输</h1><p>增加带宽： bit/s 单位时间内的比特数</p><p>响应时间 = 发送时间 + 传输时间 + 处理时间</p><p>下载速度 = 数据量字节数/响应时间</p><p>互联互通：链接网络运营商</p><h1 id="三、服务器并发处理能力"><a href="#三、服务器并发处理能力" class="headerlink" title="三、服务器并发处理能力"></a>三、服务器并发处理能力</h1><p>吞吐率：前提条件 并发用户数、总请求数、请求资源描述，进行压力测试。</p><p>CPU并发计算：进程、线程、进程调度器、系统负载、进程切换、锁竞争。</p><p>系统调用：减少系统调用可以降低请求处理时间，提升吞吐率。</p><p>内存分配：Apache 内存池 、Nginx内存分配策略。</p><p>持久连接（长链接）：http 请求中长连接的声明 开启（ Connection:Keep-Alive）关闭（KeepAlive Off） 超时时间nginx（KeepAliveTimeout 30）</p><p>I/O模型：同步阻塞、同步非阻塞、多路I/O就绪通知、内存映射、直接I/O、异步I/O</p><p>服务器并发策略</p><h1 id="四、动态内容缓存"><a href="#四、动态内容缓存" class="headerlink" title="四、动态内容缓存"></a>四、动态内容缓存</h1><p>重复的开销</p><p>缓存与速度：整页、局部、数据缓存、代码解释器缓存、web服务器缓存。</p><p>缓存与缓冲：关系到命中率的问题，缓冲是视频中负责写入磁盘。</p><p>页面缓存：指MVC框架中动态网页的缓存。</p><p>缓存持久化与查找</p><p>过期检查：对缓存的动态内容存在重复计算，对有效时间外的缓存清理。</p><p>把缓存放到内存中：常规的缓存放到磁盘中会增加I/O操作。</p><p>把缓存放到缓存服务器：memcached通过TCP将缓存存储在独立的缓存服务器中。</p><p>局部无缓存：对于一些动态更新的区域无缓存。</p><p>静态化内容：</p><p>直接访问缓存</p><p>更新策略：在数据更新时重新生成静态化内容（由用户动态触发）；定时重新生成静态化内容。</p><p>局部静态化：SSI</p><h1 id="五、动态脚本加速"><a href="#五、动态脚本加速" class="headerlink" title="五、动态脚本加速"></a>五、动态脚本加速</h1><p>Oppose缓存：动态内容编译成二进制可执行文件，也就是目标代码。</p><p>解释器扩展模块：第三方的编译程序。</p><p>脚本跟踪与分析</p><p>代码段执行时间</p><p>上下文信息收集：配合代码跟踪收集信息，记录当前上下文信息，比如当前行号、哪里被调用。</p><p>代码覆盖范围</p><p>函数跟踪</p><p>瓶颈分析</p><h1 id="六、浏览器缓存"><a href="#六、浏览器缓存" class="headerlink" title="六、浏览器缓存"></a>六、浏览器缓存</h1><p>http缓存协商：WEB服务器和浏览器之间</p><p>彻底消灭请求：浏览器缓存截止期限；性能方面，没有发起请求，就进行不了压力测试。</p><h1 id="七、WEB服务器缓存"><a href="#七、WEB服务器缓存" class="headerlink" title="七、WEB服务器缓存"></a>七、WEB服务器缓存</h1><p>URL映射：增加了I/O开销。</p><p>缓存响应内容：将内容交给WEB服务器缓存，准备好缓存区；缓存静态内容；缓存动态内容；控制有效期；</p><h1 id="八、反向代理缓存"><a href="#八、反向代理缓存" class="headerlink" title="八、反向代理缓存"></a>八、反向代理缓存</h1><p>反向代理：WEB服务器隐藏在代理服务器之后。</p><p>在反向代理上创建缓存：修改缓存规则、清除缓存、监控缓存命中率、从缓存命中率中寻找答案、缓存命中率和后端吞吐率的理想计算模型、和动态内容缓存一起工作</p><p>小心穿过代理</p><p>流量分配</p><h1 id="九、WEB组件分离"><a href="#九、WEB组件分离" class="headerlink" title="九、WEB组件分离"></a>九、WEB组件分离</h1><p>拥有不同的域名</p><p>浏览器并发数</p><p>动态内容：开启opcode缓存、足够快的CPU、足够大的内存、多进程、与数据库保持高速连接、可靠的数据中心</p><p>静态网页：支持epoll、非阻塞I/O、异步I/O、使用sendfile()系统调用、单进程、使用高速磁盘、使用RAID分区、购买足够的带宽</p><p>图片：持久连接</p><p>样式表：有效期为一年</p><p>脚本</p><p>视频</p><h1 id="十、分布式缓存"><a href="#十、分布式缓存" class="headerlink" title="十、分布式缓存"></a>十、分布式缓存</h1><p>数据库的前端缓存区：读缓存区域、写缓存区域</p><p>使用memcached分布式缓存系统：使用key-value来存储数据、数据项设置过期时间、网络并发模型、对象序列化可将数据转化为二进制</p><p>读操作缓存：重复的身份验证、数据库索引、缓存用户登录状态</p><p>写操作缓存：直接更新、线程安全和锁竞争、原子加法</p><p>监控状态：空间使用率、缓存命中率、I/O流量</p><p>缓存扩展</p><h1 id="十一、数据库性能优化"><a href="#十一、数据库性能优化" class="headerlink" title="十一、数据库性能优化"></a>十一、数据库性能优化</h1><p>提供友好的状态报告</p><p>正确使用索引：使用组合索引、使用慢查询分析工具、索引缓存、索引的代价</p><p>锁定与等待：减少表锁定等待、行锁定带来了什么？真的好吗？</p><p>事务性表的性能</p><p>使用查询缓存</p><p>临时表</p><p>线程池</p><p>反规范化设计</p><p>放弃关系型数据库</p><h1 id="十二、WEB负载均衡"><a href="#十二、WEB负载均衡" class="headerlink" title="十二、WEB负载均衡"></a>十二、WEB负载均衡</h1><p>HTTP重定向</p><p>DNS负载均衡：多个A记录</p><p>反向代理负载均衡：转移和转发、按照权重分配任务、调度起的并发处理能力、扩展的制约、健康监测</p><p>IP负载均衡：DNAT反向NAT、用iptables来实现调度器、IPVS/ipvsadm、LVS-NAT、性能、动态调度策略、网关瓶颈、</p><p>直接路由：使用IP别名、将实际服务器接入外部网络、LVS-DR、转型到DNS-RR</p><p>IP隧道</p><p>考虑可用性</p><h1 id="十三、共享文件系统"><a href="#十三、共享文件系统" class="headerlink" title="十三、共享文件系统"></a>十三、共享文件系统</h1><p>网络共享：利用共享文件系统来实现图片共享、将集群中某台WEB服务器作为文件服务器</p><p>NFS：首选方案：基于RPC传输、统计I/O、延迟I/O、</p><p>局限性：有一定影响性能</p><h1 id="十四、内容分发和同步"><a href="#十四、内容分发和同步" class="headerlink" title="十四、内容分发和同步"></a>十四、内容分发和同步</h1><p>复制：图片服务器到多台WEB服务器到文件复制</p><p>SSH：SCP+SFTP、多级分发</p><p>WEBDAV：完全基于HTTP 与restful风格相似</p><p>HASH TREE</p><p>分发还是同步</p><p>反向代理</p><h1 id="十五、分布式文件系统"><a href="#十五、分布式文件系统" class="headerlink" title="十五、分布式文件系统"></a>十五、分布式文件系统</h1><p>文件系统：Hadoop</p><p>存储节点和追踪器</p><p>MogileFS: 开源的分布式文件系统</p><h1 id="十六、数据库扩展"><a href="#十六、数据库扩展" class="headerlink" title="十六、数据库扩展"></a>十六、数据库扩展</h1><p>复制和分离：主从复制、读写分离、使用数据库反向代理</p><p>垂直分区</p><p>水平分区：把数据放到不同分区中、分区和分表、分区扩展、分区反向代理、</p><h1 id="十七、分布式计算"><a href="#十七、分布式计算" class="headerlink" title="十七、分布式计算"></a>十七、分布式计算</h1><p>异步计算：分布式消息队列、Gearman、</p><p>并行计算：分而治之、MAP/REDUCE（分布式并行计算的开发框架）</p><h1 id="十八、性能监控"><a href="#十八、性能监控" class="headerlink" title="十八、性能监控"></a>十八、性能监控</h1><p>实时监控：Nmon、监控代理、系统监控、服务监控</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、绪论&quot;&gt;&lt;a href=&quot;#一、绪论&quot; class=&quot;headerlink&quot; title=&quot;一、绪论&quot;&gt;&lt;/a&gt;一、绪论&lt;/h1&gt;&lt;p&gt;了解等待的真相&lt;/p&gt;
&lt;p&gt;查找瓶颈在哪里&lt;/p&gt;
&lt;p&gt;增加带宽&lt;/p&gt;
&lt;p&gt;减少网页中的HTTP请求数量&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2022-02】</title>
    <link href="http://yoursite.com/2022/02/28/weeks/2022/2022-02/"/>
    <id>http://yoursite.com/2022/02/28/weeks/2022/2022-02/</id>
    <published>2022-02-28T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Gx2muPw2T9zYCdBPzIbzbg" target="_blank" rel="noopener">前端灰度发布落地方案</a></p><p><a href="https://my.oschina.net/youdaotech/blog/5440241" target="_blank" rel="noopener">前端技术分享：页面性能优化问题复盘</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Gx2muPw2T9zYCdBPzIbzbg&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端灰度发布落地方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://my.osch
      
    
    </summary>
    
    
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="部署" scheme="http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2022-01】</title>
    <link href="http://yoursite.com/2022/01/30/weeks/2022/2022-01/"/>
    <id>http://yoursite.com/2022/01/30/weeks/2022/2022-01/</id>
    <published>2022-01-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7036162494573838367?utm_source=gold_browser_extension" target="_blank" rel="noopener">60+ 实用 React 工具库，助力你高效开发！</a></p><p><a href="https://www.infoq.cn/article/k1Qpf3FaxNHdb7yqQptg" target="_blank" rel="noopener">展望大前端的 2022：VR 大潮来袭，大前端迎来新机遇</a></p><p><a href="https://www.infoq.cn/article/PRfJpajWiffdE6CvDiJ6" target="_blank" rel="noopener">解读大前端的 2021 ：究竟“卷”出了什么名堂？</a></p><p><a href="https://cointelegraphcn.com/news/web30-future" target="_blank" rel="noopener">深度丨一文看懂 Web3.0 的昨天、今天与明天</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7036162494573838367?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;60+ 实用 React 工具库，助力
      
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
      <category term="大前端" scheme="http://yoursite.com/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-12】</title>
    <link href="http://yoursite.com/2021/12/30/weeks/2021/2021-12/"/>
    <id>http://yoursite.com/2021/12/30/weeks/2021/2021-12/</id>
    <published>2021-12-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://120.78.128.153/rustbook/ch00-00-introduction.html" target="_blank" rel="noopener">RUST 程序设计语言book</a></p><p>github:<a href="https://github.com/KaiserY/trpl-zh-cn" target="_blank" rel="noopener">https://github.com/KaiserY/trpl-zh-cn</a></p><p><a href="https://juejin.cn/post/7025868886914400293" target="_blank" rel="noopener">现代 Web 开发困局</a></p><p><a href="https://zhuanlan.zhihu.com/p/88616149" target="_blank" rel="noopener">现代 Web 开发的现状与未来（JSDC 2019 演讲全文）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://120.78.128.153/rustbook/ch00-00-introduction.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RUST 程序设计语言book&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;github:&lt;a hr
      
    
    </summary>
    
    
    
      <category term="rust" scheme="http://yoursite.com/tags/rust/"/>
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="微前端" scheme="http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Rust程序设计语言 入门总结</title>
    <link href="http://yoursite.com/2021/12/10/book/2021/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2021/12/10/book/2021/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/</id>
    <published>2021-12-10T02:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.958Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Cargo，内置的依赖管理器和构建工具，它能轻松增加、编译和管理依赖，并使其在 Rust 生态系统中保持一致。</li><li>Rustfmt 确保开发者遵循一致的代码风格。</li><li>Rust Language Server 为集成开发环境（IDE）提供了强大的代码补全和内联错误信息功能。</li></ul><h3 id="编译和运行是彼此独立的步骤"><a href="#编译和运行是彼此独立的步骤" class="headerlink" title="编译和运行是彼此独立的步骤"></a>编译和运行是彼此独立的步骤</h3><p>$ rustc main.rs</p><p>Rust 是一种 <strong>预编译静态类型</strong>（<em>ahead-of-time compiled</em>）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。</p><h2 id="Cargo"><a href="#Cargo" class="headerlink" title="Cargo"></a>Cargo</h2><p>Cargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。（我们把代码所需要的库叫做 <strong>依赖</strong>（<em>dependencies</em>））。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_cargo</span><br><span class="line">$ cargo build</span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>cargo build</code> 或 <code>cargo check</code> 构建项目。</li><li>可以使用 <code>cargo run</code> 一步构建并运行项目。</li><li>有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 <em>target/debug</em> 目录。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;Cargo，内置的依赖管理器和构建工具，它能轻松增加、编译和管理依赖，并使其在 Rust 生态系统中保持一致。&lt;/li&gt;
&lt;li&gt;Rustfmt 确保开发者遵循一致的代码风格。&lt;/li&gt;
&lt;li&gt;Rust Language Server 为集成开发环境（IDE）
      
    
    </summary>
    
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="rust" scheme="http://yoursite.com/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-11】</title>
    <link href="http://yoursite.com/2021/11/30/weeks/2021/2021-11/"/>
    <id>http://yoursite.com/2021/11/30/weeks/2021/2021-11/</id>
    <published>2021-11-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/7023623964110880782" target="_blank" rel="noopener">字节跳动Web Infra发起 Modern.js 开源项目</a></p><p><a href="https://juejin.cn/post/6844903828123320334" target="_blank" rel="noopener">使用JSDoc提高代码的可读性</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7023623964110880782&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;字节跳动Web Infra发起 Modern.js 开源项目&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;ht
      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="webgl" scheme="http://yoursite.com/tags/webgl/"/>
    
      <category term="微前端" scheme="http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-10】</title>
    <link href="http://yoursite.com/2021/10/30/weeks/2021/2021-10/"/>
    <id>http://yoursite.com/2021/10/30/weeks/2021/2021-10/</id>
    <published>2021-10-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.973Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/110543466" target="_blank" rel="noopener">MySQL 数据表设计规范</a><br><a href="https://juejin.cn/post/7002176233115123725" target="_blank" rel="noopener">Nest.js 实践总结</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/110543466&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MySQL 数据表设计规范&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.cn/post/7002
      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="webgl" scheme="http://yoursite.com/tags/webgl/"/>
    
      <category term="微前端" scheme="http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-09】</title>
    <link href="http://yoursite.com/2021/09/30/weeks/2021/2021-09/"/>
    <id>http://yoursite.com/2021/09/30/weeks/2021/2021-09/</id>
    <published>2021-09-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.973Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/03VvGsJ2IUx9fcdpMxbqhQ" target="_blank" rel="noopener">WebGL 概念和基础入门</a></p><p><a href="https://juejin.cn/post/7004661323124441102#heading-0" target="_blank" rel="noopener">从零到一实现企业级微前端框架</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/03VvGsJ2IUx9fcdpMxbqhQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WebGL 概念和基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juej
      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="webgl" scheme="http://yoursite.com/tags/webgl/"/>
    
      <category term="微前端" scheme="http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-08】</title>
    <link href="http://yoursite.com/2021/08/30/weeks/2021/2021-08/"/>
    <id>http://yoursite.com/2021/08/30/weeks/2021/2021-08/</id>
    <published>2021-08-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.973Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://jelly.jd.com/article/5e9d5ca110f7500156d48b42" target="_blank" rel="noopener">京喜前端自动化测试之路</a></p><p><a href="https://juejin.cn/post/6995334897065787422" target="_blank" rel="noopener">38个ES6-ES12的开发技巧</a></p><p><a href="https://zhuanlan.zhihu.com/p/269488323" target="_blank" rel="noopener">前端领域模型，重构前端研发模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://jelly.jd.com/article/5e9d5ca110f7500156d48b42&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;京喜前端自动化测试之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ju
      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="ES" scheme="http://yoursite.com/tags/ES/"/>
    
      <category term="自动化测试" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"/>
    
      <category term="领域模型" scheme="http://yoursite.com/tags/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>前端核心知识进阶</title>
    <link href="http://yoursite.com/2021/08/10/book/2021/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2021/08/10/book/2021/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/</id>
    <published>2021-08-10T02:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><ul><li>在函数体中，非显式或隐式地简单调用函数时，严格模式下，函数类的this被绑定到underfined上。在非严格模式下会绑定到全局对象window/global。</li><li>一般使用new构造的函数，构造函数内的this会被指定到新创建的对象上</li><li>一般通过apply/call/bind方法显式调用函数时，函数体内this会被绑定到指定参数的对象上</li><li>一般通过上下文对象调用函数时，函数体内的this会被绑定到该对象上</li><li>在箭头函数中，this的指向是由外层作业域来决定的</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;在函数体中，非显式或隐式地简单调用函数时，严格模式下，函数类的this被绑定到underfined上。在非严格模
      
    
    </summary>
    
    
    
      <category term="书籍" scheme="http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-07】</title>
    <link href="http://yoursite.com/2021/07/30/weeks/2021/2021-07/"/>
    <id>http://yoursite.com/2021/07/30/weeks/2021/2021-07/</id>
    <published>2021-07-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.973Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6979394726927532068" target="_blank" rel="noopener">源码浅析-Vue3中的13个全局Api</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6979394726927532068&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码浅析-Vue3中的13个全局Api&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-06】</title>
    <link href="http://yoursite.com/2021/06/30/weeks/2021/2021-06/"/>
    <id>http://yoursite.com/2021/06/30/weeks/2021/2021-06/</id>
    <published>2021-06-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.969Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/3u1HHGjBaxzMoMkkVAqk-A" target="_blank" rel="noopener">轮子库</a></p><p><a href="https://www.infoq.cn/article/dT002EZ7BiXGtMeU49qo" target="_blank" rel="noopener">2021 年大前端技术趋势解读</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/3u1HHGjBaxzMoMkkVAqk-A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;轮子库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/a
      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="组件" scheme="http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>前端月刊【2021-05】</title>
    <link href="http://yoursite.com/2021/05/30/weeks/2021/2021-05/"/>
    <id>http://yoursite.com/2021/05/30/weeks/2021/2021-05/</id>
    <published>2021-05-30T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.969Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/GXBWliuIGPe5LcZzKM2M8w" target="_blank" rel="noopener">前端开发者应该知道的 Centos/Docker/Nginx/Node/Jenkins 操作</a></p><p><a href="https://www.jianshu.com/p/2869d0306752/" target="_blank" rel="noopener">移动端适配</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/GXBWliuIGPe5LcZzKM2M8w&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前端开发者应该知道的 Centos/Docker/Nginx/Node/Jenkins 操作
      
    
    </summary>
    
    
    
      <category term="weeks" scheme="http://yoursite.com/tags/weeks/"/>
    
      <category term="部署" scheme="http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式在前端项目中的应用</title>
    <link href="http://yoursite.com/2021/05/07/basic/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2021/05/07/basic/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</id>
    <published>2021-05-07T01:00:00.000Z</published>
    <updated>2022-06-05T14:08:41.950Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设计模式的种类"><a href="#设计模式的种类" class="headerlink" title="设计模式的种类"></a><strong>设计模式的种类</strong></h4><h5 id="1、-创建型模式"><a href="#1、-创建型模式" class="headerlink" title="1、 创建型模式"></a><strong>1、 创建型模式</strong></h5><p>一般用于创建对象。<br>包括：单例模式,工厂方法模式,抽象工厂模式,建造者模式,原型模式。</p><h5 id="2、结构型模式"><a href="#2、结构型模式" class="headerlink" title="2、结构型模式"></a><strong>2、结构型模式</strong></h5><p>重点为“继承”关系，有着一层继承关系，且一般都有“代理”。<br>包括：适配器模式,桥接模式,组合模式,装饰器模式,外观模式,享元模式,代理模式,过滤器模式。</p><h5 id="3、行为型模式"><a href="#3、行为型模式" class="headerlink" title="3、行为型模式"></a><strong>3、行为型模式</strong></h5><p>职责的划分，各自为政，减少外部的干扰。<br>包括：命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式，责任链模式。</p><h4 id="前端常用的计模式应用实例"><a href="#前端常用的计模式应用实例" class="headerlink" title="前端常用的计模式应用实例"></a><strong>前端常用的计模式应用实例</strong></h4><h5 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h5><p>单例模式又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。一个极有可能重复出现的“实例”, 如果重复创建，将会产生性能消耗。如果借助第一次的实例，后续只是对该实例的重复使用，这样就达到了我们节省性能的目的。<br>全局弹窗是前端开发中一个比较常规的需求，一般情况下，同一时间只会存在一个全局弹窗，我们可以实现单例模式，保证每次实例化时返回的实际上是同一个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageBox</span> </span>&#123;</span><br><span class="line">    show() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"show"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    hide() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> getInstance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (!MessageBox.instance) &#123;</span><br><span class="line">            MessageBox.instance = <span class="keyword">new</span> MessageBox();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> MessageBox.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> box3 = MessageBox.getInstance();</span><br><span class="line"><span class="keyword">let</span> box4 = MessageBox.getInstance();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(box3 === box4); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面这种是比较常见的单例模式实现，但是这种方式存在一些弊端。因为它需要让调用方了解到通过Message.getInstance来获取单例。</p><p>又或者假设需求变更，可以通过存在二次弹窗，则需要改动不少地方，因为MessageBox除了实现常规的弹窗逻辑之外，还需要负责维护单例的逻辑。</p><p>因此，可以将初始化单例的逻辑单独维护，实现一个通用的、返回某个类对应单例的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSingleton</span>(<span class="params">ClassName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ClassName();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMessageBox = getSingleton(MessageBox);</span><br><span class="line"><span class="keyword">let</span> box5 = createMessageBox();</span><br><span class="line"><span class="keyword">let</span> box6 = createMessageBox();</span><br><span class="line"><span class="built_in">console</span>.log(box5 === box6);</span><br></pre></td></tr></table></figure><p>这样，通过createMessageBox返回的始终是同一个实例。如果在某些场景下需要生成另外的实例，则可以重新生成一个createMessageBox方法，或者直接调用new MessageBox()，这样就对之前的逻辑不会有任何影响。</p><h5 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h5><p>工厂模式提供了一种创建对象的方法，对使用方隐藏了对象的具体实现细节，并使用一个公共的接口来创建对象。</p><p>前端本地存储目前最常见的方案就是使用localStorage，为了避免在业务代码中各种getItem和setItem，我们可以做一下最简单的封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> themeModel = &#123;</span><br><span class="line">    name: <span class="string">"local_theme"</span>,</span><br><span class="line">    <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> val = localStorage.getItem(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">return</span> val &amp;&amp; jsON.parse(val);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(val) &#123;</span><br><span class="line">        localStorage.setItem(<span class="keyword">this</span>.name, jsON.stringify(val));</span><br><span class="line">    &#125;,</span><br><span class="line">    remove() &#123;</span><br><span class="line">        localStorage.removeItem(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">themeModel.get();</span><br><span class="line">themeModel.set(&#123; <span class="attr">darkMode</span>: <span class="literal">true</span> &#125;);</span><br></pre></td></tr></table></figure><p>这样，通过themeModel暴露的get、set接口，我们无需再维护local_theme。但上面的封装也存在一些可见的问题，如果需要新增多个 name，那么上面的模板代码需要重新写多遍吗？为了解决这个问题，我们可以创建Model对象的逻辑进行封装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> storageMap = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStorageModel</span>(<span class="params">key, storage = localStorage</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 相同key返回单例</span></span><br><span class="line">    <span class="keyword">if</span> (storageMap.has(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> storageMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> model = &#123;</span><br><span class="line">        key,</span><br><span class="line">        <span class="keyword">set</span>(val) &#123;</span><br><span class="line">            storage.setItem(<span class="keyword">this</span>.key, <span class="built_in">JSON</span>.stringify(val););</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> val = storage.getItem(<span class="keyword">this</span>.key);</span><br><span class="line">            <span class="keyword">return</span> val &amp;&amp; <span class="built_in">JSON</span>.parse(val);</span><br><span class="line">        &#125;,</span><br><span class="line">        remove() &#123;</span><br><span class="line">            storage.removeItem(<span class="keyword">this</span>.key);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    storageMap.set(key, model);</span><br><span class="line">    <span class="keyword">return</span> model;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> themeModel =  createStorageModel(<span class="string">'local_theme'</span>, localStorage)</span><br><span class="line"><span class="keyword">const</span> utmSourceModel = createStorageModel(<span class="string">'utm_source'</span>, sessionStorage)</span><br></pre></td></tr></table></figure><p>这样，我们就可以通过createStorageModel这个公共的接口来创建各种不同本地存储的对象，而无需关注创建对象的具体细节。</p><h5 id="3、策略模式"><a href="#3、策略模式" class="headerlink" title="3、策略模式"></a>3、策略模式</h5><p>策略模式，可以针对不同的状态，给出不同的算法或者结果。将层级相同的逻辑封装成可以组合和替换的策略方法，减少if…else代码，方便扩展后续功能。</p><p>表单校验是我们最常见的场景了，我们一般都会想到用if…else来判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onFormSubmit</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!params.name) &#123;</span><br><span class="line">        <span class="keyword">return</span> showError(<span class="string">"请填写昵称"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (params.name.length &gt; <span class="number">6</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> showError(<span class="string">"昵称最多6位字符"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/^1\d&#123;10&#125;$/</span>.test(params.phone))</span><br><span class="line">        <span class="keyword">return</span> showError(<span class="string">"请填写正确的手机号"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sendSubmit(params)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将所有字段的校验规则都堆叠在一起，代码量大，排查问题也是一个大麻烦。在遇见错误时，直接通过 return 跳过了后面的判断；如果我们希望直接展示每个字段的错误呢，那么改动的工作量又不少。</p><p>不过，在antd、ELementUI等框架盛行的年代，我们已经不再需要写这些复杂的表单校验，但是对于他们的实现原理，我们可以简单模拟一下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个校验的类，主要暴露了构造参数和validate两个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Schema</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(descriptor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.descriptor = descriptor; <span class="comment">// 传入定义的校验规则</span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// 拆分出一些更通用的规则，比如required(必填)、len(长度)、min/max(最值)等，可以尽可能地复用</span></span><br><span class="line">    handleRule(val, rule) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; key, params, message &#125; = rule;</span><br><span class="line">        <span class="keyword">let</span> ruleMap = &#123;</span><br><span class="line">            required() &#123;</span><br><span class="line">                <span class="keyword">return</span> !val;</span><br><span class="line">            &#125;,</span><br><span class="line">            max() &#123;</span><br><span class="line">                <span class="keyword">return</span> val &gt; params;</span><br><span class="line">            &#125;,</span><br><span class="line">            validator() &#123;</span><br><span class="line">                <span class="keyword">return</span> params(val);</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> handler = ruleMap[key];</span><br><span class="line">        <span class="keyword">if</span> (handler &amp;&amp; handler()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    validate(data) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(data);</span><br><span class="line">            <span class="keyword">let</span> errors = [];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys) &#123;</span><br><span class="line">                <span class="keyword">const</span> ruleList = <span class="keyword">this</span>.descriptor[key];</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(ruleList) || !ruleList.length) <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">const</span> val = data[key];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> rule <span class="keyword">of</span> ruleList) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.handleRule(val, rule);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                        errors.push(e.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (errors.length) &#123;</span><br><span class="line">                reject(errors);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明每个字段的校验逻辑</span></span><br><span class="line"><span class="keyword">const</span> descriptor = &#123;</span><br><span class="line">    nickname: [</span><br><span class="line">        &#123; <span class="attr">key</span>: <span class="string">"required"</span>, <span class="attr">message</span>: <span class="string">"请填写昵称"</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">key</span>: <span class="string">"max"</span>, <span class="attr">params</span>: <span class="number">6</span>, <span class="attr">message</span>: <span class="string">"昵称最多6位字符"</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">    phone: [</span><br><span class="line">        &#123; <span class="attr">key</span>: <span class="string">"required"</span>, <span class="attr">message</span>: <span class="string">"请填写电话号码"</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            key: <span class="string">"validator"</span>,</span><br><span class="line">            params(val) &#123;</span><br><span class="line">                <span class="keyword">return</span> !<span class="regexp">/^1\d&#123;10&#125;$/</span>.test(val);</span><br><span class="line">            &#125;,</span><br><span class="line">            message: <span class="string">"请填写正确的电话号码"</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始对数据进行校验</span></span><br><span class="line"><span class="keyword">const</span> validator = <span class="keyword">new</span> Schema(descriptor);</span><br><span class="line"><span class="keyword">const</span> params = &#123; <span class="attr">nickname</span>: <span class="string">""</span>, <span class="attr">phone</span>: <span class="string">"123000"</span> &#125;;</span><br><span class="line">validator.validate(params).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"success"</span>);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Schema主要暴露了构造参数和validate两个接口，是一个通用的工具类，而params是表单提交的数据源，因此主要的校验逻辑实际上是在descriptor中声明的。将常见的校验规则都放在ruleMap中，比之前各种不可复用的if..else判断更容易维护和迭代。</p><h5 id="4、状态模式"><a href="#4、状态模式" class="headerlink" title="4、状态模式"></a>4、状态模式</h5><p>状态模式允许一个对象在其内部状态改变的时候改变它的行为。状态模式的思路是：首先创建一个状态对象保存状态变量，然后封装好每种动作对应的状态，然后状态对象返回一个接口对象，它可以对内部的状态修改或者调用。</p><p>常见的使用场景，比如滚动加载，包含了初始化加载、加载成功、加载失败、滚动加载等状态，任意时间它只会处于一种状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个状态机</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">rollingLoad</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>._currentState = <span class="string">'init'</span></span><br><span class="line">    <span class="keyword">this</span>.states = &#123;</span><br><span class="line">        init: &#123; <span class="attr">failed</span>: <span class="string">'error'</span> &#125;,</span><br><span class="line">        init: &#123; <span class="attr">complete</span>: <span class="string">'normal'</span> &#125;,</span><br><span class="line">        normal: &#123; <span class="attr">rolling</span>: <span class="string">'loading'</span> &#125;,</span><br><span class="line">        loading: &#123; <span class="attr">complete</span>: <span class="string">'normal'</span> &#125;,</span><br><span class="line">        loading: &#123; <span class="attr">failed</span>: <span class="string">'error'</span> &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.actions = &#123;</span><br><span class="line">        init() &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'初始化加载，大loading'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        normal() &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'加载成功，正常展示'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        error() &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'加载失败'</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">        loading() &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'滚动加载'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  change(state) &#123;</span><br><span class="line">    <span class="comment">// 更改当前状态</span></span><br><span class="line">    <span class="keyword">let</span> to = <span class="keyword">this</span>.states[<span class="keyword">this</span>._currentState][state]</span><br><span class="line">    <span class="keyword">if</span>(to)&#123;</span><br><span class="line">        <span class="keyword">this</span>._currentState = to</span><br><span class="line">        <span class="keyword">this</span>.go()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go() &#123;</span><br><span class="line">    <span class="keyword">this</span>.actions[<span class="keyword">this</span>._currentState]()</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态更改的操作</span></span><br><span class="line"><span class="keyword">const</span> rollingLoad = <span class="keyword">new</span> rollingLoad()</span><br><span class="line">rollingLoad.go()</span><br><span class="line">rollingLoad.change(<span class="string">'complete'</span>)</span><br><span class="line">rollingLoad.change(<span class="string">'loading'</span>)</span><br></pre></td></tr></table></figure><p>这样，我们就可以通过状态变更，运行相应的函数，且状态之间存在联系。那么，看起来是不是和策略模式很像呢？其实不然，策略类的各个属性之间是平等平行的，它们之间没有任何联系。而状态机中的各个状态之间存在相互切换，且是被规定好了的。</p><h5 id="5、发布-订阅模式"><a href="#5、发布-订阅模式" class="headerlink" title="5、发布-订阅模式"></a>5、发布-订阅模式</h5><p>发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。</p><p>发布订阅模式大概是前端同学最熟悉的设计模式之一了，常见的事件监听addEventListener，各种属性方法onload、onchange，vue响应式数据，组件通信redux、eventBus等。</p><p>常见的获取登录信息，假设我们开发一个商城网站，网站里有 header 头部、nav 导航、消息列表、购物车等模块。</p><p>这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax 异步请求获取用户的登录信息。</p><p>比如用户的名字和头像要显示在 header 模块里，而这两个字段都来自用户登录后返回的信息。异步的问题通常也可以用回调函数来解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">login.succ(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line"> header.setAvatar( data.avatar); <span class="comment">// 设置 header 模块的头像</span></span><br><span class="line"> nav.setAvatar( data.avatar ); <span class="comment">// 设置导航模块的头像</span></span><br><span class="line"> message.refresh(); <span class="comment">// 刷新消息列表</span></span><br><span class="line"> cart.refresh(); <span class="comment">// 刷新购物车列表</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们还必须了解 header 模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种强耦合性会使程序变得不易拓展。</p><p>那么回头看看我们的发布—订阅模式，这种模式下，对用户信息感兴趣的业务模块可以自行订阅登录成功的消息事件。</p><p>当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发布登录成功的消息</span></span><br><span class="line">$.ajax( <span class="string">'http://xxx.com?login'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="comment">// 登录成功</span></span><br><span class="line"> login.trigger( <span class="string">'loginSucc'</span>, data); <span class="comment">// 发布登录成功的消息</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 各模块监听登录成功的消息</span></span><br><span class="line"><span class="keyword">var</span> header = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// header 模块</span></span><br><span class="line"> login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">     header.setAvatar( data.avatar );</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     setAvatar: <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log( <span class="string">'设置 header 模块的头像'</span> );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> nav = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// nav 模块</span></span><br><span class="line"> login.listen( <span class="string">'loginSucc'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"> data </span>)</span>&#123;</span><br><span class="line">     nav.setAvatar( data.avatar );</span><br><span class="line">   &#125;);</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">     setAvatar: <span class="function"><span class="keyword">function</span>(<span class="params"> avatar </span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log( <span class="string">'设置 nav 模块的头像'</span> );</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。</p><p>或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。</p><p>在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。</p><h5 id="6、迭代器模式"><a href="#6、迭代器模式" class="headerlink" title="6、迭代器模式"></a>6、迭代器模式</h5><p>迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</p><p>迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。</p><p>JS 也内置了多种遍历数组的方法如forEach、reduce等。对于数组的循环大家都轻车熟路了，在实际开发中，也可以通过循环来优化代码。</p><p>一个常见的开发场景是：通过 ua 判断当前页面的运行平台，方便执行不同的业务逻辑，最基本的写法当然是if…else。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PAGE_TYPE = &#123;</span><br><span class="line">    app: <span class="string">"app"</span>, <span class="comment">// app</span></span><br><span class="line">    wx: <span class="string">"wx"</span>, <span class="comment">// 微信</span></span><br><span class="line">    tiktok: <span class="string">"tiktok"</span>, <span class="comment">// 抖音</span></span><br><span class="line">    bili: <span class="string">"bili"</span>, <span class="comment">// B站</span></span><br><span class="line">    kwai: <span class="string">"kwai"</span>, <span class="comment">// 快手</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ua = navigator.userAgent;</span><br><span class="line">    <span class="keyword">let</span> pageType;</span><br><span class="line">    <span class="comment">// 移动端、桌面端微信浏览器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/xxx_app/i</span>.test(ua)) &#123;</span><br><span class="line">        pageType = app;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MicroMessenger/i</span>.test(ua)) &#123;</span><br><span class="line">        pageType = wx;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/aweme/i</span>.test(ua)) &#123;</span><br><span class="line">        pageType = tiktok;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/BiliApp/i</span>.test(ua)) &#123;</span><br><span class="line">        pageType = bili;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/Kwai/i</span>.test(ua)) &#123;</span><br><span class="line">        pageType = kwai;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考策略模式的思路，我们可以减少分支判断的出现，将每个平台的判断拆分成单独的策略:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isApp</span>(<span class="params">ua</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/xxx_app/i</span>.test(ua);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWx</span>(<span class="params">ua</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/MicroMessenger/i</span>.test(ua);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTiktok</span>(<span class="params">ua</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/aweme/i</span>.test(ua);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBili</span>(<span class="params">ua</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/BiliApp/i</span>.test(ua);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isKwai</span>(<span class="params">ua</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/Kwai/i</span>.test(ua);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> platformList = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"app"</span>, <span class="attr">validator</span>: isApp &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"wx"</span>, <span class="attr">validator</span>: isWx &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"tiktok"</span>, <span class="attr">validator</span>: isTiktok &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"bili"</span>, <span class="attr">validator</span>: isBili &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">"kwai"</span>, <span class="attr">validator</span>: isKwai &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 每个平台的名称与检测方法</span></span><br><span class="line">    <span class="keyword">const</span> ua = navigator.userAgent;</span><br><span class="line">    <span class="comment">// 遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> &#123; name, validator &#125; <span class="keyword">in</span> platformList) &#123;</span><br><span class="line">        <span class="keyword">if</span> (validator(ua)) &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;设计模式的种类&quot;&gt;&lt;a href=&quot;#设计模式的种类&quot; class=&quot;headerlink&quot; title=&quot;设计模式的种类&quot;&gt;&lt;/a&gt;&lt;strong&gt;设计模式的种类&lt;/strong&gt;&lt;/h4&gt;&lt;h5 id=&quot;1、-创建型模式&quot;&gt;&lt;a href=&quot;#1、-创建型模式
      
    
    </summary>
    
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
