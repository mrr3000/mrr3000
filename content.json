{"meta":{"title":"Marong's Note","subtitle":"","description":"","author":"Marong","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"ElasticSearch 学习笔记","slug":"book/video/202210ES学习笔记","date":"2022-10-05T06:42:04.000Z","updated":"2022-10-04T15:31:15.992Z","comments":true,"path":"2022/10/05/book/video/202210ES学习笔记/","link":"","permalink":"http://yoursite.com/2022/10/05/book/video/202210ES%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"01 开篇 结构化数据 mysql 非结构化数据 视频 图表 图片 半结构化数据 代码片断 EXCEL WORD 插件 elasticsearch-head chrome插件安装 Elasticsearch Kibanna IK分词器 https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.8.0 放入plugins重启 02 技术选型The Elastic Stack, 包括 Elasticsearch、 Kibana、 Beats 和 Logstash（也称为 ELK Stack）。能够安全可靠地获取任何来源、任何格式的数据，然后实时地对数据进行搜索、分析和可视化。 Elaticsearch，简称为 ES， ES 是一个开源的高扩展的分布式全文搜索引擎， 是整个 ElasticStack 技术栈的核心。 它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理 PB 级别的数据。 分布式 RESTFULL json 搜索 分析 03 ES 7.8 目录 含义 bin 可执行脚本目录 config 配置目录 jdk 内置 JDK目录 lib 类库 logs 日志目录 modules 模块目录 plugins 插件目录 解压后，进入 bin 文件目录，点击 elasticsearch.bat 文件启动 ES 服务 。 注意： 9300 端口为 Elasticsearch 集群间组件的通信端口， 9200 端口为浏览器访问的 http协议 RESTful 端口。 04 倒排索引正排索引（传统） id content 1001 my name is zhang san 1002 my name is li si 倒排索引 keyword id name 1001, 1002 zhang 1001 Elasticsearch 是面向文档型数据库，一条数据在这里就是一个文档。 为了方便大家理解，我们将 Elasticsearch 里存储文档数据和关系型数据库 MySQL 存储数据的概念进行一个类比 05 索引 创建、获取、删除创建 PUT http://localhost:9200/shopping查看所有索引 GET http://localhost:9200/_cat/indices?v12health status index uuid pri rep docs.count docs.deleted store.size pri.store.size yellow open shopping J0WlEhh4R7aDrfIc3AkwWQ 1 1 0 0 208b 208b 表头 含义 health 当前服务器健康状态： green(集群完整) yellow(单点正常、集群不完整) red(单点不正常) status 索引打开、关闭状态 index 索引名 uuid 索引统一编号 pri 主分片数量 rep 副本数量 docs.count 可用文档数量 docs.deleted 文档删除状态（逻辑删除） store.size 主分片和副分片整体占空间大小 pri.store.size 主分片占空间大小 查看单个索引 GET http://localhost:9200/shopping删除索引 DELETE http://localhost:9200/shopping06文档 创建创建 POST http://localhost:9200/shopping/_doc123456&#123; \"title\":\"小米手机\", \"category\":\"小米\", \"images\":\"http://www.gulixueyuan.com/xm.jpg\", \"price\":3999.00&#125; 创建时指定http://localhost:9200/shopping/_doc/107 文档 主键查询 &amp; 全量查询主键查询 GET http://localhost:9200/shopping/_doc/1查询索引下所有数据 GET http://localhost:9200/shopping/_search08 文档 全量修改 &amp; 局部修改 &amp; 删除全量修改 POST http://localhost:9200/shopping/_doc/1123456&#123; \"title\":\"华为手机\", \"category\":\"华为\", \"images\":\"http://www.gulixueyuan.com/hw.jpg\", \"price\":1999.00&#125; 局部修改 POST http://localhost:9200/shopping/_update/1123456&#123; \"doc\": &#123; \"title\":\"小米手机\", \"category\":\"小米\" &#125;&#125; 删除 DELETE http://localhost:9200/shopping/_doc/109 条件查询 &amp; 分页查询 &amp; 查询排序条件查询 - 路径带参 GET http://localhost:9200/shopping/_search?q=category:小米条件查询 - 请求体传参 GET http://localhost:9200/shopping/_search12345678910111213141516171819202122232425262728293031323334353637383940//查询条件&#123; \"query\":&#123; \"match\":&#123; \"category\":\"小米\" &#125; &#125;&#125;// 查询全部&#123; \"query\":&#123; \"match_all\":&#123;&#125; &#125;&#125;// 查询指定字段&#123; \"query\":&#123; \"match_all\":&#123;&#125; &#125;, \"_source\":[\"title\"]&#125;// 分页查询&#123; \"query\":&#123; \"match_all\":&#123;&#125; &#125;, \"from\":0, \"size\":2&#125;//查询排序&#123; \"query\":&#123; \"match_all\":&#123;&#125; &#125;, \"sort\":&#123; \"price\":&#123; \"order\":\"desc\" &#125; &#125;&#125; 10 多条件查询 &amp; 范围查询多条件查询 - 请求体传参 GET http://localhost:9200/shopping/_search12345678910111213141516171819202122232425262728293031323334353637383940// bool 多条件 Must 且的关系需要同时满足&#123; \"query\":&#123; \"bool\":&#123; \"must\":[&#123; \"match\":&#123; \"category\":\"小米\" &#125; &#125;,&#123; \"match\":&#123; \"price\":3999.00 &#125; &#125;] &#125; &#125;&#125;// bool 多条件 should 或的关系 &#123; \"query\":&#123; \"bool\":&#123; \"should\":[&#123; \"match\":&#123; \"category\":\"小米\" &#125; &#125;,&#123; \"match\":&#123; \"category\":\"华为\" &#125; &#125;] &#125;, // 过滤 范围查询 \"filter\":&#123; \"range\":&#123; \"price\":&#123; \"gt\":2000 &#125; &#125; &#125; &#125;&#125; 11 文档 全文检索 &amp; 完全匹配 &amp; 高亮查询GET http://localhost:9200/shopping/_search1234567891011121314151617181920212223242526272829// 全文检索 查小米 和华为 都会返回&#123; \"query\":&#123; \"match\":&#123; \"category\" : \"小华\" &#125; &#125;&#125;//完全匹配 只查华为&#123; \"query\":&#123; \"match_phrase\":&#123; \"category\" : \"为\" &#125; &#125;&#125;// 高亮查询&#123; \"query\":&#123; \"match_phrase\":&#123; \"category\" : \"为\" &#125; &#125;, \"highlight\":&#123; \"fields\":&#123; \"category\":&#123;&#125;//&lt;----高亮这字段 &#125; &#125;&#125; 12 文档 聚合查询GET http://localhost:9200/shopping/_search1234567891011121314151617181920&#123; \"aggs\":&#123;//聚合操作 \"price_group\":&#123;//名称，随意起名 \"terms\":&#123;//分组 \"field\":\"price\"//分组字段 &#125; &#125; &#125;&#125;// 对所有手机价格求平均值&#123; \"aggs\":&#123; \"price_avg\":&#123;//名称，随意起名 \"avg\":&#123;//求平均 \"field\":\"price\" &#125; &#125; &#125;, \"size\":0&#125; 13 文档 映射关系有了索引库，等于有了数据库中的 database。 接下来就需要建索引库(index)中的映射了，类似于数据库(database)中的表结构(table)。 创建数据库表需要设置字段名称，类型，长度，约束等；索引库也一样，需要知道这个类型下有哪些字段，每个字段有哪些约束信息，这就叫做映射(mapping)。 创建映射 PUT http://localhost:9200/user/_mapping12345678910111213141516&#123; \"properties\": &#123; \"name\":&#123; \"type\": \"text\", //做分词 \"index\": true &#125;, \"sex\":&#123; \"type\": \"keyword\",//不分词 只能完全为”男的“完全匹配，才能得出原数据。 \"index\": true //是否索引 &#125;, \"tel\":&#123; \"type\": \"keyword\", \"index\": false // 根据tel查询，不会返回结果，因为不做索引 &#125; &#125;&#125; GET http://localhost:9200/user/_mapping12345678910111213141516171819# response&#123; \"user\": &#123; \"mappings\": &#123; \"properties\": &#123; \"name\": &#123; \"type\": \"text\" &#125;, \"sex\": &#123; \"type\": \"keyword\" &#125;, \"tel\": &#123; \"type\": \"keyword\", \"index\": false &#125; &#125; &#125; &#125;&#125; 14 ES环境部署 win / linux 单机 或 集群单机 &amp; 集群单台 Elasticsearch 服务器提供服务，往往都有最大的负载能力，超过这个阈值，服务器性能就会大大降低甚至不可用，所以生产环境中，一般都是运行在指定服务器集群中。除了负载能力，单点服务器也存在其他问题： 单台机器存储容量有限 单服务器容易出现单点故障，无法实现高可用 单服务的并发处理能力有限 配置服务器集群时，集群中节点数量没有限制，大于等于 2 个节点就可以看做是集群了。一般出于高性能及高可用方面来考虑集群中节点数量都是 3 个以上 总之，集群能提高性能，增加容错。 集群 Cluster一个集群就是由一个或多个服务器节点组织在一起，共同持有整个的数据，并一起提供索引和搜索功能。一个 Elasticsearch 集群有一个唯一的名字标识，这个名字默认就是”elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群。 节点 Node集群中包含很多服务器， 一个节点就是其中的一个服务器。 作为集群的一部分，它存储数据，参与集群的索引和搜索功能。 一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于 Elasticsearch 集群中的哪些节点。 一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。 在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何 Elasticsearch 节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。 config/elasticsearch.ymlnode-1001 节点12345678910111213141516171819202122#节点 1 的配置信息：#集群名称，节点之间要保持一致cluster.name: my-elasticsearch#节点名称，集群内要唯一node.name: node-1001node.master: truenode.data: true#ip 地址network.host: localhost#http 端口http.port: 1001#tcp 监听端口transport.tcp.port: 9301#discovery.seed_hosts: [\"localhost:9301\", \"localhost:9302\",\"localhost:9303\"]#discovery.zen.fd.ping_timeout: 1m#discovery.zen.fd.ping_retries: 5#集群内的可以被选为主节点的节点列表#cluster.initial_master_nodes: [\"node-1\", \"node-2\",\"node-3\"]#跨域配置#action.destructive_requires_name: truehttp.cors.enabled: truehttp.cors.allow-origin: \"*\" node-1002 节点12345678910111213141516171819202122#节点 2 的配置信息：#集群名称，节点之间要保持一致cluster.name: my-elasticsearch#节点名称，集群内要唯一node.name: node-1002node.master: truenode.data: true#ip 地址network.host: localhost#http 端口http.port: 1002#tcp 监听端口transport.tcp.port: 9302discovery.seed_hosts: [\"localhost:9301\"]discovery.zen.fd.ping_timeout: 1mdiscovery.zen.fd.ping_retries: 5#集群内的可以被选为主节点的节点列表#cluster.initial_master_nodes: [\"node-1\", \"node-2\",\"node-3\"]#跨域配置#action.destructive_requires_name: truehttp.cors.enabled: truehttp.cors.allow-origin: \"*\" node-1003 节点1234567891011121314151617181920212223#节点 3 的配置信息：#集群名称，节点之间要保持一致cluster.name: my-elasticsearch#节点名称，集群内要唯一node.name: node-1003node.master: truenode.data: true#ip 地址network.host: localhost#http 端口http.port: 1003#tcp 监听端口transport.tcp.port: 9303#候选主节点的地址，在开启服务后可以被选为主节点discovery.seed_hosts: [\"localhost:9301\", \"localhost:9302\"]discovery.zen.fd.ping_timeout: 1mdiscovery.zen.fd.ping_retries: 5#集群内的可以被选为主节点的节点列表#cluster.initial_master_nodes: [\"node-1\", \"node-2\",\"node-3\"]#跨域配置#action.destructive_requires_name: truehttp.cors.enabled: truehttp.cors.allow-origin: \"*\" 测试集群 GET http://127.0.0.1:1001/_cluster/health GET http://127.0.0.1:1002/_cluster/health GET http://127.0.0.1:1003/_cluster/health status字段指示着当前集群在总体上是否工作正常。它的三种颜色含义如下： green：所有的主分片和副本分片都正常运行。 yellow：所有的主分片都正常运行，但不是所有的副本分片都正常运行。 red：有主分片没能正常运行。 15 进阶-核心概念索引Index一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母），并且当我们要对这个索引中的文档进行索引、搜索、更新和删除（CRUD）的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。 能搜索的数据必须索引，这样的好处是可以提高查询速度，比如：新华字典前面的目录就是索引的意思，目录可以提高查询速度。 Elasticsearch 索引的精髓：一切设计都是为了提高搜索的性能。 类型Type在一个索引中，你可以定义一种或多种类型。 一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。不同的版本，类型发生了不同的变化。 文档Document一个文档是一个可被索引的基础信息单元，也就是一条数据。 比如：你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以 JSON（Javascript Object Notation）格式来表示，而 JSON 是一个到处存在的互联网数据交互格式。 在一个 index/type 里面，你可以存储任意多的文档。 字段Field相当于是数据表的字段，对文档数据根据不同属性进行的分类标识。 映射Mappingmapping 是处理数据的方式和规则方面做一些限制，如：某个字段的数据类型、默认值、分析器、是否被索引等等。这些都是映射里面可以设置的，其它就是处理 ES 里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。 分片Shards一个索引可以存储超出单个节点硬件限制的大量数据。比如，一个具有 10 亿文档数据的索引占据 1TB 的磁盘空间，而任一节点都可能没有这样大的磁盘空间。 或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch 提供了将索引划分成多份的能力，每一份就称之为分片。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。 分片很重要，主要有两方面的原因： 允许你水平分割 / 扩展你的内容容量。 允许你在分片之上进行分布式的、并行的操作，进而提高性能/吞吐量。 至于一个分片怎样分布，它的文档怎样聚合和搜索请求，是完全由 Elasticsearch 管理的，对于作为用户的你来说，这些都是透明的，无需过分关心。 被混淆的概念是，一个 Lucene 索引 我们在 Elasticsearch 称作 分片 。 一个Elasticsearch 索引 是分片的集合。 当 Elasticsearch 在索引中搜索的时候， 他发送查询到每一个属于索引的分片（Lucene 索引），然后合并每个分片的结果到一个全局的结果集。 Lucene 是 Apache 软件基金会 Jakarta 项目组的一个子项目，提供了一个简单却强大的应用程式接口，能够做全文索引和搜寻。在 Java 开发环境里 Lucene 是一个成熟的免费开源工具。就其本身而言， Lucene 是当前以及最近几年最受欢迎的免费 Java 信息检索程序库。但 Lucene 只是一个提供全文搜索功能类库的核心工具包，而真正使用它还需要一个完善的服务框架搭建起来进行应用。 目前市面上流行的搜索引擎软件，主流的就两款： Elasticsearch 和 Solr,这两款都是基于 Lucene 搭建的，可以独立部署启动的搜索引擎服务软件。由于内核相同，所以两者除了服务器安装、部署、管理、集群以外，对于数据的操作 修改、添加、保存、查询等等都十分类似。 副本Replicas在一个网络 / 云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的， Elasticsearch 允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片(副本)。 复制分片之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。 扩展你的搜索量/吞吐量，因为搜索可以在所有的副本上并行运行。 总之，每个索引可以被分成多个分片。一个索引也可以被复制 0 次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。 分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。 默认情况下，Elasticsearch 中的每个索引被分片 1 个主分片和 1 个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有 1 个主分片和另外 1 个复制分片（1 个完全拷贝），这样的话每个索引总共就有 2 个分片， 我们需要根据索引需要确定分片个数。 分配Allocation将分片分配给某个节点的过程，包括分配主分片或者副本。如果是副本，还包含从主分片复制数据的过程。这个过程是由 master 节点完成的。 16 进阶 - 系统架构 一个运行中的 Elasticsearch 实例称为一个节点，而集群是由一个或者多个拥有相同cluster.name 配置的节点组成， 它们共同承担数据和负载的压力。当有节点加入集群中或者从集群中移除节点时，集群将会重新平均分布所有的数据。 当一个节点被选举成为主节点时， 它将负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等。 而主节点并不需要涉及到文档级别的变更和搜索等操作，所以当集群只拥有一个主节点的情况下，即使流量的增加它也不会成为瓶颈。 任何节点都可以成为主节点。我们的示例集群就只有一个节点，所以它同时也成为了主节点。 作为用户，我们可以将请求发送到集群中的任何节点 ，包括主节点。 每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点。 无论我们将请求发送到哪个节点，它都能负责从各个包含我们所需文档的节点收集回数据，并将最终结果返回給客户端。 Elasticsearch 对这一切的管理都是透明的。 17 进阶 - 单节点集群 / 故障转移 / 水平扩容12345678#PUT http://127.0.0.1:1001/users// 每个主分片拥有一个副本分片&#123; \"settings\" : &#123; \"number_of_shards\" : 3, // 3 个主分片 \"number_of_replicas\" : 1 // 1个副本 &#125;&#125; （1）集群是单节点 所有3个主分片都被分配到了node-1 13 个副本分片都是 Unassigned，它们都没有被分配到任何节点。 在同 一个节点上既保存原始数据又保存副本是没有意义的，因为一旦失去了那个节点，我们也将丢失该节点 上的所有副本数据。 （2）故障转移当集群中只有一个节点在运行时，意味着会有一个单点故障问题——没有冗余。 幸运的是，我们只需再启动一个节点即可防止数据丢失。 当你在同一台机器上启动了第二个节点时，只要它和第一个节点有同样的 cluster.name 配置，它就会自动发现集群并加入到其中。但是在不同机器上启动节点的时候，为了加入到同一集群，你需要配置一个可连接到的单播主机列表。之所以配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。 （3）水平扩容1234#PUT http://127.0.0.1:1001/users/_settings&#123; \"number_of_replicas\" : 2&#125; (4) 应对故障集群可以将缺失的副本分片再次进行分配，那么集群的状态也将恢复成之前的状态。 如果 Node 1 依然拥有着之前的分片，它将尝试去重用它们，同时仅从主分片复制发生了修改的数据文件。和之前的集群相比，只是 Master 节点切换了。 12// 若NODE-1停止了 确保有如下配置，会恢复之前的状态进行再次分配，只是不再是master了discovery.seed_hosts: [\"localhost:9302\", \"localhost:9303\"] 18 进阶 - 路由计算 分片控制（1）路由计算 ： 当创建索引时是根据公式决定放到哪个片分中的12shard = hash(routing) % number_of_primary_shards// routing 是一个可变值，默认是文档的 _id ，也可以设置成一个自定义的值。 routing 通过hash 函数生成一个数字，然后这个数字再除以 number_of_primary_shards （主分片的数量）后得到余数 。这个分布在 0 到 number_of_primary_shards-1 之间的余数，就是我们所寻求的文档所在分片的位置。 （2）分片控制我们可以发送请求到集群中的任一节点。每个节点都有能力处理任意请求。每个节点都知道集群中任一文档位置，所以可以直接将请求转发到需要的节点上。在下面的例子中，如果将所有的请求发送到Node 1001，我们将其称为协调节点coordinating node 协调节点。 当发送请求的时候， 为了扩展负载，更好的做法是轮询集群中所有的节点。 （3）数据写流程新建、索引和删除 都是写操作，必须在主分片完成后才会被复制到相关的副本分片上。 （4）数据读流程在处理读取请求时，协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡。在文档被检索时，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。 在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档。 一旦索引请求成功返回给用户，文档在主分片和副本分片都是可用的。 （5）更新流程 （6）批量操作流程 19 进阶 - 倒排索引分片是Elasticsearch最小的工作单元。但是究竟什么是一个分片，它是如何工作的？ 传统的数据库每个字段存储单个值，但这对全文检索并不够。文本字段中的每个单词需要被搜索，对数据库意味着需要单个字段有索引多值的能力。最好的支持是一个字段多个值需求的数据结构是倒排索引。 倒排索引原理Elasticsearch使用一种称为倒排索引的结构，它适用于快速的全文搜索。 见其名，知其意，有倒排索引，肯定会对应有正向索引。正向索引（forward index），反向索引（inverted index）更熟悉的名字是倒排索引。 所谓的正向索引，就是搜索引擎会将待搜索的文件都对应一个文件ID，搜索时将这个ID和搜索关键字进行对应，形成K-V对，然后对关键字进行统计计数。 20 进阶 - 文档分析（1）分析包含下面的过程： 将一块文本分成适合于倒排索引的独立的词条。 将这些词条统一化为标准格式以提高它们的“可搜索性”，或者recall。 （2）分析器执行上面的工作。分析器实际上是将三个功能封装到了一个包里 字符过滤器：首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉 HTML，或者将 &amp; 转化成 and。 分词器：其次，字符串被分词器分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。 Token 过滤器：最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化Quick ），删除词条（例如， 像 a， and， the 等无用词），或者增加词条（例如，像jump和leap这种同义词） （3）内置分析器Elasticsearch还附带了可以直接使用的预包装的分析器。接下来我们会列出最重要的分析器。为了证明它们的差异，我们看看每个分析器会从下面的字符串得到哪些词条： 1&quot;Set the shape to semi-transparent by calling set_trans(5)&quot; 标准分析器标准分析器是Elasticsearch 默认使用的分析器。它是分析各种语言文本最常用的选择。它根据Unicode 联盟定义的单词边界划分文本。删除绝大部分标点。最后，将词条小写。它会产生： 1set, the, shape, to, semi, transparent, by, calling, set_trans, 5 简单分析器简单分析器在任何不是字母的地方分隔文本，将词条小写。它会产生： 1set, the, shape, to, semi, transparent, by, calling, set, trans 空格分析器空格分析器在空格的地方划分文本。它会产生: 1Set, the, shape, to, semi-transparent, by, calling, set_trans(5) 语言分析器特定语言分析器可用于很多语言。它们可以考虑指定语言的特点。例如，英语分析器附带了一组英语无用词（常用单词，例如and或者the ,它们对相关性没有多少影响），它们会被删除。由于理解英语语法的规则，这个分词器可以提取英语单词的词干。 英语分词器会产生下面的词条： 1set, shape, semi, transpar, call, set_tran, 5 注意看transparent、calling和 set_trans已经变为词根格式。 （4） 分析器使用场景 当你查询一个全文域时，会对查询字符串应用相同的分析器，以产生正确的搜索词条列表。 当你查询一个精确值域时，不会分析查询字符串，而是搜索你指定的精确值。 （5）指定分析器当Elasticsearch在你的文档中检测到一个新的字符串域，它会自动设置其为一个全文字符串域，使用 标准 分析器对它进行分析。你不希望总是这样。可能你想使用一个不同的分析器，适用于你的数据使用的语言。有时候你想要一个字符串域就是一个字符串域，不使用分析，直接索引你传入的精确值，例如用户 ID 或者一个内部的状态域或标签。要做到这一点，我们必须手动指定这些域的映射。 （细粒度指定分析器） （6）IK分词器安装插件后 1234567# GET http://localhost:9200/_analyze&#123; \"text\":\"测试单词\", \"analyzer\":\"ik_max_word\"&#125;// ik_max_word：会将文本做最细粒度的拆分。// ik_smart：会将文本做最粗粒度的拆分。 扩展词汇 首先进入 ES 根目录中的 plugins 文件夹下的 ik 文件夹，进入 config 目录，创建 custom.dic文件，写入“弗雷尔卓德”。 同时打开 IKAnalyzer.cfg.xml 文件，将新建的 custom.dic 配置其中。 重启 ES 服务器 。 （7）自定义分析器虽然Elasticsearch带有一些现成的分析器，然而在分析器上Elasticsearch真正的强大之处在于，你可以通过在一个适合你的特定数据的设置之中组合字符过滤器、分词器、词汇单元过滤器来创建自定义的分析器。在分析与分析器我们说过，一个分析器就是在一个包里面组合了三种函数的一个包装器，三种函数按照顺序被执行： 字符过滤器字符过滤器用来整理一个尚未被分词的字符串。例如，如果我们的文本是HTML格式的，它会包含像或者这样的HTML标签，这些标签是我们不想索引的。我们可以使用html清除字符过滤器来移除掉所有的HTML标签，并且像把&Aacute;转换为相对应的Unicode字符Á 这样，转换HTML实体。一个分析器可能有0个或者多个字符过滤器。 分词器一个分析器必须有一个唯一的分词器。分词器把字符串分解成单个词条或者词汇单元。标准分析器里使用的标准分词器把一个字符串根据单词边界分解成单个词条，并且移除掉大部分的标点符号，然而还有其他不同行为的分词器存在。 ​ 例如，关键词分词器完整地输出接收到的同样的字符串，并不做任何分词。空格分词器只根据空格分割文本。正则分词器根据匹配正则表达式来分割文本。 词单元过滤器经过分词，作为结果的词单元流会按照指定的顺序通过指定的词单元过滤器。词单元过滤器可以修改、添加或者移除词单元。我们已经提到过lowercase和stop词过滤器，但是在Elasticsearch 里面还有很多可供选择的词单元过滤器。词干过滤器把单词遏制为词干。ascii_folding过滤器移除变音符，把一个像”très”这样的词转换为“tres”。 ​ ngram和 edge_ngram词单元过滤器可以产生适合用于部分匹配或者自动补全的词单元。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 自定义创建分析器例子#PUT http://localhost:9200/my_index&#123; \"settings\": &#123; \"analysis\": &#123; \"char_filter\": &#123; \"&amp;_to_and\": &#123; \"type\": \"mapping\", \"mappings\": [ \"&amp;=&gt; and \" ] &#125; &#125;, \"filter\": &#123; \"my_stopwords\": &#123; \"type\": \"stop\", \"stopwords\": [ \"the\", \"a\" ] &#125; &#125;, \"analyzer\": &#123; \"my_analyzer\": &#123; \"type\": \"custom\", \"char_filter\": [ \"html_strip\", \"&amp;_to_and\" ], \"tokenizer\": \"standard\", \"filter\": [ \"lowercase\", \"my_stopwords\" ] &#125; &#125; &#125; &#125;&#125;// 创建后使用# GET http://127.0.0.1:9200/my_index/_analyze&#123; \"text\":\"The quick &amp; brown fox\", \"analyzer\": \"my_analyzer\"&#125; 21 进阶 - 文档控制文档冲突当我们使用index API更新文档，可以一次性读取原始文档，做我们的修改，然后重新索引整个文档。最近的索引请求将获胜：无论最后哪一个文档被索引，都将被唯一存储在 Elasticsearch 中。如果其他人同时更改这个文档，他们的更改将丢失。 悲观并发控制这种方法被关系型数据库广泛使用，它假定有变更冲突可能发生，因此阻塞访问资源以防止冲突。一个典型的例子是读取一行数据之前先将其锁住，确保只有放置锁的线程能够对这行数据进行修改。 乐观并发控制Elasticsearch 中使用的这种方法假定冲突是不可能发生的，并且不会阻塞正在尝试的操作。然而，如果源数据在读写当中被修改，更新将会失败。应用程序接下来将决定该如何解决冲突。例如，可以重试更新、使用新的数据、或者将相关情况报告给用户。 22 优化 - 硬件选择Elasticsearch 的基础是 Lucene，所有的索引和文档数据是存储在本地的磁盘中，具体的路径可在 ES 的配置文件…/config/elasticsearch.yml中配置，如下： 12345678## Path to directory where to store the data (separate multiple locations by comma):#path.data: /path/to/data## Path to log files:#path.logs: /path/to/logs 磁盘在现代服务器上通常都是瓶颈。Elasticsearch重度使用磁盘，你的磁盘能处理的吞吐量越大，你的节点就越稳定。这里有一些优化磁盘I/O的技巧： 使用SSD就像其他地方提过的，他们比机械磁盘优秀多了。 使用RAID0。条带化RAID会提高磁盘IO，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验RAID，因为副本已经提供了这个功能。 另外，使用多块硬盘，并允许Elasticsearch 通过多个path data目录配置把数据条带化分配到它们上面。 不要使用远程挂载的存储，比如NFS或者SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的。 23 优化 - 分片策略合理设置分片数分片和副本的设计为 ES 提供了支持分布式和故障转移的特性，但并不意味着分片和副本是可以无限分配的。而且索引的分片完成分配后由于索引的路由机制，我们是不能重新修改分片数的。 可能有人会说，我不知道这个索引将来会变得多大，并且过后我也不能更改索引的大小，所以为了保险起见，还是给它设为 1000 个分片吧。但是需要知道的是，一个分片并不是没有代价的。需要了解： 一个分片的底层即为一个 Lucene 索引，会消耗一定文件句柄、内存、以及 CPU运转。 每一个搜索请求都需要命中索引中的每一个分片，如果每一个分片都处于不同的节点还好， 但如果多个分片都需要在同一个节点上竞争使用相同的资源就有些糟糕了。 用于计算相关度的词项统计信息是基于分片的。如果有许多分片，每一个都只有很少的数据会导致很低的相关度。 一个业务索引具体需要分配多少分片可能需要架构师和技术人员对业务的增长有个预先的判断，横向扩展应当分阶段进行。为下一阶段准备好足够的资源。 只有当你进入到下一个阶段，你才有时间思考需要作出哪些改变来达到这个阶段。一般来说，我们遵循一些原则： 控制每个分片占用的硬盘容量不超过 ES 的最大 JVM 的堆空间设置（一般设置不超过 32G，参考下文的 JVM 设置原则），因此，如果索引的总容量在 500G 左右，那分片大小在 16 个左右即可；当然，最好同时考虑原则 2。 考虑一下 node 数量，一般一个节点有时候就是一台物理机，如果分片数过多，大大超过了节点数，很可能会导致一个节点上存在多个分片，一旦该节点故障，即使保持了 1 个以上的副本，同样有可能会导致数据丢失，集群无法恢复。所以， 一般都设置分片数不超过节点数的 3 倍。 主分片，副本和节点最大数之间数量，我们分配的时候可以参考以下关系：节点数&lt;=主分片数 *（副本数+1） 推迟分片分配对于节点瞬时中断的问题，默认情况，集群会等待一分钟来查看节点是否会重新加入，如果这个节点在此期间重新加入，重新加入的节点会保持其现有的分片数据，不会触发新的分片分配。这样就可以减少 ES 在自动再平衡可用分片时所带来的极大开销。 通过修改参数 delayed_timeout ，可以延长再均衡的时间，可以全局设置也可以在索引级别进行修改： 123456#PUT /_all/_settings&#123; \"settings\": &#123; \"index.unassigned.node_left.delayed_timeout\": \"5m\" &#125;&#125; 24 优化 - 路由选择当我们查询文档的时候， Elasticsearch 如何知道一个文档应该存放到哪个分片中呢？它其实是通过下面这个公式来计算出来： shard = hash(routing) % number_of_primary_shards routing 默认值是文档的 id，也可以采用自定义值，比如用户 id。 不带routing查询在查询的时候因为不知道要查询的数据具体在哪个分片上，所以整个过程分为2个步骤 分发：请求到达协调节点后，协调节点将查询请求分发到每个分片上。 聚合：协调节点搜集到每个分片上查询结果，在将查询的结果进行排序，之后给用户返回结果。 带routing查询查询的时候，可以直接根据routing 信息定位到某个分配查询，不需要查询所有的分配，经过协调节点排序。向上面自定义的用户查询，如果routing 设置为userid 的话，就可以直接查询出数据来，效率提升很多。 25 优化 - 写入速度优化针对于搜索性能要求不高，但是对写入要求较高的场景，我们需要尽可能的选择恰当写优化策略。综合来说，可以考虑以下几个方面来提升写索引的性能： 加大Translog Flush，目的是降低Iops、Writeblock。 增加Index Refesh间隔，目的是减少Segment Merge的次数。 调整Bulk 线程池和队列。 优化节点间的任务分布。 优化Lucene层的索引建立，目的是降低CPU及IO。 优化存储设备 ES 是一种密集使用磁盘的应用，在段合并的时候会频繁操作磁盘，所以对磁盘要求较高，当磁盘速度提升之后，集群的整体性能会大幅度提高。 合理使用合并Lucene 以段的形式存储数据。当有新的数据写入索引时， Lucene 就会自动创建一个新的段。 随着数据量的变化，段的数量会越来越多，消耗的多文件句柄数及 CPU 就越多，查询效率就会下降。 由于 Lucene 段合并的计算量庞大，会消耗大量的 I/O，所以 ES 默认采用较保守的策略，让后台定期进行段合并。 减少 Refresh 的次数Lucene 在新增数据时，采用了延迟写入的策略，默认情况下索引的refresh_interval 为1 秒。 Lucene 将待写入的数据先写到内存中，超过 1 秒（默认）时就会触发一次 Refresh，然后 Refresh 会把内存中的的数据刷新到操作系统的文件缓存系统中。 如果我们对搜索的实效性要求不高，可以将 Refresh 周期延长，例如 30 秒。 这样还可以有效地减少段刷新次数，但这同时意味着需要消耗更多的 Heap 内存。 加大 Flush 设置Flush 的主要目的是把文件缓存系统中的段持久化到硬盘，当 Translog 的数据量达到 512MB 或者 30 分钟时，会触发一次 Flush。 index.translog.flush_threshold_size 参数的默认值是 512MB，我们进行修改。 增加参数值意味着文件缓存系统中可能需要存储更多的数据，所以我们需要为操作系统的文件缓存系统留下足够的空间。 减少副本的数量ES 为了保证集群的可用性，提供了 Replicas（副本）支持，然而每个副本也会执行分析、索引及可能的合并过程，所以 Replicas 的数量会严重影响写索引的效率。 当写索引时，需要把写入的数据都同步到副本节点，副本节点越多，写索引的效率就越慢。 如果我们需要大批量进行写入操作，可以先禁止Replica复制，设置index.number_of_replicas: 0 关闭副本。在写入完成后， Replica 修改回正常的状态。 26 优化 - 内存设置因为 ES 堆内存的分配需要满足以下两个原则： 不要超过物理内存的 50%： Lucene 的设计目的是把底层 OS 里的数据缓存到内存中。Lucene 的段是分别存储到单个文件中的，这些文件都是不会变化的，所以很利于缓存，同时操作系统也会把这些段文件缓存起来，以便更快的访问。如果我们设置的堆内存过大， Lucene 可用的内存将会减少，就会严重影响降低 Lucene 的全文本查询性能。 堆内存的大小最好不要超过 32GB：在 Java 中，所有对象都分配在堆上，然后有一个 Klass Pointer 指针指向它的类元数据。这个指针在 64 位的操作系统上为 64 位， 64 位的操作系统可以使用更多的内存（2^64）。在 32 位的系统上为 32 位， 32 位的操作系统的最大寻址空间为 4GB（2^32）。但是 64 位的指针意味着更大的浪费，因为你的指针本身大了。浪费内存不算，更糟糕的是，更大的指针在主内存和缓存器（例如 LLC, L1 等）之间移动数据的时候，会占用更多的带宽。 最终我们都会采用 31 G 设置 -Xms 31g -Xmx 31g 27 优化 - 重要配置 参数名 参数值 说明 cluster.name elasticsearch 配置 ES 的集群名称，默认值是 ES，建议改成与所存数据相关的名称， ES 会自动发现在同一网段下的 集群名称相同的节点。 node.name node-1 集群中的节点名，在同一个集群中不能重复。节点 的名称一旦设置，就不能再改变了。当然，也可以 设 置 成 服 务 器 的 主 机 名 称 ， 例 如 node.name:${HOSTNAME}。 node.master true 指定该节点是否有资格被选举成为 Master 节点，默 认是 True，如果被设置为 True，则只是有资格成为 Master 节点，具体能否成为 Master 节点，需要通 过选举产生。 node.data true 指定该节点是否存储索引数据，默认为 True。数据 的增、删、改、查都是在 Data 节点完成的。 index.number_of_shards 1 设置都索引分片个数，默认是 1 片。也可以在创建 索引时设置该值，具体设置为多大都值要根据数据 量的大小来定。如果数据量不大，则设置成 1 时效 率最高 index.number_of_replicas 1 设置默认的索引副本个数，默认为 1 个。副本数越 多，集群的可用性越好，但是写索引时需要同步的 数据越多。 transport.tcp.compress true 设置在节点间传输数据时是否压缩，默认为 False， 不压缩 discovery.zen.minimum_master_nodes 1 设置在选举 Master 节点时需要参与的最少的候选 主节点数，默认为 1。如果使用默认值，则当网络 不稳定时有可能会出现脑裂。 合 理 的 数 值 为 (master_eligible_nodes/2)+1 ， 其 中 master_eligible_nodes 表示集群中的候选主节点数 discovery.zen.ping.timeout 3s 设置在集群中自动发现其他节点时 Ping 连接的超 时时间，默认为 3 秒。 在较差的网络环境下需要设置得大一点，防止因误 判该节点的存活状态而导致分片的转移","categories":[],"tags":[{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"},{"name":"elastic","slug":"elastic","permalink":"http://yoursite.com/tags/elastic/"}]},{"title":"WebGL编程指南","slug":"book/2022/WebGL编程指南","date":"2022-10-03T02:00:00.000Z","updated":"2022-10-03T02:58:25.215Z","comments":true,"path":"2022/10/03/book/2022/WebGL编程指南/","link":"","permalink":"http://yoursite.com/2022/10/03/book/2022/WebGL%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/","excerpt":"","text":"`","categories":[],"tags":[{"name":"WebGL","slug":"WebGL","permalink":"http://yoursite.com/tags/WebGL/"}]},{"title":"HTTP图解","slug":"book/2022/HTTP图解","date":"2022-09-30T02:00:00.000Z","updated":"2022-10-02T01:41:35.911Z","comments":true,"path":"2022/09/30/book/2022/HTTP图解/","link":"","permalink":"http://yoursite.com/2022/09/30/book/2022/HTTP%E5%9B%BE%E8%A7%A3/","excerpt":"","text":"一、网络基础TCP/IP 网络基础，互联 网相关的各类协议族的总称 应用层(FTP)、传输层(TCP UDP)、网络层(数据包IP)、数据链路层(网卡NIC) URI统一资源标识符 URL统一资源定位符 二、HTTP协议 http协议用于客户端和服务器端之间的通信 通过请求和响应的交换达成通信 HTTP是不保存状态的协议，stateless无状态协议，不做持久化处理 通过请求URI定位资源 HTTP方法：GET请求访问已被URI识别的资源 POST用来传输实体的主体 DELETE删除指定资源 PUT传输文件 OPTIONS询问支持的方法 TRACE追踪路径（不常用，经常被跨站追踪） CONNECT要求用隧道协议连接代理进行TPC通信（主要使用SSL TSL） 持久连接：减少流量 keep-alive；使得多数请求管线化方法同时并行发送多个请求。 cookie管理状态：请求、响应报文都会协带 三、报文内的HTTP信息 HTTP报文分为 报文首部 和 报文主体 首部：请求行、状态行、首部字段 主体：报文message 8位组字节流 + 实体entity （有效载荷数据，包括实体首部+实体主体） 压缩传输的内容编码：gzip / compress / deflate / identity 分割发送的分块传输编码 发送多种数据的多部份对象集合：multipart/form-data multipart/byteranges 获取部份内容的范围请求 Range: bytes=5001-10000 内容协商返回最合适的内容：服务器驱动协商 Server-driven Negotiation 客户端驱动协商 Agent-driven Negotiation 透明协商 Transparent Negotiation 四、状态码 1XX 信息性状态码 接收 的请求正在处理 2XX 成功状态码 请求正常处理完结 200 成功处理 204 NOT Content 服务器接收的请求已成功处理，但在返回响应报文中不含实体的主体部份 206 Partial Content 客户端进行了范围请求Content-Range，服务器成功执行了这个部份的请求。 3XX 重定向状态码 需要进行附加操作以完成请求 301 Moved Permanently 永久性重定向 302 Found 临时性重定向 303 See Other 由于请求对应的资源存在着另一个URI，应该使用GET定向获取请求资源 304 Not Modified 服务器资源未改变，可直接使用客户端未过期的缓存 307 Temporary Redirect 临时重定向 4XX 客户端错误状态码 服务器无法处理请求 401 Unauthorized 请求未通过HTTP认证 403 Forbidden 对请求资源的访问被服务器拒绝了。未获得文件系统的访问权限。服务器不说明原因。 404 Not Found 服务器上无法找到请求的资源。服务器不说明原因。 5XX 服务器错误状态码 服务器处理请求出错 500 Internal Server Error 临时性故障，在执行请求时发生了错误 503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，无法处理请求 五、与HTTP协作的WEB服务器 用单台虚拟机可以实现绑定多个域名 通信数据转发程序： 代理（一种有转发功能的应用程序，扮演中间人） 缓存代理：会预先将资源的副本缓存在代理服务器上 透明代理：不对报文做任何加工 非透明代理：对报文做加工处理后再转发 网关（转发其它服务器通信数据的服务器）：具有一定安全信 隧道（相隔甚远的客户端和服务器两者之间进行中转，保持双方通信连接的应用程序）：更安全，使用SSL，本身不会解析HTTP，保持原样直接转发 保存资源的缓存 节省通信流量和时间 缓存有效期限 客户端缓存 六、HTTP首部 HTTP报文首部 请求报文：方法、URI、HTTP版本、HTTP首部字段 响应报文：HTTP版本、状态码、HTTP首部字段 HTTP首部字段 HTTP首部字段传递重要信息 HTTP首部字段结构：（字段名:字段值） HTTP首部字段类型：通用首部字段、请求首部字段、响应首部字段、实体首部字段 非HTTP/1.1首部字段：还有Cookie / Set-Cookie / Content-Disposition HTTP首部字段将定义成缓存代理和非缓存代理的行为 端到端End-to-end首部：会转发给请求、响应对应的最终接收目标，必须被转发。除以下8个逐跳首部，其它都是端到端。 逐跳Hop-by-hop首部：只对单次转发有效，会因通过缓存或代理不再转发 Connection\\Keep-Alive\\Proxy-Authenticate\\Proxy-Authorization\\Trailer\\TE\\Transfer-Encodeing\\Upgrade HTTP/1.1通用首部字段 Cache-Control 控制缓存行为 Connection 逐跳首部、连接的管理 Date 创建报文的日期时间 Piagma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言 Authorization 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在的服务器 If-Match 比较实体标记 ETag If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记 与If-Match相反 If-Range 资源未更新时发送实体Byte的范围请求 If-Unmodified-Since 比较资源的更新时间 与上面相反 Max-Forward 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中的URI的原始获取方 TE 传输编码的优先级 User-Agent HTTP客户端的程序信息 响应首部字段 Accept-Ranges 是否接受字节范围的请求 Age 推算资源创建经过的时间 ETag 资源的匹配信息 Location 令客户端重定向至指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的URI Content-Md5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期 的日期时间 Last-Modified 资源最后修改的日期旱 为Cookie服务的首部字段 Set-Cookie 服务器准备开始管理客户端状态时，会事先告知各种信息 Cookie 其它首部字段 X-Frame-Options 属于响应首部 用于控制网站内容在其它WEB的Frame标签内的显示问题，防止点击劫持 X-XSS-protechtion 属于响应首部 针对 跨站脚本 攻击XSS的一种对策 DNT 属于请求首部 拒绝个人信息被收集，拒绝被精准广告追踪的一种方法 P3P 属于响应首部 个人隐私变成一种仅供程序可理解的形式，达到保护用户隐私 七、确保WEB安全的HTTPS HTTP信息窃听（使用明文）身份伪装（不验证通信方身份）篡改（无法证明报文完整性）等安全问题 防止窃听：使用加密方式 通信加密SSL + TLS 内容加密 防止伪装：查明对方证书 防止篡改：散列值校验MD5 SHA-1 或 数字签名RSA HTTP+加密+认证+完整性保护=HTTPS(混合加密) 八、确认访问用户身份的认证 HTTP使用认证方式 BASIC认证（基本认证） DIGEST认证（摘要认证） SSL客户端认证 FormBase认证（基于表单认证）：Cookie管理Session会话 九、基于HTTP的功能追加协议 消除HTTP瓶颈的SPDY，GOOOGLE在2010发布的，缩短WEB页面加载时间50% 虽然相继出现AJAX，COMET等解决方法 SPDY的设计，未完全改写HTTP协议，以会话层形式加入，控制对数据的流动，采用HTTP建立通信连接 多路复用流 赋予请求优先级 压缩HTTP首部 推送功能 服务器提示功能 使用浏览器进行全双工通信的WEBSOCKET 推送功能 减少通信量 HTTP/2.0 十、WEB的攻击技术 因输出值转义不完全引发的安全漏洞 跨站脚本攻击 SQL注入攻击 OS命令注入攻击 HTTP首部注入攻击 邮件首部注入攻击 目录遍历攻击 远程文件 包含漏洞 因设置或设计上的缺陷引发的安全漏洞 强制浏览 不正确的错误消息处理 开放重定向 因会话管理疏忽引发的安全漏洞 会话劫持 会话固定攻击 跨站点请求伪造 其它安全漏洞 密码破解 点击劫持 DOS攻击 后门程序","categories":[],"tags":[{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"前端月刊【2022-09】","slug":"weeks/2022/2022-09","date":"2022-09-30T01:00:00.000Z","updated":"2022-10-03T02:32:33.205Z","comments":true,"path":"2022/09/30/weeks/2022/2022-09/","link":"","permalink":"http://yoursite.com/2022/09/30/weeks/2022/2022-09/","excerpt":"","text":"最全面的 Node.js 资源汇总推荐 前端知识体系导图","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"}]},{"title":"前端月刊【2022-08】","slug":"weeks/2022/2022-08","date":"2022-08-30T01:00:00.000Z","updated":"2022-10-03T02:22:11.902Z","comments":true,"path":"2022/08/30/weeks/2022/2022-08/","link":"","permalink":"http://yoursite.com/2022/08/30/weeks/2022/2022-08/","excerpt":"","text":"Kubernetes原理与架构初探","categories":[],"tags":[{"name":"k8s","slug":"k8s","permalink":"http://yoursite.com/tags/k8s/"}]},{"title":"前端月刊【2022-07】","slug":"weeks/2022/2022-07","date":"2022-07-30T01:00:00.000Z","updated":"2022-10-03T02:42:28.943Z","comments":true,"path":"2022/07/30/weeks/2022/2022-07/","link":"","permalink":"http://yoursite.com/2022/07/30/weeks/2022/2022-07/","excerpt":"","text":"使用 WebAssembly 打造定制 JS Runtime Web 3D 从入门到跑路 你不知道的 Rust","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://yoursite.com/tags/rust/"},{"name":"webassembly","slug":"webassembly","permalink":"http://yoursite.com/tags/webassembly/"},{"name":"webGL","slug":"webGL","permalink":"http://yoursite.com/tags/webGL/"}]},{"title":"前端月刊【2022-06】","slug":"weeks/2022/2022-06","date":"2022-06-30T01:00:00.000Z","updated":"2022-10-03T02:42:21.651Z","comments":true,"path":"2022/06/30/weeks/2022/2022-06/","link":"","permalink":"http://yoursite.com/2022/06/30/weeks/2022/2022-06/","excerpt":"","text":"深入浅出区块链技术 写给前端的区块链开发入门指南：零基础开发基于以太坊智能合约的 ICO DApp QCon 演讲：为什么前端工程师更应该掌握区块链 DApp 开发（上） 掘金 AMA：前端 + 区块链的跨界者–CSS魔法聊前端和区块链 DApp 【译】用JavaScript写一个区块链 区块链入门教程-阮一峰","categories":[],"tags":[{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"}]},{"title":"前端月刊【2022-05】","slug":"weeks/2022/2022-05","date":"2022-05-30T01:00:00.000Z","updated":"2022-10-03T02:03:30.591Z","comments":true,"path":"2022/05/30/weeks/2022/2022-05/","link":"","permalink":"http://yoursite.com/2022/05/30/weeks/2022/2022-05/","excerpt":"","text":"8 种技巧让你编写更简洁的 JavaScript 代码 1.4w字总结带你重学TypeScript","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"前端月刊【2022-04】","slug":"weeks/2022/2022-04","date":"2022-04-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.975Z","comments":true,"path":"2022/04/30/weeks/2022/2022-04/","link":"","permalink":"http://yoursite.com/2022/04/30/weeks/2022/2022-04/","excerpt":"","text":"86张脑图，一口气看完 React 2022 年的 React 生态 扔掉 Electron，拥抱基于 Rust 开发的 Tauri 50 多个提高前端人效率的工具、网站和书籍整理","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"小灰算法","slug":"book/2022/小灰算法","date":"2022-04-22T02:00:00.000Z","updated":"2022-06-05T14:08:41.959Z","comments":true,"path":"2022/04/22/book/2022/小灰算法/","link":"","permalink":"http://yoursite.com/2022/04/22/book/2022/%E5%B0%8F%E7%81%B0%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、算法概述1.1 算法algorithm和数据结构数据结构：线性结构（数组、链表、栈、队列、哈希表）、树、图、其它类型 1.2 时间复杂度 time complexity运行时间 ms基本操作执行次数T(n) n是规模 执行次数是线性的 T(n)=3n T(n)=O(n) 执行次数是对数计算的 T(n)=5logn T(n)=O(logn) 执行次数是常量 T(n)=2 T(n)=O(1) 执行次数是多项式 T(n)=0.5n² + 0.5n T(n)=O(n²) O(1) &lt; O(logn) &lt; O(n) &lt; O(n²) 1.3 空间复杂度 space complexity占用空间MB 常量空间 O(1) 线性空间 O(n) 二维空间 O(n²) 递归空间 方法调用栈 进栈 出栈 递归深度为n 空间复杂度为O(n) 二、数据结构基础2.1 数组 有限个相同类型的变量所组成的有序集合 在内存中顺序存储 读取、更新、插入、删除 扩容 2.2 链表 在内存中随机存储 单向链表-每一个节点包含两部分，一部分是存放数据的变量data，一部分是指向下一个节点的指针next 双向链表-还多一个指向前置节点的pre指针 查找、更新、插入 首尾中间、删除 首尾中间 2.3 栈和队列 栈 ： 线性数据结构；先入后出、最后入栈顶、最先入为栈底；出栈、入栈、只有栈顶才能出栈； 队列：单行隧道；先入先出、出口叫队头、入口叫队尾；入队、出队 2.4 散列表 散列表也叫做哈希表 提供了键key值value;写操作put；读操作get；扩容resize 三、树3.1 树和二叉树树：是n个节点的有限集，有且仅有一个特定的称为根的节点。 二叉树：每个节点最多有2个孩子 的节点。左孩子，右孩子 ，顺序固定。 满二叉树：所有非叶子节点都存在左右孩子 ，并且所有叶子节点都在同一层级上。（满二叉树每个分支都是满的） 完全二叉树：对一个有n个节点的二叉树，按层级顺序编号，则所有节点的编号为从1到n。如果这个树所有节点和同样深度的满二叉树的编号为从1到n的节点位置相同。 二叉树存储方式：链式存储结构和数组 3.2 二叉树遍历深度优先遍历前序遍历：根节点、左子树、右子树 中序遍历：左子树、根节点、右子树 后序遍历：左子树、右子树、根节点 广度优先遍历层序遍历：一层层的遍历 3.3 二叉堆（完全二叉树）最大堆：任何一个父节点的值，都大于或等于它的左右孩子节点的值。 最小堆：任何一个父节点的值，都小于或等于它的左右孩子节点的值。 二叉堆的根节点叫做堆顶。最大堆的堆顶是最大元素，最小堆的堆顶是最小元素。 3.4 优先队列二叉堆是实现优先队列的基础，队列先进先出。 入队列，将新元素置于队尾。出队列，队头元素最先被移除。 最大优先队列，无论入队顺序如何，都是当前最大的元素优先出队。 最小优先队列，无论入队顺序如何，都是当前最小的元素优先出队。 四、排序算法4.1 冒泡排序定义：把相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换它们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。 一种稳定排序 每一轮都要遍历所有元素，总共遍历无数数量 -1 轮 平均时间复杂度为O(n2) 鸡尾酒排序冒泡排序每一轮都是从左到右来比较元素，进行单向的位置交换的。 鸡尾酒排序的元素比较和交换过程是双向的。 4.2 快速排序（交换排序）定义：在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部份。(分治法) 选择基准元素 元素的交换：双边循环法、单边循环法 非递归实现 4.3 堆排序1、把无序数组构建成二叉堆。需要从小到大排序，则构建成最大堆；需要从大到小排序，则构建成最小堆。 2、循环删除堆顶元素，替换到二叉堆的末尾，调整堆产生新的堆顶。 4.4 计数排序和桶排序线性时间的排序 计数排序… 桶排序 创建这些桶并确定每个桶的区间范围 遍历原始数列，把元素对号入座放入各个桶中。 对每个树内部的元素分别进行排序。（显然只有第一个桶需要排序）","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"小灰","slug":"小灰","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%81%B0/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"如何成为一个会学习的人","slug":"book/2022/如何成为一个会学习的人","date":"2022-04-22T02:00:00.000Z","updated":"2022-06-05T14:29:00.903Z","comments":true,"path":"2022/04/22/book/2022/如何成为一个会学习的人/","link":"","permalink":"http://yoursite.com/2022/04/22/book/2022/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E4%BC%9A%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BA%BA/","excerpt":"","text":"全身心投入 将专注力应用学习的好处 能在短时间内取得成果 能把一天变成72小时 不再为了努力而努力 找到学习令人沉迷的要点 能够快速获得成就感 要重视“全身心投入”而非“效率” 一、学习停不下来！磨炼“专注力”！只有喜欢，才能擅长因为喜欢才全身心投入，并一直坚持下去的结果。无论是学习还是兴趣爱好，我都认为“只有喜欢，才能擅长”。即使做不到，也不要怕丢人，重要的是大胆地迈出第一步。只要始终保持喜欢的心态，就一定能够不断精进。 大家热衷的事情，要尝试去做只需增加“天线”，信息就会纷至沓来善于倾听才能善于学习经常带着问号，锻炼逻辑思维“遇到困难”更有利于吸取知识不顺利的时候毫不犹豫地妥协有时候需要妥协，放松自己。这才是持续下去的秘诀 利用“付出金钱就希望收回成本”的潜意识先尝试着去做，机会才能到来二、同时提高逻辑思维能力、记忆力、专注力的学习术五分钟回顾学习法 每1-2页回顾一次 每个项目总结一次 每个章节重新审视 迅速提高逻辑思维能力的“立场转换法“，反复论证AB角色提高记忆力、专注力的“散步锻炼法”随时随地能够自动复习的“自问自答法”通过音乐提升情绪的“自我动力转换法”一张A4纸就能飞速提高记忆固化率的“睡前检查法”体验成就感，稳定进步的“音效激励法”背诵复杂内容的“反复诵读法”打造超专注空间的“秘密基地法” - 狭小空间、消除诱惑轻松提高阅读速度的“速读捕获法“ - 词组 三、把“做不到”变成“做得到”！把不擅长的领域变成擅长的领域把学会的项目写出来、可视化只要遵守三个规则，就一定能全身心投入 快速反馈 可以控制 保持平衡轻松了解自己学习能力的方法 一点也不会 并不知道答案 看完答案解析就懂了 一定程度上了解想象“做”“不做”“实现”想办法“享受”学习战胜睡魔的五个方法深呼吸、营造沐浴晨光的环境、睡前泡个澡、做伸展运动、防蓝光 改变饮食习惯 提升专注力柠檬、葡萄糖、红茶 把无趣的世界变得有趣的承诺合同四、只有聪明之人才有的快乐学习的习惯专注学习需要养成某些习惯做让人赞叹不已的事被称赞、数字化目标、时间轴 给自己制造良好的反馈把看似毫无关系的事务联系起来，无论何时何地都在学习把时间和金钱赚回来从略感兴趣到乐此不疲必须要做的事情，要在最短时间内完成坚持本身就会产生成就感 朴实 X 脚踏实地 = 成就感有针对性的改造学习六个学习方法 费曼学习法 番茄工作法 金字塔原理 多元思维模型 5W2H分析思考法 康奈尔5R笔记法","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"}]},{"title":"前端月刊【2022-03】","slug":"weeks/2022/2022-03","date":"2022-03-30T01:00:00.000Z","updated":"2022-10-03T02:32:28.215Z","comments":true,"path":"2022/03/30/weeks/2022/2022-03/","link":"","permalink":"http://yoursite.com/2022/03/30/weeks/2022/2022-03/","excerpt":"","text":"深度：跨端技术的本质与现状 重构知识的供给模式 ——《数据平台》从思考到落地","categories":[],"tags":[{"name":"跨端","slug":"跨端","permalink":"http://yoursite.com/tags/%E8%B7%A8%E7%AB%AF/"},{"name":"数据平台","slug":"数据平台","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/"}]},{"title":"构建高性能WEB站点","slug":"book/2022/构建高性能WEB站点","date":"2022-03-10T02:00:00.000Z","updated":"2022-06-05T14:08:41.959Z","comments":true,"path":"2022/03/10/book/2022/构建高性能WEB站点/","link":"","permalink":"http://yoursite.com/2022/03/10/book/2022/%E6%9E%84%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BDWEB%E7%AB%99%E7%82%B9/","excerpt":"","text":"一、绪论了解等待的真相 查找瓶颈在哪里 增加带宽 减少网页中的HTTP请求数量 加快服务器脚本计算速度 使用动态内容缓存 将动态内容静态化 更换WEB服务器软件 页面组建分离 合理部署服务器 使用负载均衡 优化数据哭 考虑可扩展性 减少视觉等待 二、数据的网络传输增加带宽： bit/s 单位时间内的比特数 响应时间 = 发送时间 + 传输时间 + 处理时间 下载速度 = 数据量字节数/响应时间 互联互通：链接网络运营商 三、服务器并发处理能力吞吐率：前提条件 并发用户数、总请求数、请求资源描述，进行压力测试。 CPU并发计算：进程、线程、进程调度器、系统负载、进程切换、锁竞争。 系统调用：减少系统调用可以降低请求处理时间，提升吞吐率。 内存分配：Apache 内存池 、Nginx内存分配策略。 持久连接（长链接）：http 请求中长连接的声明 开启（ Connection:Keep-Alive）关闭（KeepAlive Off） 超时时间nginx（KeepAliveTimeout 30） I/O模型：同步阻塞、同步非阻塞、多路I/O就绪通知、内存映射、直接I/O、异步I/O 服务器并发策略 四、动态内容缓存重复的开销 缓存与速度：整页、局部、数据缓存、代码解释器缓存、web服务器缓存。 缓存与缓冲：关系到命中率的问题，缓冲是视频中负责写入磁盘。 页面缓存：指MVC框架中动态网页的缓存。 缓存持久化与查找 过期检查：对缓存的动态内容存在重复计算，对有效时间外的缓存清理。 把缓存放到内存中：常规的缓存放到磁盘中会增加I/O操作。 把缓存放到缓存服务器：memcached通过TCP将缓存存储在独立的缓存服务器中。 局部无缓存：对于一些动态更新的区域无缓存。 静态化内容： 直接访问缓存 更新策略：在数据更新时重新生成静态化内容（由用户动态触发）；定时重新生成静态化内容。 局部静态化：SSI 五、动态脚本加速Oppose缓存：动态内容编译成二进制可执行文件，也就是目标代码。 解释器扩展模块：第三方的编译程序。 脚本跟踪与分析 代码段执行时间 上下文信息收集：配合代码跟踪收集信息，记录当前上下文信息，比如当前行号、哪里被调用。 代码覆盖范围 函数跟踪 瓶颈分析 六、浏览器缓存http缓存协商：WEB服务器和浏览器之间 彻底消灭请求：浏览器缓存截止期限；性能方面，没有发起请求，就进行不了压力测试。 七、WEB服务器缓存URL映射：增加了I/O开销。 缓存响应内容：将内容交给WEB服务器缓存，准备好缓存区；缓存静态内容；缓存动态内容；控制有效期； 八、反向代理缓存反向代理：WEB服务器隐藏在代理服务器之后。 在反向代理上创建缓存：修改缓存规则、清除缓存、监控缓存命中率、从缓存命中率中寻找答案、缓存命中率和后端吞吐率的理想计算模型、和动态内容缓存一起工作 小心穿过代理 流量分配 九、WEB组件分离拥有不同的域名 浏览器并发数 动态内容：开启opcode缓存、足够快的CPU、足够大的内存、多进程、与数据库保持高速连接、可靠的数据中心 静态网页：支持epoll、非阻塞I/O、异步I/O、使用sendfile()系统调用、单进程、使用高速磁盘、使用RAID分区、购买足够的带宽 图片：持久连接 样式表：有效期为一年 脚本 视频 十、分布式缓存数据库的前端缓存区：读缓存区域、写缓存区域 使用memcached分布式缓存系统：使用key-value来存储数据、数据项设置过期时间、网络并发模型、对象序列化可将数据转化为二进制 读操作缓存：重复的身份验证、数据库索引、缓存用户登录状态 写操作缓存：直接更新、线程安全和锁竞争、原子加法 监控状态：空间使用率、缓存命中率、I/O流量 缓存扩展 十一、数据库性能优化提供友好的状态报告 正确使用索引：使用组合索引、使用慢查询分析工具、索引缓存、索引的代价 锁定与等待：减少表锁定等待、行锁定带来了什么？真的好吗？ 事务性表的性能 使用查询缓存 临时表 线程池 反规范化设计 放弃关系型数据库 十二、WEB负载均衡HTTP重定向 DNS负载均衡：多个A记录 反向代理负载均衡：转移和转发、按照权重分配任务、调度起的并发处理能力、扩展的制约、健康监测 IP负载均衡：DNAT反向NAT、用iptables来实现调度器、IPVS/ipvsadm、LVS-NAT、性能、动态调度策略、网关瓶颈、 直接路由：使用IP别名、将实际服务器接入外部网络、LVS-DR、转型到DNS-RR IP隧道 考虑可用性 十三、共享文件系统网络共享：利用共享文件系统来实现图片共享、将集群中某台WEB服务器作为文件服务器 NFS：首选方案：基于RPC传输、统计I/O、延迟I/O、 局限性：有一定影响性能 十四、内容分发和同步复制：图片服务器到多台WEB服务器到文件复制 SSH：SCP+SFTP、多级分发 WEBDAV：完全基于HTTP 与restful风格相似 HASH TREE 分发还是同步 反向代理 十五、分布式文件系统文件系统：Hadoop 存储节点和追踪器 MogileFS: 开源的分布式文件系统 十六、数据库扩展复制和分离：主从复制、读写分离、使用数据库反向代理 垂直分区 水平分区：把数据放到不同分区中、分区和分表、分区扩展、分区反向代理、 十七、分布式计算异步计算：分布式消息队列、Gearman、 并行计算：分而治之、MAP/REDUCE（分布式并行计算的开发框架） 十八、性能监控实时监控：Nmon、监控代理、系统监控、服务监控","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"前端月刊【2022-02】","slug":"weeks/2022/2022-02","date":"2022-02-28T01:00:00.000Z","updated":"2022-10-03T02:32:22.651Z","comments":true,"path":"2022/02/28/weeks/2022/2022-02/","link":"","permalink":"http://yoursite.com/2022/02/28/weeks/2022/2022-02/","excerpt":"","text":"前端灰度发布落地方案 前端技术分享：页面性能优化问题复盘","categories":[],"tags":[{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"},{"name":"部署","slug":"部署","permalink":"http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"}]},{"title":"前端月刊【2022-01】","slug":"weeks/2022/2022-01","date":"2022-01-30T01:00:00.000Z","updated":"2022-10-03T02:32:20.154Z","comments":true,"path":"2022/01/30/weeks/2022/2022-01/","link":"","permalink":"http://yoursite.com/2022/01/30/weeks/2022/2022-01/","excerpt":"","text":"60+ 实用 React 工具库，助力你高效开发！ 展望大前端的 2022：VR 大潮来袭，大前端迎来新机遇 解读大前端的 2021 ：究竟“卷”出了什么名堂？ 深度丨一文看懂 Web3.0 的昨天、今天与明天","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"大前端","slug":"大前端","permalink":"http://yoursite.com/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}]},{"title":"前端月刊【2021-12】","slug":"weeks/2021/2021-12","date":"2021-12-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.974Z","comments":true,"path":"2021/12/30/weeks/2021/2021-12/","link":"","permalink":"http://yoursite.com/2021/12/30/weeks/2021/2021-12/","excerpt":"","text":"RUST 程序设计语言book github:https://github.com/KaiserY/trpl-zh-cn 现代 Web 开发困局 现代 Web 开发的现状与未来（JSDC 2019 演讲全文）","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"http://yoursite.com/tags/rust/"},{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"微前端","slug":"微前端","permalink":"http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"Rust程序设计语言 入门总结","slug":"book/2021/Rust程序设计语言","date":"2021-12-10T02:00:00.000Z","updated":"2022-06-05T14:08:41.958Z","comments":true,"path":"2021/12/10/book/2021/Rust程序设计语言/","link":"","permalink":"http://yoursite.com/2021/12/10/book/2021/Rust%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/","excerpt":"","text":"Cargo，内置的依赖管理器和构建工具，它能轻松增加、编译和管理依赖，并使其在 Rust 生态系统中保持一致。 Rustfmt 确保开发者遵循一致的代码风格。 Rust Language Server 为集成开发环境（IDE）提供了强大的代码补全和内联错误信息功能。 编译和运行是彼此独立的步骤$ rustc main.rs Rust 是一种 预编译静态类型（ahead-of-time compiled）语言，这意味着你可以编译程序，并将可执行文件送给其他人，他们甚至不需要安装 Rust 就可以运行。 CargoCargo 是 Rust 的构建系统和包管理器。大多数 Rustacean 们使用 Cargo 来管理他们的 Rust 项目，因为它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。（我们把代码所需要的库叫做 依赖（dependencies））。 12$ cargo new hello_cargo$ cargo build 可以使用 cargo build 或 cargo check 构建项目。 可以使用 cargo run 一步构建并运行项目。 有别于将构建结果放在与源码相同的目录，Cargo 会将其放到 target/debug 目录。","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"rust","slug":"rust","permalink":"http://yoursite.com/tags/rust/"}]},{"title":"前端月刊【2021-11】","slug":"weeks/2021/2021-11","date":"2021-11-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.974Z","comments":true,"path":"2021/11/30/weeks/2021/2021-11/","link":"","permalink":"http://yoursite.com/2021/11/30/weeks/2021/2021-11/","excerpt":"","text":"字节跳动Web Infra发起 Modern.js 开源项目 使用JSDoc提高代码的可读性","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/tags/webgl/"},{"name":"微前端","slug":"微前端","permalink":"http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"前端月刊【2021-10】","slug":"weeks/2021/2021-10","date":"2021-10-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.973Z","comments":true,"path":"2021/10/30/weeks/2021/2021-10/","link":"","permalink":"http://yoursite.com/2021/10/30/weeks/2021/2021-10/","excerpt":"","text":"MySQL 数据表设计规范Nest.js 实践总结","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/tags/webgl/"},{"name":"微前端","slug":"微前端","permalink":"http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"前端月刊【2021-09】","slug":"weeks/2021/2021-09","date":"2021-09-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.973Z","comments":true,"path":"2021/09/30/weeks/2021/2021-09/","link":"","permalink":"http://yoursite.com/2021/09/30/weeks/2021/2021-09/","excerpt":"","text":"WebGL 概念和基础入门 从零到一实现企业级微前端框架","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/tags/webgl/"},{"name":"微前端","slug":"微前端","permalink":"http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"}]},{"title":"前端月刊【2021-08】","slug":"weeks/2021/2021-08","date":"2021-08-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.973Z","comments":true,"path":"2021/08/30/weeks/2021/2021-08/","link":"","permalink":"http://yoursite.com/2021/08/30/weeks/2021/2021-08/","excerpt":"","text":"京喜前端自动化测试之路 38个ES6-ES12的开发技巧 前端领域模型，重构前端研发模式","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"领域模型","slug":"领域模型","permalink":"http://yoursite.com/tags/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/"}]},{"title":"前端核心知识进阶","slug":"book/2021/前端核心知识进阶","date":"2021-08-10T02:00:00.000Z","updated":"2022-06-05T14:08:41.958Z","comments":true,"path":"2021/08/10/book/2021/前端核心知识进阶/","link":"","permalink":"http://yoursite.com/2021/08/10/book/2021/%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E8%BF%9B%E9%98%B6/","excerpt":"","text":"this 在函数体中，非显式或隐式地简单调用函数时，严格模式下，函数类的this被绑定到underfined上。在非严格模式下会绑定到全局对象window/global。 一般使用new构造的函数，构造函数内的this会被指定到新创建的对象上 一般通过apply/call/bind方法显式调用函数时，函数体内this会被绑定到指定参数的对象上 一般通过上下文对象调用函数时，函数体内的this会被绑定到该对象上 在箭头函数中，this的指向是由外层作业域来决定的","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"前端月刊【2021-07】","slug":"weeks/2021/2021-07","date":"2021-07-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.973Z","comments":true,"path":"2021/07/30/weeks/2021/2021-07/","link":"","permalink":"http://yoursite.com/2021/07/30/weeks/2021/2021-07/","excerpt":"","text":"源码浅析-Vue3中的13个全局Api","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"前端月刊【2021-06】","slug":"weeks/2021/2021-06","date":"2021-06-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2021/06/30/weeks/2021/2021-06/","link":"","permalink":"http://yoursite.com/2021/06/30/weeks/2021/2021-06/","excerpt":"","text":"轮子库 2021 年大前端技术趋势解读","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"}]},{"title":"前端月刊【2021-05】","slug":"weeks/2021/2021-05","date":"2021-05-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2021/05/30/weeks/2021/2021-05/","link":"","permalink":"http://yoursite.com/2021/05/30/weeks/2021/2021-05/","excerpt":"","text":"前端开发者应该知道的 Centos/Docker/Nginx/Node/Jenkins 操作 移动端适配","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"部署","slug":"部署","permalink":"http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"}]},{"title":"常用设计模式在前端项目中的应用","slug":"basic/js/设计模式在前端项目中的应用","date":"2021-05-07T01:00:00.000Z","updated":"2022-06-05T14:08:41.950Z","comments":true,"path":"2021/05/07/basic/js/设计模式在前端项目中的应用/","link":"","permalink":"http://yoursite.com/2021/05/07/basic/js/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"","text":"设计模式的种类1、 创建型模式一般用于创建对象。包括：单例模式,工厂方法模式,抽象工厂模式,建造者模式,原型模式。 2、结构型模式重点为“继承”关系，有着一层继承关系，且一般都有“代理”。包括：适配器模式,桥接模式,组合模式,装饰器模式,外观模式,享元模式,代理模式,过滤器模式。 3、行为型模式职责的划分，各自为政，减少外部的干扰。包括：命令模式，解释器模式，迭代器模式，中介者模式，备忘录模式，观察者模式，状态模式，策略模式，模板方法模式，访问者模式，责任链模式。 前端常用的计模式应用实例1、单例模式单例模式又称为单体模式，保证一个类只有一个实例，并提供一个访问它的全局访问点。一个极有可能重复出现的“实例”, 如果重复创建，将会产生性能消耗。如果借助第一次的实例，后续只是对该实例的重复使用，这样就达到了我们节省性能的目的。全局弹窗是前端开发中一个比较常规的需求，一般情况下，同一时间只会存在一个全局弹窗，我们可以实现单例模式，保证每次实例化时返回的实际上是同一个方法。 123456789101112131415161718class MessageBox &#123; show() &#123; console.log(\"show\"); &#125; hide() &#123;&#125; static getInstance() &#123; if (!MessageBox.instance) &#123; MessageBox.instance = new MessageBox(); &#125; return MessageBox.instance; &#125;&#125;let box3 = MessageBox.getInstance();let box4 = MessageBox.getInstance();console.log(box3 === box4); // true 上面这种是比较常见的单例模式实现，但是这种方式存在一些弊端。因为它需要让调用方了解到通过Message.getInstance来获取单例。 又或者假设需求变更，可以通过存在二次弹窗，则需要改动不少地方，因为MessageBox除了实现常规的弹窗逻辑之外，还需要负责维护单例的逻辑。 因此，可以将初始化单例的逻辑单独维护，实现一个通用的、返回某个类对应单例的方法。 1234567891011121314function getSingleton(ClassName) &#123; let instance; return () =&gt; &#123; if (!instance) &#123; instance = new ClassName(); &#125; return instance; &#125;;&#125;const createMessageBox = getSingleton(MessageBox);let box5 = createMessageBox();let box6 = createMessageBox();console.log(box5 === box6); 这样，通过createMessageBox返回的始终是同一个实例。如果在某些场景下需要生成另外的实例，则可以重新生成一个createMessageBox方法，或者直接调用new MessageBox()，这样就对之前的逻辑不会有任何影响。 2、工厂模式工厂模式提供了一种创建对象的方法，对使用方隐藏了对象的具体实现细节，并使用一个公共的接口来创建对象。 前端本地存储目前最常见的方案就是使用localStorage，为了避免在业务代码中各种getItem和setItem，我们可以做一下最简单的封装。 123456789101112131415let themeModel = &#123; name: \"local_theme\", get() &#123; let val = localStorage.getItem(this.name); return val &amp;&amp; jsON.parse(val); &#125;, set(val) &#123; localStorage.setItem(this.name, jsON.stringify(val)); &#125;, remove() &#123; localStorage.removeItem(this.name); &#125;,&#125;;themeModel.get();themeModel.set(&#123; darkMode: true &#125;); 这样，通过themeModel暴露的get、set接口，我们无需再维护local_theme。但上面的封装也存在一些可见的问题，如果需要新增多个 name，那么上面的模板代码需要重新写多遍吗？为了解决这个问题，我们可以创建Model对象的逻辑进行封装。 1234567891011121314151617181920212223242526const storageMap = new Map()function createStorageModel(key, storage = localStorage) &#123; // 相同key返回单例 if (storageMap.has(key)) &#123; return storageMap.get(key); &#125; const model = &#123; key, set(val) &#123; storage.setItem(this.key, JSON.stringify(val);); &#125;, get() &#123; let val = storage.getItem(this.key); return val &amp;&amp; JSON.parse(val); &#125;, remove() &#123; storage.removeItem(this.key); &#125;, &#125;; storageMap.set(key, model); return model;&#125;const themeModel = createStorageModel('local_theme', localStorage)const utmSourceModel = createStorageModel('utm_source', sessionStorage) 这样，我们就可以通过createStorageModel这个公共的接口来创建各种不同本地存储的对象，而无需关注创建对象的具体细节。 3、策略模式策略模式，可以针对不同的状态，给出不同的算法或者结果。将层级相同的逻辑封装成可以组合和替换的策略方法，减少if…else代码，方便扩展后续功能。 表单校验是我们最常见的场景了，我们一般都会想到用if…else来判断。 12345678910111213function onFormSubmit(params) &#123; if (!params.name) &#123; return showError(\"请填写昵称\"); &#125; if (params.name.length &gt; 6) &#123; return showError(\"昵称最多6位字符\"); &#125; if (!/^1\\d&#123;10&#125;$/.test(params.phone)) return showError(\"请填写正确的手机号\"); &#125; // ... sendSubmit(params)&#125; 将所有字段的校验规则都堆叠在一起，代码量大，排查问题也是一个大麻烦。在遇见错误时，直接通过 return 跳过了后面的判断；如果我们希望直接展示每个字段的错误呢，那么改动的工作量又不少。 不过，在antd、ELementUI等框架盛行的年代，我们已经不再需要写这些复杂的表单校验，但是对于他们的实现原理，我们可以简单模拟一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 定义一个校验的类，主要暴露了构造参数和validate两个接口class Schema &#123; constructor(descriptor) &#123; this.descriptor = descriptor; // 传入定义的校验规则 &#125; // 拆分出一些更通用的规则，比如required(必填)、len(长度)、min/max(最值)等，可以尽可能地复用 handleRule(val, rule) &#123; const &#123; key, params, message &#125; = rule; let ruleMap = &#123; required() &#123; return !val; &#125;, max() &#123; return val &gt; params; &#125;, validator() &#123; return params(val); &#125;, &#125;; let handler = ruleMap[key]; if (handler &amp;&amp; handler()) &#123; throw message; &#125; &#125; validate(data) &#123; return new Promise((resolve, reject) =&gt; &#123; let keys = Object.keys(data); let errors = []; for (let key of keys) &#123; const ruleList = this.descriptor[key]; if (!Array.isArray(ruleList) || !ruleList.length) continue; const val = data[key]; for (let rule of ruleList) &#123; try &#123; this.handleRule(val, rule); &#125; catch (e) &#123; errors.push(e.toString()); &#125; &#125; &#125; if (errors.length) &#123; reject(errors); &#125; else &#123; resolve(); &#125; &#125;); &#125;&#125;// 声明每个字段的校验逻辑const descriptor = &#123; nickname: [ &#123; key: \"required\", message: \"请填写昵称\" &#125;, &#123; key: \"max\", params: 6, message: \"昵称最多6位字符\" &#125;, ], phone: [ &#123; key: \"required\", message: \"请填写电话号码\" &#125;, &#123; key: \"validator\", params(val) &#123; return !/^1\\d&#123;10&#125;$/.test(val); &#125;, message: \"请填写正确的电话号码\", &#125;, ],&#125;;// 开始对数据进行校验const validator = new Schema(descriptor);const params = &#123; nickname: \"\", phone: \"123000\" &#125;;validator.validate(params).then(() =&gt; &#123; console.log(\"success\");&#125;).catch((e) =&gt; &#123; console.log(e);&#125;); Schema主要暴露了构造参数和validate两个接口，是一个通用的工具类，而params是表单提交的数据源，因此主要的校验逻辑实际上是在descriptor中声明的。将常见的校验规则都放在ruleMap中，比之前各种不可复用的if..else判断更容易维护和迭代。 4、状态模式状态模式允许一个对象在其内部状态改变的时候改变它的行为。状态模式的思路是：首先创建一个状态对象保存状态变量，然后封装好每种动作对应的状态，然后状态对象返回一个接口对象，它可以对内部的状态修改或者调用。 常见的使用场景，比如滚动加载，包含了初始化加载、加载成功、加载失败、滚动加载等状态，任意时间它只会处于一种状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 定义一个状态机class rollingLoad &#123; constructor() &#123; this._currentState = 'init' this.states = &#123; init: &#123; failed: 'error' &#125;, init: &#123; complete: 'normal' &#125;, normal: &#123; rolling: 'loading' &#125;, loading: &#123; complete: 'normal' &#125;, loading: &#123; failed: 'error' &#125;, &#125; this.actions = &#123; init() &#123; console.log('初始化加载，大loading') &#125;, normal() &#123; console.log('加载成功，正常展示') &#125;, error() &#123; console.log('加载失败') &#125;, loading() &#123; console.log('滚动加载') &#125; // ..... &#125; &#125; change(state) &#123; // 更改当前状态 let to = this.states[this._currentState][state] if(to)&#123; this._currentState = to this.go() return true &#125; return false &#125; go() &#123; this.actions[this._currentState]() return this &#125;&#125;// 状态更改的操作const rollingLoad = new rollingLoad()rollingLoad.go()rollingLoad.change('complete')rollingLoad.change('loading') 这样，我们就可以通过状态变更，运行相应的函数，且状态之间存在联系。那么，看起来是不是和策略模式很像呢？其实不然，策略类的各个属性之间是平等平行的，它们之间没有任何联系。而状态机中的各个状态之间存在相互切换，且是被规定好了的。 5、发布-订阅模式发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。 发布订阅模式大概是前端同学最熟悉的设计模式之一了，常见的事件监听addEventListener，各种属性方法onload、onchange，vue响应式数据，组件通信redux、eventBus等。 常见的获取登录信息，假设我们开发一个商城网站，网站里有 header 头部、nav 导航、消息列表、购物车等模块。 这几个模块的渲染有一个共同的前提条件，就是必须先用 ajax 异步请求获取用户的登录信息。 比如用户的名字和头像要显示在 header 模块里，而这两个字段都来自用户登录后返回的信息。异步的问题通常也可以用回调函数来解决： 123456login.succ(function(data)&#123; header.setAvatar( data.avatar); // 设置 header 模块的头像 nav.setAvatar( data.avatar ); // 设置导航模块的头像 message.refresh(); // 刷新消息列表 cart.refresh(); // 刷新购物车列表&#125;); 我们还必须了解 header 模块里设置头像的方法叫setAvatar、购物车模块里刷新的方法叫refresh，这种强耦合性会使程序变得不易拓展。 那么回头看看我们的发布—订阅模式，这种模式下，对用户信息感兴趣的业务模块可以自行订阅登录成功的消息事件。 当登录成功时，登录模块只需要发布登录成功的消息，而业务方接受到消息之后，就会开始进行各自的业务处理，登录模块并不关心业务方究竟要做什么。 1234567891011121314151617181920212223242526// 发布登录成功的消息$.ajax( 'http://xxx.com?login', function(data)&#123; // 登录成功 login.trigger( 'loginSucc', data); // 发布登录成功的消息&#125;);// 各模块监听登录成功的消息var header = (function()&#123; // header 模块 login.listen( 'loginSucc', function(data)&#123; header.setAvatar( data.avatar ); &#125;); return &#123; setAvatar: function( data )&#123; console.log( '设置 header 模块的头像' ); &#125; &#125;&#125;)();var nav = (function()&#123; // nav 模块 login.listen( 'loginSucc', function( data )&#123; nav.setAvatar( data.avatar ); &#125;); return &#123; setAvatar: function( avatar )&#123; console.log( '设置 nav 模块的头像' ); &#125; &#125;&#125;)(); 发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅ajax请求的error、succ等事件。 或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。 在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 6、迭代器模式迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 JS 也内置了多种遍历数组的方法如forEach、reduce等。对于数组的循环大家都轻车熟路了，在实际开发中，也可以通过循环来优化代码。 一个常见的开发场景是：通过 ua 判断当前页面的运行平台，方便执行不同的业务逻辑，最基本的写法当然是if…else。 1234567891011121314151617181920212223242526const PAGE_TYPE = &#123; app: \"app\", // app wx: \"wx\", // 微信 tiktok: \"tiktok\", // 抖音 bili: \"bili\", // B站 kwai: \"kwai\", // 快手&#125;;function getPageType() &#123; const ua = navigator.userAgent; let pageType; // 移动端、桌面端微信浏览器 if (/xxx_app/i.test(ua)) &#123; pageType = app; &#125; else if (/MicroMessenger/i.test(ua)) &#123; pageType = wx; &#125; else if (/aweme/i.test(ua)) &#123; pageType = tiktok; &#125; else if (/BiliApp/i.test(ua)) &#123; pageType = bili; &#125; else if (/Kwai/i.test(ua)) &#123; pageType = kwai; &#125; else &#123; // ... &#125; return pageType;&#125; 参考策略模式的思路，我们可以减少分支判断的出现，将每个平台的判断拆分成单独的策略: 12345678910111213141516171819202122232425262728293031323334353637function isApp(ua) &#123; return /xxx_app/i.test(ua);&#125;function isWx(ua) &#123; return /MicroMessenger/i.test(ua);&#125;function isTiktok(ua) &#123; return /aweme/i.test(ua);&#125;function isBili(ua) &#123; return /BiliApp/i.test(ua);&#125;function isKwai(ua) &#123; return /Kwai/i.test(ua);&#125;let platformList = [ &#123; name: \"app\", validator: isApp &#125;, &#123; name: \"wx\", validator: isWx &#125;, &#123; name: \"tiktok\", validator: isTiktok &#125;, &#123; name: \"bili\", validator: isBili &#125;, &#123; name: \"kwai\", validator: isKwai &#125;,];function getPageType() &#123; // 每个平台的名称与检测方法 const ua = navigator.userAgent; // 遍历 for (let &#123; name, validator &#125; in platformList) &#123; if (validator(ua)) &#123; return name; &#125; &#125;&#125;","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"前端月刊【2021-04】","slug":"weeks/2021/2021-04","date":"2021-04-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2021/04/30/weeks/2021/2021-04/","link":"","permalink":"http://yoursite.com/2021/04/30/weeks/2021/2021-04/","excerpt":"","text":"CSS 实现优惠券的技巧 前端布局神器display:flex React 开发必须知道的 34 个技巧 「react进阶」一文吃透react-hooks原理 前端优秀实践不完全指南","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"react-hooks","slug":"react-hooks","permalink":"http://yoursite.com/tags/react-hooks/"}]},{"title":"前端月刊【2021-03】","slug":"weeks/2021/2021-03","date":"2021-03-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2021/03/30/weeks/2021/2021-03/","link":"","permalink":"http://yoursite.com/2021/03/30/weeks/2021/2021-03/","excerpt":"","text":"快速使用Vue3最新的15个常用API 15道ES6 Promise实战练习题，助你快速理解Promise 1.5 万字 CSS 基础拾遗（核心知识、常见需求）","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"}]},{"title":"React全家桶核心知识点(四) - 扩展","slug":"frame/react/React全家桶核心知识点4","date":"2021-03-12T01:00:00.000Z","updated":"2022-06-05T14:08:41.964Z","comments":true,"path":"2021/03/12/frame/react/React全家桶核心知识点4/","link":"","permalink":"http://yoursite.com/2021/03/12/frame/react/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B94/","excerpt":"","text":"一. setStatesetState更新状态的2种写法1234567891011121314 (1). setState(stateChange, [callback])------对象式的setState 1.stateChange为状态改变对象(该对象可以体现出状态的更改) 2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 (2). setState(updater, [callback])------函数式的setState 1.updater为返回stateChange对象的函数。 2.updater可以接收到state和props。 4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。总结: 1.对象式的setState是函数式的setState的简写方式(语法糖) 2.使用原则： (1).如果新状态不依赖于原状态 &#x3D;&#x3D;&#x3D;&gt; 使用对象方式 (2).如果新状态依赖于原状态 &#x3D;&#x3D;&#x3D;&gt; 使用函数方式 (3).如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取 二. lazyLoad路由组件的lazyLoad12345678910//1.通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包const Login = lazy(()=&gt;import('@/pages/Login'))//2.通过&lt;Suspense&gt;指定在加载得到路由打包文件前显示一个自定义loading界面&lt;Suspense fallback=&#123;&lt;h1&gt;loading.....&lt;/h1&gt;&#125;&gt; &lt;Switch&gt; &lt;Route path=\"/xxx\" component=&#123;Xxxx&#125;/&gt; &lt;Redirect to=\"/login\"/&gt; &lt;/Switch&gt; &lt;/Suspense&gt; 三. Hooks1. React Hook/Hooks是什么?12(1). Hook是React 16.8.0版本增加的新特性&#x2F;新语法(2). 可以让你在函数组件中使用 state 以及其他的 React 特性 2. 三个常用的Hook123(1). State Hook: React.useState()(2). Effect Hook: React.useEffect()(3). Ref Hook: React.useRef() 3. State Hook12345678(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作(2). 语法: const [xxx, setXxx] &#x3D; React.useState(initValue) (3). useState()说明: 参数: 第一次初始化指定的值在内部作缓存 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数(4). setXxx()2种写法: setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值 setXxx(value &#x3D;&gt; newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值 4. Effect Hook1234567891011121314151617(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)(2). React中的副作用操作: 发ajax请求数据获取 设置订阅 &#x2F; 启动定时器 手动更改真实DOM(3). 语法和说明: useEffect(() &#x3D;&gt; &#123; &#x2F;&#x2F; 在此可以执行任何带副作用操作 return () &#x3D;&gt; &#123; &#x2F;&#x2F; 在组件卸载前执行 &#x2F;&#x2F; 在此做一些收尾工作, 比如清除定时器&#x2F;取消订阅等 &#125; &#125;, [stateValue]) &#x2F;&#x2F; 如果指定的是[], 回调函数只会在第一次render()后执行 (4). 可以把 useEffect Hook 看做如下三个函数的组合 componentDidMount() componentDidUpdate() componentWillUnmount() 5. Ref Hook123(1). Ref Hook可以在函数组件中存储&#x2F;查找组件内的标签或任意其它数据(2). 语法: const refContainer &#x3D; useRef()(3). 作用:保存标签对象,功能与React.createRef()一样 四. Fragment使用&lt;Fragment&gt;&lt;Fragment&gt; &lt;&gt;&lt;/&gt;作用 可以不用必须有一个真实的DOM根标签了 五. Context理解 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信 使用123456789101112131415161718192021221) 创建Context容器对象： const XxxContext = React.createContext() 2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据： &lt;xxxContext.Provider value=&#123;数据&#125;&gt; 子组件 &lt;/xxxContext.Provider&gt; 3) 后代组件读取数据： //第一种方式:仅适用于类组件 static contextType = xxxContext // 声明接收context this.context // 读取context中的value数据 //第二种方式: 函数组件与类组件都可以 &lt;xxxContext.Consumer&gt; &#123; value =&gt; ( // value就是context中的value数据 要显示的内容 ) &#125; &lt;/xxxContext.Consumer&gt; 注意在应用开发中一般不用context, 一般都它的封装react插件 六. 组件优化Component的2个问题 只要执行setState(),即使不改变状态数据, 组件也会重新render() 只当前组件重新render(), 就会自动重新render子组件 ==&gt; 效率低 效率高的做法 只有当组件的state或props数据发生改变时才重新render() 原因 Component中的shouldComponentUpdate()总是返回true 解决办法1: 重写shouldComponentUpdate()方法 比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false 办法2: 使用PureComponent PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true 注意: 只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false 不要直接修改state数据, 而是要产生新数据项目中一般使用PureComponent来优化 七. render props如何向组件内部动态传入带内容的结构(标签)?Vue中: 使用slot技术, 也就是通过组件标签体传入结构 &lt;AA&gt;&lt;BB/&gt;&lt;/AA&gt; React中: 使用children props: 通过组件标签体传入结构 使用render props: 通过组件标签属性传入结构, 一般用render函数属性children props&lt;A&gt; &lt;B&gt;xxxx&lt;/B&gt; &lt;/A&gt; {this.props.children} 问题: 如果B组件需要A组件内的数据, ==&gt; 做不到 render props&lt;A render={(data) =&gt; &lt;C data={data}&gt;&lt;/C&gt;}&gt;&lt;/A&gt; A组件: {this.props.render(内部state数据)} C组件: 读取A组件传入的数据显示 {this.props.data} 八. 错误边界理解：错误边界：用来捕获后代组件错误，渲染出备用页面 特点：只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误 使用方式：getDerivedStateFromError配合componentDidCatch 1234567891011121314// 生命周期函数，一旦后台组件报错，就会触发static getDerivedStateFromError(error) &#123; console.log(error); // 在render之前触发 // 返回新的state return &#123; hasError: true, &#125;;&#125;componentDidCatch(error, info) &#123; // 统计页面的错误。发送请求发送到后台去 console.log(error, info);&#125; 九. 组件通信方式总结方式：props： (1).children props (2).render props 消息订阅-发布： pubs-sub、event等等 集中式管理： redux、dva等等 conText: 生产者-消费者模式组件间的关系父子组件：props 兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理 祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"React全家桶核心知识点(三) - redux","slug":"frame/react/React全家桶核心知识点3","date":"2021-03-10T01:00:00.000Z","updated":"2022-06-05T14:08:41.964Z","comments":true,"path":"2021/03/10/frame/react/React全家桶核心知识点3/","link":"","permalink":"http://yoursite.com/2021/03/10/frame/react/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B93/","excerpt":"","text":"一、redux是什么学习文档 英文文档: https://redux.js.org/ 中文文档: http://www.redux.org.cn/ Github: https://github.com/reactjs/redux redux是什么 redux是一个专门用于做状态管理的JS库(不是react插件库)。 它可以用在react, angular, vue等项目中, 但基本与react配合使用。 作用: 集中式管理react应用中多个组件共享的状态。 什么情况下需要使用redux 某个组件的状态，需要让其他组件可以随时拿到（共享）。 一个组件需要改变另一个组件的状态（通信）。 总体原则：能不用就不用, 如果不用比较吃力才考虑使用。 redux工作流程 二、redux的三个核心概念action 动作的对象 包含2个属性 type：标识属性, 值为字符串, 唯一, 必要属性 data：数据属性, 值类型任意, 可选属性 例子：{ type: ‘ADD_STUDENT’,data:{name: ‘tom’,age:18} } reducer 用于初始化状态、加工状态。 加工时，根据旧的state和action， 产生新的state的纯函数。 store 将state、action、reducer联系在一起的对象 如何得到此对象? 1) import {createStore} from ‘redux’ 2) import reducer from ‘./reducers’ 3) const store = createStore(reducer) 此对象的功能? 1) getState(): 得到state 2) dispatch(action): 分发action, 触发reducer调用, 产生新的state 3) subscribe(listener): 注册监听, 当产生了新的state时, 自动调用 三、redux的核心APIcreatestore()作用：创建包含指定reducer的store对象 store对象 作用: redux库最核心的管理对象 它内部维护着: 1) state 2) reducer 核心方法:1) getState()2) dispatch(action)3) subscribe(listener) 具体编码:1) store.getState()2) store.dispatch({type:’INCREMENT’, number})3) store.subscribe(render) applyMiddleware()作用：应用上基于redux的中间件(插件库) combineReducers()作用：合并多个reducer函数 四、react-reudx理解 一个react插件库 专门用来简化react应用中使用redux react-Redux将所有组件分成两大类 UI组件 1)只负责 UI 的呈现，不带有任何业务逻辑 2)通过props接收数据(一般数据和函数) 3)不使用任何 Redux 的 API 4)一般保存在components文件夹下 容器组件 1)负责管理数据和业务逻辑，不负责UI的呈现 2)使用 Redux 的 API 3)一般保存在containers文件夹下 API1、Provider：让所有组件都可以得到state数据 123&lt;Provider store&#x3D;&#123;store&#125;&gt; &lt;App &#x2F;&gt;&lt;&#x2F;Provider&gt; 2、connect：用于包装 UI 组件生成容器组件 12345import &#123; connect &#125; from &#39;react-redux&#39; connect( mapStateToprops, mapDispatchToProps )(Counter) 3、mapStateToprops：将外部的数据（即state对象）转换为UI组件的标签属性 12345const mapStateToprops &#x3D; function (state) &#123; return &#123; value: state &#125;&#125; 4、mapDispatchToProps：将分发action的函数转换为UI组件的标签属性 五、纯函数和高阶函数纯函数 一类特别的函数: 只要是同样的输入(实参)，必定得到同样的输出(返回) 必须遵守以下一些约束 1)不得改写参数数据 2)不会产生任何副作用，例如网络请求，输入和输出设备 3)不能调用Date.now()或者Math.random()等不纯的方法 redux的reducer函数必须是一个纯函数 高阶函数 理解: 一类特别的函数 1)情况1: 参数是函数 2)情况2: 返回是函数 常见的高阶函数: 1)定时器设置函数 2)数组的forEach()/map()/filter()/reduce()/find()/bind() 3)promise 4)react-redux中的connect函数 作用: 能实现更加动态, 更加可扩展的功能 六、案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781.redux精简版 (1).去除Count组件自身的状态 (2).src下建立: -redux -store.js -count_reducer.js (3).store.js： 1).引入redux中的createStore函数，创建一个store 2).createStore调用时要传入一个为其服务的reducer 3).记得暴露store对象 (4).count_reducer.js： 1).reducer的本质是一个函数，接收：preState,action，返回加工后的状态 2).reducer有两个作用：初始化状态，加工状态 3).reducer被第一次调用时，是store自动触发的， 传递的preState是undefined, 传递的action是:&#123;type:&#39;@@REDUX&#x2F;INIT_a.2.b.4&#125; (5).在index.js中监测store中状态的改变，一旦发生改变重新渲染&lt;App&#x2F;&gt; 备注：redux只负责管理状态，至于状态的改变驱动着页面的展示，要靠我们自己写。2.redux完整版 新增文件： 1.count_action.js 专门用于创建action对象 2.constant.js 放置容易写错的type值3.redux异步action版 (1).明确：延迟的动作不想交给组件自身，想交给action (2).何时需要异步action：想要对状态进行操作，但是具体的数据靠异步任务返回。 (3).具体编码： 1).yarn add redux-thunk，并配置在store中 2).创建action的函数不再返回一般对象，而是一个函数，该函数中写异步任务。 3).异步任务有结果后，分发一个同步的action去真正操作数据。 (4).备注：异步action不是必须要写的，完全可以自己等待异步任务的结果了再去分发同步action。4.react-redux基本使用 (1).明确两个概念： 1).UI组件:不能使用任何redux的api，只负责页面的呈现、交互等。 2).容器组件：负责和redux通信，将结果交给UI组件。 (2).如何创建一个容器组件————靠react-redux 的 connect函数 connect(mapStateToProps,mapDispatchToProps)(UI组件) -mapStateToProps:映射状态，返回值是一个对象 -mapDispatchToProps:映射操作状态的方法，返回值是一个对象 (3).备注1：容器组件中的store是靠props传进去的，而不是在容器组件中直接引入 (4).备注2：mapDispatchToProps，也可以是一个对象5.react-redux优化 (1).容器组件和UI组件整合一个文件 (2).无需自己给容器组件传递store，给&lt;App&#x2F;&gt;包裹一个&lt;Provider store&#x3D;&#123;store&#125;&gt;即可。 (3).使用了react-redux后也不用再自己检测redux中状态的改变了，容器组件可以自动完成这个工作。 (4).mapDispatchToProps也可以简单的写成一个对象 (5).一个组件要和redux“打交道”要经过哪几步？ (1).定义好UI组件---不暴露 (2).引入connect生成一个容器组件，并暴露，写法如下： connect( state &#x3D;&gt; (&#123;key:value&#125;), &#x2F;&#x2F;映射状态 &#123;key:xxxxxAction&#125; &#x2F;&#x2F;映射操作状态的方法 )(UI组件) (4).在UI组件中通过this.props.xxxxxxx读取和操作状态6.react-redux数据共享版 (1).定义一个Pserson组件，和Count组件通过redux共享数据。 (2).为Person组件编写：reducer、action，配置constant常量。 (3).重点：Person的reducer和Count的Reducer要使用combineReducers进行合并， 合并后的总状态是一个对象！！！ (4).交给store的是总reducer，最后注意在组件中取出状态的时候，记得“取到位”。7.react-redux开发者工具的使用 (1).yarn add redux-devtools-extension (2).store中进行配置 import &#123;composeWithDevTools&#125; from &#39;redux-devtools-extension&#39; const store &#x3D; createStore(allReducer,composeWithDevTools(applyMiddleware(thunk)))8.react-redux最终版 (1).所有变量名字要规范，尽量触发对象的简写形式。 (2).reducers文件夹中，编写index.js专门用于汇总并暴露所有的reducer","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"http://yoursite.com/tags/react-redux/"}]},{"title":"React全家桶核心知识点(二) - 框架开发技巧","slug":"frame/react/React全家桶核心知识点2","date":"2021-03-06T01:00:00.000Z","updated":"2022-06-05T14:08:41.964Z","comments":true,"path":"2021/03/06/frame/react/React全家桶核心知识点2/","link":"","permalink":"http://yoursite.com/2021/03/06/frame/react/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B92/","excerpt":"","text":"一、组件相关知识点 拆分组件、实现静态组件，注意：className、style的写法 动态初始化列表，如何确定将数据放在哪个组件的state中？ ——某个组件使用：放在其自身的state中 ——某些组件使用：放在他们共同的父组件state中（官方称此操作为：状态提升） 关于父子之间通信： 【父组件】给【子组件】传递数据：通过props传递 【子组件】给【父组件】传递数据：通过props传递，要求父提前给子传递一个函数 注意defaultChecked 和 checked的区别，类似的还有：defaultValue 和 value 状态在哪里，操作状态的方法就在哪里 设计状态时要考虑全面，例如带有网络请求的组件，要考虑请求失败怎么办。 ES6小知识点：解构赋值+重命名1234let obj = &#123;a:&#123;b:1&#125;&#125;const &#123;a&#125; = obj; //传统解构赋值const &#123;a:&#123;b&#125;&#125; = obj; //连续解构赋值const &#123;a:&#123;b:value&#125;&#125; = obj; //连续解构赋值+重命名 消息订阅与发布机制 先订阅，再发布（理解：有一种隔空对话的感觉） 适用于任意组件间通信 要在组件的componentWillUnmount中取消订阅 fetch发送请求（关注分离的设计思想）1234567try &#123; const response= await fetch(`/api1/search/users2?q=$&#123;keyWord&#125;`) const data = await response.json() console.log(data);&#125; catch (error) &#123; console.log('请求出错',error);&#125; 二、路由的基本使用 明确好界面中的导航区、展示区 导航区的a标签改为Link标签Demo 展示区写Route标签进行路径的匹配 的最外侧包裹了一个或 三、路由组件与一般组件 写法不同：一般组件：路由组件： 存放位置不同：一般组件：components路由组件：pages 接收到的props不同：一般组件：写组件标签时传递了什么，就能收到什么路由组件：接收到三个固定的属性1234567891011121314history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(path, state)location: pathname: &quot;&#x2F;about&quot; search: &quot;&quot; state: undefinedmatch: params: &#123;&#125; path: &quot;&#x2F;about&quot; url: &quot;&#x2F;about&quot; 四、NavLink与封装NavLinkNavLink可以实现路由链接的高亮，通过activeClassName指定样式名 五、Switch的使用 通常情况下，path和component是一一对应的关系。 Switch可以提高路由匹配效率(单一匹配)。 六、解决多级路径刷新页面样式丢失的问题 public/index.html 中 引入样式时不写 ./ 写 / （常用） public/index.html 中 引入样式时不写 ./ 写 1%PUBLIC_URL%（常用） 使用HashRouter 七、路由的严格匹配与模糊匹配1 .默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致）2. 开启严格匹配：3. 严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由 八、Redirect的使用 一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由 具体编码：12345&lt;Switch&gt; &lt;Route path=\"/about\" component=&#123;About&#125;/&gt; &lt;Route path=\"/home\" component=&#123;Home&#125;/&gt; &lt;Redirect to=\"/about\"/&gt;&lt;/Switch&gt; 九、嵌套路由 注册子路由时要写上父路由的path值 路由的匹配是按照注册路由的顺序进行的 十、向路由组件传递参数 params参数 123路由链接(携带参数)：&lt;Link to&#x3D;&#39;&#x2F;demo&#x2F;test&#x2F;tom&#x2F;18&#39;&#125;&gt;详情&lt;&#x2F;Link&gt;注册路由(声明接收)：&lt;Route path&#x3D;&quot;&#x2F;demo&#x2F;test&#x2F;:name&#x2F;:age&quot; component&#x3D;&#123;Test&#125;&#x2F;&gt;接收参数：this.props.match.params search参数 1234路由链接(携带参数)：&lt;Link to&#x3D;&#39;&#x2F;demo&#x2F;test?name&#x3D;tom&amp;age&#x3D;18&#39;&#125;&gt;详情&lt;&#x2F;Link&gt;注册路由(无需声明，正常注册即可)：&lt;Route path&#x3D;&quot;&#x2F;demo&#x2F;test&quot; component&#x3D;&#123;Test&#125;&#x2F;&gt;接收参数：this.props.location.search备注：获取到的search是urlencoded编码字符串，需要借助querystring解析 state参数 1234路由链接(携带参数)：&lt;Link to&#x3D;&#123;&#123;pathname:&#39;&#x2F;demo&#x2F;test&#39;,state:&#123;name:&#39;tom&#39;,age:18&#125;&#125;&#125;&gt;详情&lt;&#x2F;Link&gt;注册路由(无需声明，正常注册即可)：&lt;Route path&#x3D;&quot;&#x2F;demo&#x2F;test&quot; component&#x3D;&#123;Test&#125;&#x2F;&gt;接收参数：this.props.location.state备注：刷新也可以保留住参数 十一、编程式路由导航借助this.prosp.history对象上的API对操作路由跳转、前进、后退 -this.prosp.history.push() -this.prosp.history.replace() -this.prosp.history.goBack() -this.prosp.history.goForward() -this.prosp.history.go() 十二、BrowserRouter与HashRouter的区别 底层原理不一样： BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。 HashRouter使用的是URL的哈希值。 path表现形式不一样 BrowserRouter的路径中没有#,例如： 1localhost:3000&#x2F;demo&#x2F;test HashRouter的路径包含#,例如： 1localhost:3000&#x2F;#&#x2F;demo&#x2F;test 刷新后对路由state参数的影响 (1).BrowserRouter没有任何影响，因为state保存在history对象中。 (2).HashRouter刷新后会导致路由state参数的丢失！！！ 备注：HashRouter可以用于解决一些路径错误相关的问题。 十三、antd的按需引入+自定主题 安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader 修改package.json 123456\"scripts\": &#123; \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\"&#125; 根目录下创建config-overrides.js 123456789101112131415//配置具体的修改规则const &#123; override, fixBabelImports,addLessLoader&#125; = require('customize-cra');module.exports = override( fixBabelImports('import', &#123; libraryName: 'antd', libraryDirectory: 'es', style: true,&#125;),addLessLoader(&#123; lessOptions:&#123; javascriptEnabled: true, modifyVars: &#123; '@primary-color': 'green' &#125;, &#125;&#125;),); 备注：不用在组件里亲自引入样式了，即：import ‘antd/dist/antd.css’应该删掉","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"前端月刊【2021-02】","slug":"weeks/2021/2021-02","date":"2021-02-27T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2021/02/27/weeks/2021/2021-02/","link":"","permalink":"http://yoursite.com/2021/02/27/weeks/2021/2021-02/","excerpt":"","text":"技术架构涵盖内容和演变过程总结 15道ES6 Promise实战练习题，助你快速理解Promise 快速使用Vue3最新的15个常用API","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"}]},{"title":"React全家桶核心知识点(一) - 基础原理","slug":"frame/react/React全家桶核心知识点1","date":"2021-02-24T01:00:00.000Z","updated":"2022-06-05T14:08:41.964Z","comments":true,"path":"2021/02/24/frame/react/React全家桶核心知识点1/","link":"","permalink":"http://yoursite.com/2021/02/24/frame/react/React%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B91/","excerpt":"","text":"一、虚拟DOM的两种创建方式 使用JSX创建虚拟DOM 12345678&#x2F;&#x2F;1.创建虚拟DOMconst VDOM &#x3D; ( &#x2F;* 此处一定不要写引号，因为不是字符串 *&#x2F; &lt;h1 id&#x3D;&quot;title&quot;&gt; &lt;span&gt;Hello,React&lt;&#x2F;span&gt; &lt;&#x2F;h1&gt; )&#x2F;&#x2F;2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;)) 使用JS创建虚拟DOM 1234&#x2F;&#x2F;1.创建虚拟DOMconst VDOM &#x3D; React.createElement(&#39;h1&#39;,&#123;id:&#39;title&#39;&#125;,React.createElement(&#39;span&#39;,&#123;&#125;,&#39;Hello,React&#39;))&#x2F;&#x2F;2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;)) 关于虚拟DOM： 1.本质是Object类型的对象（一般对象） 2.虚拟DOM比较“轻”，真实DOM比较“重”，因为虚拟DOM是React内部在用，无需真实DOM上那么多的属性。 3.虚拟DOM最终会被React转化为真实DOM，呈现在页面上。 二、jsx语法规则 定义虚拟DOM时，不要写引号。 标签中混入JS表达式时要用{}。 样式的类名指定不要用class，要用className。 内联样式，要用的形式去写。1style=&#123;&#123;key:value&#125;&#125; 只有一个根标签 标签必须闭合 标签首字母(1) 若小写字母开头，则将该标签转为html中同名元素，若html中无该标签对应的同名元素，则报错。(2) 若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。 三、js语句(代码)与js表达式 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方(1). a(2). a+b(3). demo(1)(4). arr.map()(5). function test () {} 语句(代码)：(1).if(){}(2).for(){}(3).switch(){case:xxxx} 1234567891011121314151617&#x2F;&#x2F;模拟一些数据const data &#x3D; [&#39;Angular&#39;,&#39;React&#39;,&#39;Vue&#39;]&#x2F;&#x2F;1.创建虚拟DOMconst VDOM &#x3D; ( &lt;div&gt; &lt;h1&gt;前端js框架列表&lt;&#x2F;h1&gt; &lt;ul&gt; &#123; data.map((item,index)&#x3D;&gt;&#123; return &lt;li key&#x3D;&#123;index&#125;&gt;&#123;item&#125;&lt;&#x2F;li&gt; &#125;) &#125; &lt;&#x2F;ul&gt; &lt;&#x2F;div&gt;)&#x2F;&#x2F;2.渲染虚拟DOM到页面ReactDOM.render(VDOM,document.getElementById(&#39;test&#39;)) 四、函数式组件 &amp;&amp; 类式组件4.1 函数式组件执行了ReactDOM.render(…….之后，发生了什么？ React解析组件标签，找到了MyComponent组件。 发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转为真实DOM，随后呈现在页面中。 1234567&#x2F;&#x2F;1.创建函数式组件function MyComponent()&#123; console.log(this); &#x2F;&#x2F;此处的this是undefined，因为babel编译后开启了严格模式 return &lt;h2&gt;我是用函数定义的组件(适用于【简单组件】的定义)&lt;&#x2F;h2&gt;&#125;&#x2F;&#x2F;2.渲染组件到页面ReactDOM.render(&lt;MyComponent&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 4.2 类式组件执行了ReactDOM.render(…….之后，发生了什么？ React解析组件标签，找到了MyComponent组件。 发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用到原型上的render方法。 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。 1234567891011&#x2F;&#x2F;1.创建类式组件class MyComponent extends React.Component &#123; render()&#123; &#x2F;&#x2F;render是放在哪里的？—— MyComponent的原型对象上，供实例使用。 &#x2F;&#x2F;render中的this是谁？—— MyComponent的实例对象 &lt;&#x3D;&gt; MyComponent组件实例对象。 console.log(&#39;render中的this:&#39;,this); return &lt;h2&gt;我是用类定义的组件(适用于【复杂组件】的定义)&lt;&#x2F;h2&gt; &#125;&#125;&#x2F;&#x2F;2.渲染组件到页面ReactDOM.render(&lt;MyComponent&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 4.3 注意 组件名必须首字母大写 虚拟DOM元素只能有一个根元素 虚拟DOM元素必须有结束标签 4.4 渲染类组件标签的基本流程 React内部会创建组件实例对象 调用render()得到虚拟DOM, 并解析为真实DOM 插入到指定的页面元素内部 五、组件实例的三大属性之一 state12345678910111213141516171819202122232425262728293031323334353637383940&#x2F;&#x2F;1.创建组件class Weather extends React.Component&#123; &#x2F;&#x2F;构造器调用几次？ ———— 1次 constructor(props)&#123; console.log(&#39;constructor&#39;); super(props) &#x2F;&#x2F;初始化状态 this.state &#x3D; &#123;isHot:false,wind:&#39;微风&#39;&#125; &#x2F;&#x2F;解决changeWeather中this指向问题 this.changeWeather &#x3D; this.changeWeather.bind(this) &#125; &#x2F;&#x2F;render调用几次？ ———— 1+n次 1是初始化的那次 n是状态更新的次数 render()&#123; console.log(&#39;render&#39;); &#x2F;&#x2F;读取状态 const &#123;isHot,wind&#125; &#x3D; this.state return &lt;h1 onClick&#x3D;&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &#39;炎热&#39; : &#39;凉爽&#39;&#125;，&#123;wind&#125;&lt;&#x2F;h1&gt; &#125; &#x2F;&#x2F;changeWeather调用几次？ ———— 点几次调几次 changeWeather()&#123; &#x2F;&#x2F;changeWeather放在哪里？ ———— Weather的原型对象上，供实例使用 &#x2F;&#x2F;由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用 &#x2F;&#x2F;类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined console.log(&#39;changeWeather&#39;); &#x2F;&#x2F;获取原来的isHot值 const isHot &#x3D; this.state.isHot &#x2F;&#x2F;严重注意：状态必须通过setState进行更新,且更新是一种合并，不是替换。 this.setState(&#123;isHot:!isHot&#125;) console.log(this); &#x2F;&#x2F;严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！ &#x2F;&#x2F;this.state.isHot &#x3D; !isHot &#x2F;&#x2F;这是错误的写法 &#125;&#125;&#x2F;&#x2F;2.渲染组件到页面ReactDOM.render(&lt;Weather&#x2F;&gt;,document.getElementById(&#39;test&#39;)) state 简写形式 123456789101112131415161718&#x2F;&#x2F;1.创建组件class Weather extends React.Component&#123; &#x2F;&#x2F;初始化状态 state &#x3D; &#123;isHot:false,wind:&#39;微风&#39;&#125;render()&#123; const &#123;isHot,wind&#125; &#x3D; this.state return &lt;h1 onClick&#x3D;&#123;this.changeWeather&#125;&gt;今天天气很&#123;isHot ? &#39;炎热&#39; : &#39;凉爽&#39;&#125;，&#123;wind&#125;&lt;&#x2F;h1&gt;&#125;&#x2F;&#x2F;自定义方法————要用赋值语句的形式+箭头函数changeWeather &#x3D; ()&#x3D;&gt;&#123; const isHot &#x3D; this.state.isHot this.setState(&#123;isHot:!isHot&#125;)&#125;&#125;&#x2F;&#x2F;2.渲染组件到页面ReactDOM.render(&lt;Weather&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 5.1 理解 state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合) 组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件) 5.2 强烈注意 组件中render方法中的this为组件实例对象 组件自定义的方法中this为undefined，如何解决？a) 强制绑定this: 通过函数对象的bind()b) 箭头函数 状态数据，不能直接修改或更新 六、组件实例的三大属性之一 props6.1 理解 每个组件对象都会有props(properties的简写)属性 组件标签的所有属性都保存在props中 6.2 作用 通过标签属性从组件外向组件内传递变化的数据 注意: 组件内部不要修改props数据 6.3 编码操作 内部读取某个属性值 this.props.name 对props中的属性值进行类型限制和必要性限制 第一种方式（React v15.5 开始已弃用）： 1234Person.propTypes &#x3D; &#123; name: React.PropTypes.string.isRequired, age: React.PropTypes.number&#125; 第二种方式（新）：使用prop-types库进限制（需要引入prop-types库） 12345import PropTypes from &#39;prop-types.js&#39;Person.propTypes &#x3D; &#123; name: PropTypes.string.isRequired, age: PropTypes.number. &#125; 扩展属性: 将对象的所有属性通过props传递 1Person &#123;...person&#125;&#x2F;&gt; 默认属性值： 1234Person.defaultProps &#x3D; &#123; age: 18, sex:&#39;男&#39;&#125; 组件类的构造函数 1234constructor(props)&#123; super(props) console.log(props)&#x2F;&#x2F;打印所有属性&#125; 函数组件使用props 123456789101112131415161718192021222324&#x2F;&#x2F;创建组件function Person (props)&#123; const &#123;name,age,sex&#125; &#x3D; props return ( &lt;ul&gt; &lt;li&gt;姓名：&#123;name&#125;&lt;&#x2F;li&gt; &lt;li&gt;性别：&#123;sex&#125;&lt;&#x2F;li&gt; &lt;li&gt;年龄：&#123;age&#125;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; )&#125;Person.propTypes &#x3D; &#123; name:PropTypes.string.isRequired, &#x2F;&#x2F;限制name必传，且为字符串 sex:PropTypes.string,&#x2F;&#x2F;限制sex为字符串 age:PropTypes.number,&#x2F;&#x2F;限制age为数值&#125;&#x2F;&#x2F;指定默认标签属性值Person.defaultProps &#x3D; &#123; sex:&#39;男&#39;,&#x2F;&#x2F;sex默认值为男 age:18 &#x2F;&#x2F;age默认值为18&#125;&#x2F;&#x2F;渲染组件到页面ReactDOM.render(&lt;Person name&#x3D;&quot;jerry&quot;&#x2F;&gt;,document.getElementById(&#39;test1&#39;)) 七、组件实例的三大属性之一 refs与事件处理7.1 理解组件内的标签可以定义ref属性来标识自己 7.2 编码 字符串形式的ref1&lt;input ref=\"input1\"/&gt; 回调形式的ref1&lt;input ref=&#123;(c)=&gt;&#123;this.input1 = c&#125;&#125;/&gt; createRef创建ref容器 – 官方最推荐但比较繁琐12myRef = React.createRef() &lt;input ref=&#123;this.myRef&#125;/&gt; 7.3 事件处理 通过onXxx属性指定事件处理函数(注意大小写)1) React使用的是自定义(合成)事件, 而不是使用的原生DOM事件2) React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) 通过event.target得到发生事件的DOM元素对象 八、受控组件和非受控组件 包含表单的非受控组件 12345678910111213141516171819&#x2F;&#x2F;创建组件class Login extends React.Component&#123; handleSubmit &#x3D; (event)&#x3D;&gt;&#123; event.preventDefault() &#x2F;&#x2F;阻止表单提交 const &#123;username,password&#125; &#x3D; this alert(&#96;你输入的用户名是：$&#123;username.value&#125;,你输入的密码是：$&#123;password.value&#125;&#96;) &#125; render()&#123; return( &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt; 用户名：&lt;input ref&#x3D;&#123;c &#x3D;&gt; this.username &#x3D; c&#125; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt; 密码：&lt;input ref&#x3D;&#123;c &#x3D;&gt; this.password &#x3D; c&#125; type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&#x2F;&gt; &lt;button&gt;登录&lt;&#x2F;button&gt; &lt;&#x2F;form&gt; ) &#125;&#125;&#x2F;&#x2F;渲染组件ReactDOM.render(&lt;Login&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 包含表单的受控组件 1234567891011121314151617181920212223242526272829303132333435363738&#x2F;&#x2F;创建组件class Login extends React.Component&#123; &#x2F;&#x2F;初始化状态 state &#x3D; &#123; username:&#39;&#39;, &#x2F;&#x2F;用户名 password:&#39;&#39; &#x2F;&#x2F;密码 &#125;&#x2F;&#x2F;保存用户名到状态中saveUsername &#x3D; (event)&#x3D;&gt;&#123; this.setState(&#123;username:event.target.value&#125;)&#125;&#x2F;&#x2F;保存密码到状态中savePassword &#x3D; (event)&#x3D;&gt;&#123; this.setState(&#123;password:event.target.value&#125;)&#125;&#x2F;&#x2F;表单提交的回调handleSubmit &#x3D; (event)&#x3D;&gt;&#123; event.preventDefault() &#x2F;&#x2F;阻止表单提交 const &#123;username,password&#125; &#x3D; this.state alert(&#96;你输入的用户名是：$&#123;username&#125;,你输入的密码是：$&#123;password&#125;&#96;)&#125;render()&#123; return( &lt;form onSubmit&#x3D;&#123;this.handleSubmit&#125;&gt; 用户名：&lt;input onChange&#x3D;&#123;this.saveUsername&#125; type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt; 密码：&lt;input onChange&#x3D;&#123;this.savePassword&#125; type&#x3D;&quot;password&quot; name&#x3D;&quot;password&quot;&#x2F;&gt; &lt;button&gt;登录&lt;&#x2F;button&gt; &lt;&#x2F;form&gt; )&#125;&#125;&#x2F;&#x2F;渲染组件ReactDOM.render(&lt;Login&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 九、高阶函数&amp;函数柯里化 高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数。 若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。 若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。常见的高阶函数有：Promise、setTimeout、arr.map()等等 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 1234567function sum(a)&#123; return(b)&#x3D;&gt;&#123; return (c)&#x3D;&gt;&#123; return a+b+c &#125; &#125;&#125; 十、组件的生命周期 旧和新生命周期-旧 初始化阶段: 由ReactDOM.render()触发—初次渲染 constructor() componentWillMount() render() componentDidMount() =====&gt; 常用一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息 更新阶段: 由组件内部this.setSate()或父组件render触发 shouldComponentUpdate() componentWillUpdate() render() =====&gt; 必须使用的一个 componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 componentWillUnmount() =====&gt; 常用一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126&#x2F;&#x2F;创建组件class Count extends React.Component&#123;&#x2F;&#x2F;构造器constructor(props)&#123;console.log(&#39;Count---constructor&#39;);super(props)&#x2F;&#x2F;初始化状态this.state &#x3D; &#123;count:0&#125;&#125;&#x2F;&#x2F;加1按钮的回调add &#x3D; ()&#x3D;&gt;&#123;&#x2F;&#x2F;获取原状态const &#123;count&#125; &#x3D; this.state&#x2F;&#x2F;更新状态this.setState(&#123;count:count+1&#125;)&#125;&#x2F;&#x2F;卸载组件按钮的回调death &#x3D; ()&#x3D;&gt;&#123;ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))&#125;&#x2F;&#x2F;强制更新按钮的回调force &#x3D; ()&#x3D;&gt;&#123;this.forceUpdate()&#125;&#x2F;&#x2F;组件将要挂载的钩子componentWillMount()&#123;console.log(&#39;Count---componentWillMount&#39;);&#125;&#x2F;&#x2F;组件挂载完毕的钩子componentDidMount()&#123;console.log(&#39;Count---componentDidMount&#39;);&#125;&#x2F;&#x2F;组件将要卸载的钩子componentWillUnmount()&#123;console.log(&#39;Count---componentWillUnmount&#39;);&#125;&#x2F;&#x2F;控制组件更新的“阀门”shouldComponentUpdate()&#123;console.log(&#39;Count---shouldComponentUpdate&#39;);return true&#125;&#x2F;&#x2F;组件将要更新的钩子componentWillUpdate()&#123;console.log(&#39;Count---componentWillUpdate&#39;);&#125;&#x2F;&#x2F;组件更新完毕的钩子componentDidUpdate()&#123;console.log(&#39;Count---componentDidUpdate&#39;);&#125;render()&#123;console.log(&#39;Count---render&#39;);const &#123;count&#125; &#x3D; this.statereturn(&lt;div&gt;&lt;h2&gt;当前求和为：&#123;count&#125;&lt;&#x2F;h2&gt;&lt;button onClick&#x3D;&#123;this.add&#125;&gt;点我+1&lt;&#x2F;button&gt;&lt;button onClick&#x3D;&#123;this.death&#125;&gt;卸载组件&lt;&#x2F;button&gt;&lt;button onClick&#x3D;&#123;this.force&#125;&gt;不更改任何状态中的数据，强制更新一下&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;)&#125;&#125;&#x2F;&#x2F;父组件Aclass A extends React.Component&#123;&#x2F;&#x2F;初始化状态state &#x3D; &#123;carName:&#39;奔驰&#39;&#125;changeCar &#x3D; ()&#x3D;&gt;&#123;this.setState(&#123;carName:&#39;奥拓&#39;&#125;)&#125;render()&#123;return(&lt;div&gt;&lt;div&gt;我是A组件&lt;&#x2F;div&gt;&lt;button onClick&#x3D;&#123;this.changeCar&#125;&gt;换车&lt;&#x2F;button&gt;&lt;B carName&#x3D;&#123;this.state.carName&#125;&#x2F;&gt;&lt;&#x2F;div&gt;)&#125;&#125;&#x2F;&#x2F;子组件Bclass B extends React.Component&#123;&#x2F;&#x2F;组件将要接收新的props的钩子componentWillReceiveProps(props)&#123;console.log(&#39;B---componentWillReceiveProps&#39;,props);&#125;&#x2F;&#x2F;控制组件更新的“阀门”shouldComponentUpdate()&#123;console.log(&#39;B---shouldComponentUpdate&#39;);return true&#125;&#x2F;&#x2F;组件将要更新的钩子componentWillUpdate()&#123;console.log(&#39;B---componentWillUpdate&#39;);&#125;&#x2F;&#x2F;组件更新完毕的钩子componentDidUpdate()&#123;console.log(&#39;B---componentDidUpdate&#39;);&#125;render()&#123;console.log(&#39;B---render&#39;);return(&lt;div&gt;我是B组件，接收到的车是:&#123;this.props.carName&#125;&lt;&#x2F;div&gt;)&#125;&#125;&#x2F;&#x2F;渲染组件ReactDOM.render(&lt;Count&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 生命周期-新 初始化阶段: 由ReactDOM.render()触发—初次渲染 constructor() getDerivedStateFromProps render() componentDidMount() =====&gt; 常用一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息 更新阶段: 由组件内部this.setSate()或父组件重新render触发 getDerivedStateFromProps shouldComponentUpdate() render() getSnapshotBeforeUpdate componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 componentWillUnmount() =====&gt; 常用一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&#x2F;&#x2F;创建组件class Count extends React.Component&#123;&#x2F;&#x2F;构造器constructor(props)&#123;console.log(&#39;Count---constructor&#39;);super(props)&#x2F;&#x2F;初始化状态this.state &#x3D; &#123;count:0&#125;&#125;&#x2F;&#x2F;加1按钮的回调add &#x3D; ()&#x3D;&gt;&#123;&#x2F;&#x2F;获取原状态const &#123;count&#125; &#x3D; this.state&#x2F;&#x2F;更新状态this.setState(&#123;count:count+1&#125;)&#125;&#x2F;&#x2F;卸载组件按钮的回调death &#x3D; ()&#x3D;&gt;&#123;ReactDOM.unmountComponentAtNode(document.getElementById(&#39;test&#39;))&#125;&#x2F;&#x2F;强制更新按钮的回调force &#x3D; ()&#x3D;&gt;&#123;this.forceUpdate()&#125;&#x2F;&#x2F;若state的值在任何时候都取决于props，那么可以使用getDerivedStateFromPropsstatic getDerivedStateFromProps(props,state)&#123;console.log(&#39;getDerivedStateFromProps&#39;,props,state);return null&#125;&#x2F;&#x2F;在更新之前获取快照getSnapshotBeforeUpdate()&#123;console.log(&#39;getSnapshotBeforeUpdate&#39;);return &#39;atguigu&#39;&#125;&#x2F;&#x2F;组件挂载完毕的钩子componentDidMount()&#123;console.log(&#39;Count---componentDidMount&#39;);&#125;&#x2F;&#x2F;组件将要卸载的钩子componentWillUnmount()&#123;console.log(&#39;Count---componentWillUnmount&#39;);&#125;&#x2F;&#x2F;控制组件更新的“阀门”shouldComponentUpdate()&#123;console.log(&#39;Count---shouldComponentUpdate&#39;);return true&#125;&#x2F;&#x2F;组件更新完毕的钩子componentDidUpdate(preProps,preState,snapshotValue)&#123;console.log(&#39;Count---componentDidUpdate&#39;,preProps,preState,snapshotValue);&#125;render()&#123;console.log(&#39;Count---render&#39;);const &#123;count&#125; &#x3D; this.statereturn(&lt;div&gt;&lt;h2&gt;当前求和为：&#123;count&#125;&lt;&#x2F;h2&gt;&lt;button onClick&#x3D;&#123;this.add&#125;&gt;点我+1&lt;&#x2F;button&gt;&lt;button onClick&#x3D;&#123;this.death&#125;&gt;卸载组件&lt;&#x2F;button&gt;&lt;button onClick&#x3D;&#123;this.force&#125;&gt;不更改任何状态中的数据，强制更新一下&lt;&#x2F;button&gt;&lt;&#x2F;div&gt;)&#125;&#125;&#x2F;&#x2F;渲染组件ReactDOM.render(&lt;Count count&#x3D;&#123;199&#125;&#x2F;&gt;,document.getElementById(&#39;test&#39;)) 重要的勾子 render：初始化渲染或更新渲染调用 componentDidMount：开启监听, 发送ajax请求 componentWillUnmount：做一些收尾工作, 如: 清理定时器即将废弃的勾子 componentWillMount componentWillReceiveProps componentWillUpdate现在使用会出现警告，下一个大版本需要加上UNSAFE_前缀才能使用，以后可能会被彻底废弃，不建议使用。 十一、Key的作用react/vue中的key有什么作用？（key的内部原理是什么？）为什么遍历列表时，key最好不要用index? 虚拟DOM中key的作用： 简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。 详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下： a. 旧虚拟DOM中找到了与新虚拟DOM相同的key： (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM b. 旧虚拟DOM中未找到与新虚拟DOM相同的key根据数据创建新的真实DOM，随后渲染到到页面 用index作为key可能会引发的问题： 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 开发中如何选择key?:1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。2.如果确定只是简单的展示数据，用index也是可以的。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"Java基础编程 - 4、面向对象-中","slug":"frame/java/Java基础编程/4. 面向对象/面向对象-中","date":"2021-02-07T01:00:00.000Z","updated":"2022-06-05T14:08:41.963Z","comments":true,"path":"2021/02/07/frame/java/Java基础编程/4. 面向对象/面向对象-中/","link":"","permalink":"http://yoursite.com/2021/02/07/frame/java/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%AD/","excerpt":"","text":"1、OOP特征二 继承性 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。多个类称为子类(派生类)，单独的这个类称为父类(基类 或超类)类继承语法规则:class Subclass extends SuperClass{ } 1.1 继承性的好处： 少了代码的冗余，提高了代码的复用性 便于功能的扩展 为之后多态性的使用，提供了前提 1.2 继承性的格式： class A extends B{} A:子类、派生类、subclass B:父类、超类、基类、superclass 1.2.1体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只有因为封装性的影响，使得子类不能直接调用父类的结构而已。 1.2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。extends：延展、扩展 1.3 Java中关于继承性的规定：1.一个类可以被多个子类继承。 2.Java中类的单继承性：一个类只能有一个父类 3.子父类是相对的概念。 4.子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类 5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法1.4 Object类1. 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类 2. 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类 3. 意味着，所有的java类具有java.lang.Object类声明的功能。2、方法的重写override overwrite 在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 2.1 重写的规定1234# 方法的声明权限修饰符 返回值类型 方法名(形参列表) throws 异常的类型&#123; //方法体&#125; 约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法 ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同 ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符 &gt;特殊情况：子类不能重写父类中声明为private权限的方法 ③ 返回值类型： &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类 &gt;父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double) ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型（具体放到异常处理时候讲） 注意：子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写）。 ​ 3、四种访问权限修饰符 修饰符 类内部 同一个包 不同包的子类 同一个工程 private yes —- —- —- 缺省 yes yes —- —- protected yes yes yes —- public yes yes yes yes 对于class的权限修饰只可以用public和default(缺省) public类可以在任意地方被访问。 default类只可以被同一个包内部的类访问。 4、关键字super在Java类中使用super来调用父类中的指定操作： super可用于访问父类中定义的属性 super可用于调用父类中定义的成员方法 super可用于在子类构造器中调用父类的构造器 注意： 尤其当子父类出现同名成员时，可以用super表明调用的是父类中的成员 super的追溯不仅限于直接父类 super和this的用法相像，this代表本类对象的引用，super代表父类的内存空间的标识 1234567891011121314151617181920212223class Person &#123; protected String name = \"张三\"; 关键字super举例 protected int age; public String getInfo() &#123; return \"Name: \" + name + \"\\nage: \" + age; &#125; &#125;class Student extends Person &#123; protected String name = \"李四\"; private String school = \"New Oriental\"; public String getSchool() &#123; return school; &#125; public String getInfo() &#123; return super.getInfo() + \"\\nschool: \" + school; &#125;&#125;public class StudentTest &#123; public static void main(String[] args) &#123; Student st = new Student(); System.out.println(st.getInfo()); &#125;&#125; 调用父类构造器举例 子类中所有的构造器默认都会访问父类中空参数的构造器 当父类中没有空参数的构造器时，子类的构造器必须通过this(参数列表)或者super(参数列表)语句指定调用本类或者父类中相应的构造器。同时，只能”二选一”，且必须放在构造器的首行 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错 this和super的区别 区别点 this super 1 访问属性 访问本类中的属性，如果本类没有此属性则从父类中继续查找 直接访问父类中的属性 2 调用方法 访问本类中的方法，如果本类没有此方法则从父类中继续查找 直接访问父类中的方法 3 调用构造器 调用本类构造器，必须放在构造器的首行 调用父类构造器，必须放在子类构造器的首行 5、子类对象实例化过程5.1从结果上来看：（继承性）子类继承父类以后，就获取了父类中声明的属性或方法。 创建子类的对象，在堆空间中，就会加载所有父类中声明的属性。5.2从过程上来看：当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，... 直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构，子类对象才可以考虑进行调用。明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。 6、OOP特征三 多态性6.1.理解多态性：可以理解为一个事物的多种形态。6.2.何为多态性：对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）6.3.多态的使用：虚拟方法调用有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。总结： 编译，看左边 - 看的是父类的引用（父类中不具备子类特有的方法） 运行，看右边 - 看的是子类的对象（实际运行的是子类重写父类的方法） 6.4.多态性的使用前提：① 类的继承关系② 方法的重写 6.5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）6.7.instanceof 操作符x instanceof A：检验x是否为类A的对象，返回值为boolean型。 要求x所属的类与类A必须是子类和父类的关系，否则编译错误。 如果x属于类A的子类B，x instanceof A值也为true。 6.8 对象类型转换 (Casting ) 基本数据类型的Casting： 自动类型转换：小的数据类型可以自动转换成大的数据类型如long g=20; double d=12.0f 强制类型转换：可以把大的数据类型强制转换(casting)成小的数据类型如 float f=(float)12.0; int a=(int)1200L 对Java对象的强制类型转换称为造型 从子类到父类的类型转换可以自动进行 从父类到子类的类型转换必须通过造型(强制类型转换)实现 无继承关系的引用类型间的转换是非法的 在造型前可以使用instanceof操作符测试一个对象的类型 7、 java.lang.Object类的使用 1.Object类是所有Java类的根父类 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 3.Object类中的功能(属性、方法)就具有通用性。 属性：无 方法：equals() / toString() / getClass() /hashCode() / clone() / finalize()wait() 、 notify()、notifyAll() 4.Object类只声明了一个空参的构造器 NO. 方法名称 类型 描述 1 public Object() 构造 2 public boolean equals(Object obj) 普通 对象比较 3 public int hashCode() 普通 取得Hash码 4 public String toString() 普通 对象打印时调用 7.1 == 和 equals() 区别 一、回顾 == 的使用：== ：运算符 可以使用在基本数据类型变量和引用数据类型变量中 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。 二、equals()方法的使用： 是一个方法，而非运算符 只能适用于引用数据类型 Object类中equals()的定义：public boolean equals(Object obj) {return (this == obj); }说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同。 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同. 三、重写equals()方法的原则 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。 自反性：x.equals(x)必须返回是“true”。 传递性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管重复x.equals(y)多少次，返回都是“true”。 任何情况下，x.equals(null)，永远返回是“false”； x.equals(和x不同类型的对象)永远返回是“false”。 7.2 Object类中toString()的使用 当我们输出一个对象的引用时，实际上就是调用当前对象的toString() Object类中toString()的定义： 123public String toString() &#123; return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); &#125; 12 像String、Date、File、包装类等都重写了Object类中的toString()方法。使得在调用对象的toString()时，返回”实体内容”信息 自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容” 8、包装类的使用 针对八种基本数据类型定义相应的引用类型—包装类（封装类） 有了类的特点，就可以调用类中的方法，Java才是真正的面向对象 基本数据类型 包装类 byte Byte 父类Number short Short 父类Number int Integer 父类Number long Long 父类Number float Float 父类Number double Double 父类Number boolean Boolean char Character 8.1 装箱 &amp; 拆箱 基本数据类型包装成包装类的实例 —装箱 通过包装类的构造器实现：int i = 500; Integer t = new Integer(i); 还可以通过字符串参数构造包装类对象：Float f = new Float(“4.56”);Long l = new Long(“asdf”); //NumberFormatException 获得包装类对象中包装的基本类型变量 —拆箱 调用包装类的.xxxValue()方法：boolean b = bObj.booleanValue(); JDK1.5之后，支持自动装箱，自动拆箱。但类型必须匹配。 字符串转换成基本数据类型 通过包装类的构造器实现：int i = new Integer(“12”); 通过包装类的parseXxx(String s)静态方法：Float f = Float.parseFloat(“12.1”); 基本数据类型转换成字符串 调用字符串重载的valueOf()方法：String fstr = String.valueOf(2.34f); 更直接的方式：String intStr = 5 + “” 8.2 Java中的JUnit单元测试 步骤： 1.选中当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步 2.创建Java类，进行单元测试。 此时的Java类要求：① 此类是public的 ②此类提供公共的无参的构造器 3.此类中声明单元测试方法。 此时的单元测试方法：方法的权限是public,没有返回值，没有形参 4.此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test; 5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。 6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test 说明： 1.如果执行结果没有任何异常：绿条 2.如果执行结果出现异常：红条","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"前端月刊【2021-01】","slug":"weeks/2021/2021-01","date":"2021-01-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2021/01/30/weeks/2021/2021-01/","link":"","permalink":"http://yoursite.com/2021/01/30/weeks/2021/2021-01/","excerpt":"","text":"23 个非常有用的 NodeJs 库您必须知道的 Git 分支开发规范Vue 项目性能优化 — 实践指南（网上最全 / 详细","categories":[],"tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"Effective Java","slug":"book/2021/EffectiveJava","date":"2021-01-10T02:00:00.000Z","updated":"2022-06-05T14:08:41.958Z","comments":true,"path":"2021/01/10/book/2021/EffectiveJava/","link":"","permalink":"http://yoursite.com/2021/01/10/book/2021/EffectiveJava/","excerpt":"","text":"一 引言目的：高效实用java.lang、java.util、java.io等库。 二 创建和销毁对象第一条 考虑用表态工厂方法代替构造器 静态工厂方法与构造器的不同 第一大优势在于，它们有名称。 第二大优势在于，不必在每次调用它们的时候都创建一个新对象。 第三大优势在于，它们可以返回原返回类型的任何子类型的对象。 第四大优势在于，在创建参数化类型实例的时候，它们使代码变得更加简洁。 静态工厂方法的主要缺点 第一，类如果不含公有的或者受保护的构造器，就不能被子类化。 第二，它们与其它的静态方法实际上没有任何区别。 第二条 遇到多个构造器参数时要考虑用构建器 1、telescoping constructor （又称为重叠构造器） 2、JavaBeans模式 3、Builder模式 兼容以上两种 第三条 用私有构造器或者枚举类型强化singleton属性仅仅被实例化一次的类。把构造器保持为私有的，并导出公有的静态成员，以便允许客户端能够访问该类的唯一实例。 1、私有构造器仅被调用一次，用来实例化公有的静态final域Elvis.INSTANCE 12345public class Evlis &#123; private static final Elvis INSTANCE = new Elvis(); private Elvis()&#123;...&#125;; public voide leaveTheBuilding()&#123;...&#125;&#125; 2、静态方法Elvis.getInstance的所有调用，都会返回同一个对象引用，所以永远不会创建其它的Elvis实例 123456public class Evlis &#123; private static final Elvis INSTANCE = new Elvis(); private Elvis()&#123;...&#125;; public static Elvis getInstance()&#123;return Instance;&#125; public voide leaveTheBuilding()&#123;...&#125;&#125; 第四条 通过私有构造器强化不可实例化的能力第五条 避免创建不必要的对象12String s = new String(\"stringette\");// no!!String s = \"stringette\";// yes !! 自动装箱（autoboxing）允许程序员将基本类型和装箱基本类型混用，按需要自动装箱和拆箱。 要先使用基本类型而不是装箱 基本类型，要当心无意识的自动装箱。 也不是一味的不能创建对象，小对象的创建和回收动作是非常廉价的。通过创建附加的对象，提升程序清晰性，简洁性，功能性，是件好事。 反之，通过维护自己的对象池object pool来避免创建对象并不是一种 好的做法，除非对象池中的对象 是非常重量级的。（真正正确使用对象池的典型对象示例就是数据库连接池） 保护性拷贝（defensive copying）当你应该重用现有对象的时候，请不要创建新的对象；当你应该创建新对象的时候，请不要重用现有的对象。 第六条 消除过期的对象引用需要时刻考虑内存管理的工作，防止内存泄漏。 栈先是增长，后收缩，从栈中出来的对象将不会被当做垃圾回收，栈内部维护着对这些对象的过期引用obsolete reference。 对象引用过期，清空引用。 只要类是自己管理内存，程序员就应该警惕内存泄漏问题 一理把对象引用 放到缓存，就容易忘记，也会导致内存泄漏 监听器和其它回调也会导致 第七条 避免使用终结方法终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。 三 对于所有对象都通用的方法第八条 覆盖equals时请遵守通用约定 什么情况下需要覆盖？ 类的每个实例本质上都是唯一的 不关心类是否提供了逻辑相等的测试功能 超类已覆盖了equals，从超类继承过来的行为对于子类也是合适的 类是私有的或是包级私有的，可以确定它的equals方法永远 不会被调用 equals的约定 *** 自反性 对称性 传递性 一致性 对于任何非Null的引用值x。x.equals(null)必须返回false 第九条 覆盖equals时总要覆盖hashCode没有覆盖hasCode而违反的关键约定是第二条，相等的对象必须具有相等的数列码。 第十条 始终要覆盖toStringjava.lang.Object提供了toString方法的一个实现，但它的返回字符串通常并不是类的用户所期望看到的，包含了一个@符号，接着是散列码的无符号十六进制表示法。 虽然没有equals hasCode重要，但是一旦被广泛使用，提供好的toString实现可以使类使用起来更加舒适。toString也时常会被其它方法所自动调用，因为覆盖toString很有必要，返回对象中包含的所值得关注的信息。 第十一条 谨慎地覆盖cloneCloneable接口的目的是作为对象的一个mixin接口，表明这样的对象允许克隆。遗憾的是，并没有成功的达到这个目的，主要缺陷在于它缺少一个cone方法。object的clone是受保护的。 解决方法 拷贝构造器copy constructor或拷贝工厂copy factory 第十二条 考虑实现comparable接口类实现了Comparable接口，就表明它的实例具有内在的排序关系natural ordering。","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Java基础编程 - 4、面向对象-上","slug":"frame/java/Java基础编程/4. 面向对象/面向对象-上","date":"2021-01-07T01:00:00.000Z","updated":"2022-06-05T14:08:41.963Z","comments":true,"path":"2021/01/07/frame/java/Java基础编程/4. 面向对象/面向对象-上/","link":"","permalink":"http://yoursite.com/2021/01/07/frame/java/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8A/","excerpt":"","text":"1 类的对象1、Java面向对象学习的三条主线： 1.Java类及类的成员：属性、方法、构造器；代码块、内部类 2.面向对象的三大特征：封装性、继承性、多态性、(抽象性) 3.其它关键字：this、super、static、final、abstract、interface、package、import等“大处着眼，小处着手” 2、“人把大象装进冰箱”1.面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。123① 把冰箱门打开② 抬起大象，塞进冰箱② 把冰箱门关闭 2.面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。12345678910111213141516171819202122232425人&#123; 打开(冰箱)&#123; 冰箱.开开(); &#125; 抬起(大象)&#123; 大象.进入(冰箱); &#125; 关闭(冰箱)&#123; 冰箱.闭合(); &#125;&#125;冰箱&#123; 开开()&#123;&#125; 闭合()&#123;&#125;&#125;大象&#123; 进入(冰箱)&#123; &#125;&#125; 3、面向对象的两个要素： 类：对一类事物的描述，是抽象的、概念上的定义 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance) 面向对象程序设计的重点是类的设计 设计类，就是设计类的成员。 2 类的结构之一 属性属性（成员变量） vs 局部变量 1.相同点： 1.1 定义变量的格式：数据类型 变量名 = 变量值 1.2 先声明，后使用 1.3 变量都有其对应的作用域 2.不同点： 2.1 在类中声明的位置的不同 属性：直接定义在类的一对{}内 局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 2.2 关于权限修饰符的不同 属性：可以在声明属性时，指明其权限，使用权限修饰符。 常用的权限修饰符：private、public、缺省、protected ---&gt;封装性 目前，大家声明属性时，都使用缺省就可以了。 局部变量：不可以使用权限修饰符。 2.3 默认初始化值的情况： 属性：类的属性，根据其类型，都有默认初始化值。 整型（byte、short、int、long）：0 浮点型（float、double）：0.0 字符型（char）：0 （或&apos;\\u0000&apos;） 布尔型（boolean）：false 引用数据类型（类、数组、接口）：null 局部变量：没有默认初始化值。 意味着，我们在调用局部变量之前，一定要显式赋值。 特别地：形参在调用时，我们赋值即可。 2.4 在内存中加载的位置： 属性：加载到堆空间中 （非static） 局部变量：加载到栈空间3 类的结构之二 方法方法：描述类应该具有的功能。 比如：Math类：sqrt()\\random() \\... Scanner类：nextXxx() ... Arrays类：sort() \\ binarySearch() \\ toString() \\ equals() \\ ... 1.举例： public void eat(){} public void sleep(int hour){} public String getName(){} public String getNation(String nation){} 2. 方法的声明：权限修饰符 返回值类型 方法名(形参列表){ 方法体 } 注意：static、final、abstract 来修饰的方法，后面再讲。 3. 说明： 3.1 关于权限修饰符：默认方法的权限修饰符先都使用public Java规定的4种权限修饰符：private、public、缺省、protected --&gt;封装性再细说 3.2 返回值类型： 有返回值 vs 没有返回值 3.2.1 如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用 return关键字来返回指定类型的变量或常量：“return 数据”。 如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要 使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。 3.2.2 我们定义方法该不该有返回值？ ① 题目要求 ② 凭经验：具体问题具体分析 3.3 方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 3.4 形参列表： 方法可以声明0个，1个，或多个形参。 3.4.1 格式：数据类型1 形参1,数据类型2 形参2,... 3.4.2 我们定义方法时，该不该定义形参？ ① 题目要求 ② 凭经验：具体问题具体分析 3.5 方法体：方法功能的体现。 4.return关键字的使用： 1.使用范围：使用在方法体中 2.作用：① 结束方法 ② 针对于有返回值类型的方法，使用&quot;return 数据&quot;方法返回所要的数据。 3.注意点：return关键字后面不可以声明执行语句。 5. 方法的使用中，可以调用当前类的属性或方法 特殊的：方法A中又调用了方法A:递归方法。 方法中，不可以定义方法。4 类的特征之一 封装性 ####一、问题的引入： 当我们创建一个类的对象以后，我们可以通过”对象.属性”的方式，对对象的属性进行赋值。这里，赋值操作要受到 属性的数据类型和存储范围的制约。除此之外，没有其他制约条件。但是，在实际问题中，我们往往需要给属性赋值加入额外的限制条件。这个条件就不能在属性声明时体现，我们只能通过方法进行限制条件的添加。（比如：setLegs()） 同时，我们需要避免用户再使用”对象.属性”的方式对属性进行赋值。则需要将属性声明为私有的(private). –&gt;此时，针对于属性就体现了封装性。 二、封装性的体现： 我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值 拓展：封装性的体现：① 如上 ② 不对外暴露的私有的方法 ③ 单例模式 … 三、封装性的体现，需要权限修饰符来配合。 1.Java规定的4种权限（从小到大排列）：private、缺省、protected 、public 2.4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类 3.具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类修饰类的话，只能使用：缺省、public 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。 5 类的结构 构造器 类的结构之三：构造器（或构造方法、constructor）的使用 construct：建设、建造。 construction:CCB constructor:建设者 一、构造器的作用： 1.创建对象 2.初始化对象的信息 二、说明： 1.如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器 2.定义构造器的格式：权限修饰符 类名(形参列表){} 3.一个类中定义的多个构造器，彼此构成重载 4.一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器 5.一个类中，至少会有一个构造器。 总结：属性赋值的先后顺序 ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过”对象.方法” 或 “对象.属性”的方式，赋值 以上操作的先后顺序：① - ② - ③ - ④ JavaBean是一种Java语言写成的可重用组件。所谓JavaBean，是指符合如下标准的Java类： &gt;类是公共的 &gt;有一个无参的公共的构造器 &gt;有属性，且有对应的get、set方法6 关键字 thisthis关键字的使用： this可以用来修饰、调用：属性、方法、构造器 this修饰属性和方法： this理解为：当前对象 或 当前正在创建的对象 2.1 在类的方法中，我们可以使用”this.属性”或”this.方法”的方式，调用当前对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式 的使用”this.变量”的方式，表明此变量是属性，而非形参。 2.2 在类的构造器中，我们可以使用”this.属性”或”this.方法”的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都选择省略”this.”。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用”this.变量”的方式，表明此变量是属性，而非形参。 this调用构造器 ① 我们在类的构造器中，可以显式的使用&quot;this(形参列表)&quot;方式，调用本类中指定的其他构造器 ② 构造器中不能通过&quot;this(形参列表)&quot;方式调用自己 ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了&quot;this(形参列表)&quot; ④ 规定：&quot;this(形参列表)&quot;必须声明在当前构造器的首行 ⑤ 构造器内部，最多只能声明一个&quot;this(形参列表)&quot;，用来调用其他的构造器 7 关键字 package/import一、package关键字的使用 1.为了更好的实现项目中类的管理，提供包的概念 2.使用package声明类或接口所属的包，声明在源文件的首行 3.包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意” 4.每”.”一次，就代表一层文件目录。 补充：同一个包下，不能命名同名的接口、类。 不同的包下，可以命名同名的接口、类。 二、import关键字的使用 import:导入 在源文件中显式的使用import结构导入指定包下的类、接口 声明在包的声明和类的声明之间 如果需要导入多个结构，则并列写出即可 可以使用”xxx.”的方式，表示可以导入xxx包下的所有结构 如果使用的类或接口是java.lang包下定义的，则可以省略import结构 如果使用的类或接口是本包下定义的，则可以省略import结构 如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。 使用”xxx.”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入 import static:导入指定类或接口中的静态结构:属性或方法。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java基础编程 - 4、面向对象-下","slug":"frame/java/Java基础编程/4. 面向对象/面向对象-下","date":"2021-01-07T01:00:00.000Z","updated":"2022-06-05T14:08:41.963Z","comments":true,"path":"2021/01/07/frame/java/Java基础编程/4. 面向对象/面向对象-下/","link":"","permalink":"http://yoursite.com/2021/01/07/frame/java/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/4.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E4%B8%8B/","excerpt":"","text":"","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java基础编程 - 3、数组","slug":"frame/java/Java基础编程/3. 数组/数组","date":"2021-01-06T01:00:00.000Z","updated":"2022-06-05T14:08:41.962Z","comments":true,"path":"2021/01/06/frame/java/Java基础编程/3. 数组/数组/","link":"","permalink":"http://yoursite.com/2021/01/06/frame/java/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/3.%20%E6%95%B0%E7%BB%84/%E6%95%B0%E7%BB%84/","excerpt":"","text":"1 数组的概述概念数组(Array)，是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式 对这些数据进行统一管理。 数组的常见概念 数组名 下标(或索引) 元素 数组的长度 数组本身是引用数据类型，而数组中的元素可以是任何数据类型，包括基本数据类型和引用数据类型。创建数组对象会在内存中开辟一整块连续的空间，而数组名中引用的是这块连续空间的首地址。  数组的长度一旦确定，就不能修改。我们可以直接通过下标(或索引)的方式调用指定位置的元素，速度很快。数组的分类： 按照维度：一维数组、二维数组、三维数组、… 按照元素的数据类型分：基本数据类型元素的数组、引用数据类型元素的数组(即对象数组)数组元素的默认初始化值 数组元素是整型：0 数组元素是浮点型：0.0 数组元素是char型：0或’\\u0000’，而非’0’ 数组元素是boolean型：false 数组元素是引用数据类型：null2 一维数组的使用 ① 一维数组的声明和初始化 ② 如何调用数组的指定位置的元素 ③ 如何获取数组的长度 ④ 如何遍历数组 ⑤ 数组元素的默认初始化值 ：见ArrayTest1.java ⑥ 数组的内存解析 ：见ArrayTest1.java3 多维数组的使用 二维数组的使用 1.理解： 对于二维数组的理解，我们可以看成是一维数组array1又作为另一个一维数组array2的元素而存在。 其实，从数组底层的运行机制来看，其实没有多维数组。 二维数组的使用:① 二维数组的声明和初始化② 如何调用数组的指定位置的元素③ 如何获取数组的长度④ 如何遍历数组⑤ 数组元素的默认初始化值 :见 ArrayTest3.java⑥ 数组的内存解析 :见 ArrayTest3.java 4 数组中涉及到的常见算法 数组元素的赋值(杨辉三角、回形数等) 求数值型数组中元素的最大值、最小值、平均数、总和等 数组的复制、反转、查找(线性查找、二分法查找) 数组元素的排序算法 排序算法分类：内部排序和外部排序。 内部排序：整个排序过程不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。 外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路归并排序。可以认为外部排序是由多次内部排序组成。 十大内部排序算法 选择排序 直接选择排序、堆排序 交换排序 冒泡排序、快速排序 插入排序 直接插入排序、折半插入排序、Shell排序 归并排序 桶式排序 基数排序 5 Arrays工具类的使用java.util.Arrays类即为操作数组的工具类，包含了用来操作数组（比如排序和搜索）的各种方法。1 boolean equals(int[] a,int[] b) 判断两个数组是否相等。2 String toString(int[] a) 输出数组信息。3 void fill(int[] a,int val) 将指定值填充到数组之中。4 void sort(int[] a) 对数组进行排序。5 int binarySearch(int[] a,int key) 对排序后的数组进行二分法检索指定的值。 6 数组使用中的常见异常数组脚标越界异常(ArrayIndexOutOfBoundsException)1234int[] arr = new int[2];System.out.println(arr[2]);System.out.println(arr[-1]);// 访问到了数组中的不存在的脚标时发生 空指针异常(NullPointerException)123int[] arr = null;System.out.println(arr[0]);// arr引用没有指向实体，却在操作实体中的元素时","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Java基础编程 - 2、基础语法","slug":"frame/java/Java基础编程/2. 基本语法/基本语法","date":"2020-12-28T01:00:00.000Z","updated":"2022-06-05T14:08:41.962Z","comments":true,"path":"2020/12/28/frame/java/Java基础编程/2. 基本语法/基本语法/","link":"","permalink":"http://yoursite.com/2020/12/28/frame/java/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/2.%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1 关键字与保留字关键字(keyword)的定义和特点 定义：被Java语言赋予了特殊含义，用做专门用途的字符串（单词） 特点：关键字中所有字母都为小写123456789101112131415161718192021222324用于定义数据类型的关键字class interface enum byte shortint long float double charboolean void用于定义流程控制的关键字if else switch case defaultwhile do for break continuereturn用于定义访问权限修饰符的关键字private protected public用于定义类，函数，变量修饰符的关键字abstract final static synchronized用于定义类与类之间关系的关键字extends implements用于定义建立实例及引用实例，判断实例的关键字new this super instanceof用于异常处理的关键字try catch finally throw throws用于包的关键字package import其他修饰符关键字native strictfp transient volatile assert* 用于定义数据类型值的字面值true false null 保留字(reserved word) Java保留字：现有Java版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字 goto 、const 2 标识符(Identifier)标识符： Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符 技巧：凡是自己可以起名字的地方都叫标识符。 定义合法标识符规则： 由26个英文字母大小写，0-9 ，_或 $ 组成 数字不可以开头。 不可以使用关键字和保留字，但能包含关键字和保留字。 Java中严格区分大小写，长度无限制。 标识符不能包含空格。Java中的名称命名规范： 包名：多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 3 变量变量的概念： 内存中的一个存储区域 该区域的数据可以在同一类型范围内不断变化 变量是程序中最基本的存储单元。包含变量类型、变量名和存储的值变量的作用： 用于在内存中保存数据使用变量注意： Java中每个变量必须先声明，后使用 使用变量名来访问这块区域的数据 变量的作用域：其定义所在的一对{ }内 变量只有在其作用域内才有效 同一个作用域内，不能定义重名的变量 声明变量 语法：&lt;数据类型&gt; &lt;变量名称&gt;  例如：int var; ① 变量必须先声明，后使用 ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了 ③ 同一个作用域内，不可以声明两个同名的变量变量的赋值 语法：&lt;变量名称&gt; = &lt;值&gt;  例如：var = 10;声明和赋值变量 语法： &lt;数据类型&gt; &lt;变量名&gt; = &lt;初始化值&gt;  例如：int var = 10; 变量的分类-按数据类型 基本数据类型：整型：byte \\ short \\ int \\ long 浮点型：float \\ double 字符型：char 布尔型：boolean 引用数据类型：类(class) 接口(interface) 数组(array) 变量的分类-按声明的位置的不同 在方法体外，类体内声明的变量称为成员变量。 在方法体内部声明的变量称为局部变量。 基本数据类型之间的运算规则前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型的。 自动类型提升： 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。 byte 、char 、short –&gt; int –&gt; long –&gt; float –&gt; double 特别的：当byte、char、short三种类型的变量做运算时，结果为int型 强制类型转换：见VariableTest3.java说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量 强制类型转换：自动类型提升运算的逆运算。1.需要使用强转符：()2.注意点：强制类型转换，可能导致精度损失。 计算机中不同进制的使用说明 对于整数，有四种表示方式： 二进制(binary)：0,1 ，满2进1.以0b或0B开头。十进制(decimal)：0-9 ，满10进1。八进制(octal)：0-7 ，满8进1. 以数字0开头表示。十六进制(hex)：0-9及A-F，满16进1. 以0x或0X开头表示。此处的A-F不区分大小写。 如：0x21AF +1= 0X21B0 4 运算符算术运算符 / % (前)++ (后)++ (前)– (后)– +赋值运算符= += -= *= /= %= 比较运算符（关系运算符）== != &gt; &lt; &gt;= &lt;= instanceof结论： 1.比较运算符的结果是boolean类型2.区分 == 和 = 逻辑运算符&amp; &amp;&amp; | || ! ^说明：1.逻辑运算符操作的都是boolean类型的变量 位运算符 位运算符操作的都是整型的数据 &lt;&lt; ：在一定范围内，每向左移1位，相当于 * 2 :在一定范围内，每向右移1位，相当于 / 2 三元运算符1.结构：(条件表达式)? 表达式1 : 表达式22. 说明① 条件表达式的结果为boolean类型② 根据条件表达式真或假，决定执行表达式1，还是表达式2. 如果表达式为true，则执行表达式1。 如果表达式为false，则执行表达式2。③ 表达式1 和表达式2要求是一致的。④ 三元运算符可以嵌套使用 凡是可以使用三元运算符的地方，都可以改写为if-else反之，不成立。 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。 12345678910111213141516/*基本数据类型之间的运算规则：前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型的。1. 自动类型提升： 结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。 byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double 特别的：当byte、char、short三种类型的变量做运算时，结果为int型 2. 强制类型转换：见VariableTest3.java说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量*/ 5 流程控制顺序结构程序从上到下逐行地执行，中间没有任何判断和跳转。 分支结构根据条件，选择性地执行某段代码。有if…else和switch-case两种分支语句。 分支结构之一 if…else （条件判断结构） 第一种： 123if(条件表达式)&#123; 执行表达式&#125; 第二种：二选一 12345if(条件表达式)&#123; 执行表达式1&#125;else&#123; 执行表达式2&#125; 第三种：n选一 1234567891011if(条件表达式)&#123; 执行表达式1&#125;else if(条件表达式)&#123; 执行表达式2&#125;else if(条件表达式)&#123; 执行表达式3&#125;...else&#123; 执行表达式n&#125; 分支结构之二：switch-case123456789101112switch(表达式)&#123;case 常量1: 执行语句1; //break;case 常量2: 执行语句2; //break;...default: 执行语句n; //break;&#125; ① 根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。 当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。 ② break,可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构 ③ switch结构中的表达式，只能是如下的6种数据类型之一：byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增) ④ case 之后只能声明常量。不能声明范围。 ⑤ break关键字是可选的。 ⑥ default:相当于if-else结构中的else. default结构是可选的，而且位置是灵活的。 循环结构根据循环条件，重复性的执行某段代码。有while、do…while、for三种循环语句。注：JDK1.5提供了foreach循环，方便的遍历集合、数组元素。 循环结构：forFor循环结构的使用一、循环结构的4个要素① 初始化条件② 循环条件 —&gt;是boolean类型③ 循环体④ 迭代条件 二、for循环的结构 1234for(①;②;④)&#123; ③&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② 循环结构 - While 循环的使用While 循环的使用一、循环结构的4个要素① 初始化条件② 循环条件 —&gt;是boolean类型③ 循环体④ 迭代条件 二、while循环的结构 1234567①while(②)&#123; ③; ④;&#125;执行过程：① - ② - ③ - ④ - ② - ③ - ④ - ... - ② 1.写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！2.我们写程序，要避免出现死循环。3.for循环和while循环是可以相互转换的！ 区别：for循环和while循环的初始化条件部分的作用范围不同。 嵌套循环 嵌套循环：将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环 外层循环：循环结构B 内层循环：循环结构A 说明① 内层循环结构遍历一遍，只相当于外层循环循环体执行了一次② 假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次 技巧： 外层循环控制行数，内层循环控制列数 do-while循环的使用一、循环结构的4个要素① 初始化条件② 循环条件 —&gt;是boolean类型③ 循环体④ 迭代条件 二、do-while循环结构： 123456①do&#123; ③; ④;&#125;while(②);执行过程：① - ③ - ④ - ② - ③ - ④ - ... - ② 说明：1.do-while循环至少会执行一次循环体！2.开发中，使用for和while更多一些。较少使用do-while break和continue关键字的使用使用范围 循环中使用的作用(不同点) 相同点break: switch-case循环结构中 结束当前循环 关键字后面不能声明执行语句continue: 循环结构中 结束当次循环 关键字后面不能声明执行语句","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"前端周刊【202012-4】","slug":"weeks/2020/202012-4","date":"2020-12-27T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2020/12/27/weeks/2020/202012-4/","link":"","permalink":"http://yoursite.com/2020/12/27/weeks/2020/202012-4/","excerpt":"","text":"2020年大前端技术趋势解读 微前端在美团外卖的实践 可视化拖拽组件库一些技术要点原理分析","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202012-2】","slug":"weeks/2020/202012-3","date":"2020-12-20T01:00:00.000Z","updated":"2022-06-05T14:08:41.969Z","comments":true,"path":"2020/12/20/weeks/2020/202012-3/","link":"","permalink":"http://yoursite.com/2020/12/20/weeks/2020/202012-3/","excerpt":"","text":"回到页面指定位置的三种方式 Lodash 源码中的那些迷人的细节","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"Java基础编程 - 1、语言描述","slug":"frame/java/Java基础编程/1.语言描述/语言描述","date":"2020-12-16T01:00:00.000Z","updated":"2022-06-05T14:08:41.962Z","comments":true,"path":"2020/12/16/frame/java/Java基础编程/1.语言描述/语言描述/","link":"","permalink":"http://yoursite.com/2020/12/16/frame/java/Java%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B/1.%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"什么是计算机语言第一代语言 机器语言。指令以二进制代码形式存在。 第二代语言 汇编语言。使用助记符表示一条机器指令。 第三代语言：高级语言 C、Pascal、Fortran面向过程的语言C++面向过程/面向对象Java跨平台的纯面向对象的语言.NET跨语言的平台Python、Scala… Java历史SUN(Stanford University Network，斯坦福大学网络公司 ) 1995年推出的一门高级编程语言。 12345678910111213 1991年 Green项目，开发语言最初命名为Oak (橡树)  1994年，开发组意识到Oak 非常适合于互联网 1996年，发布JDK 1.0，约8.3万个网页应用Java技术来制作 1997年，发布JDK 1.1，JavaOne会议召开，创当时全球同类会议规模之最 1998年，发布JDK 1.2，同年发布企业平台J2EE 1999年，Java分成J2SE、J2EE和J2ME，JSP&#x2F;Servlet技术诞生 2004年，发布里程碑式版本：JDK 1.5，为突出此版本的重要性，更名为JDK 5.0 2005年，J2SE -&gt; JavaSE，J2EE -&gt; JavaEE，J2ME -&gt; JavaME 2009年，Oracle公司收购SUN，交易价格74亿美元 2011年，发布JDK 7.0 2014年，发布JDK 8.0，是继JDK 5.0以来变化最大的版本 2017年，发布JDK 9.0，最大限度实现模块化 2018年3月，发布JDK 10.0，版本号也称为18.3 2018年9月，发布JDK 11.0，版本号也称为18.9 Java技术体系平台 Java SE(Java Standard Edition)****标准版 支持面向桌面级应用（如Windows下的应用程序）的Java平台，提供了完整的Java核心API，此版本以前称为J2SE Java EE(Java Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如:Servlet 、Jsp等，主要针对于Web应用程序开发。版本以前称为J2EE Java ME(Java Micro Edition)小型版 支持Java程序运行在移动终端（手机、PDA）上的平台，对Java API有所精简，并加入了针对移动终端的支持，此版本以前称为J2ME Java Card 支持一些Java小程序（Applets）运行在小内存设备（如智能卡）上的平台 JAVA特点 特点一：面向对象 两个基本概念：类、对象 三大特性：封装、继承、多态 特点二：健壮性 吸收了C/C++语言的优点，但去掉了其影响程序健壮性的部分（如指针、内存的申请与释放等），提供了一个相对安全的内存管理和访问机制 特点三：跨平台性 跨平台性：通过Java语言编写的应用程序在不同的系统平台上都可以运行。Write once , Run Anywhere原理：只要在需要运行 java 应用程序的操作系统上，先安装一个Java虚拟机 (JVM Java Virtual Machine) 即可。由JVM来负责Java Java两种核心机制 Java虚拟机 (Java Virtal Machine) JVM是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器。对于不同的平台，有不同的虚拟机。只有某平台提供了对应的java虚拟机，java程序才可在此平台运行Java虚拟机机制屏蔽了底层运行平台的差别，实现了“一次编译，到处运行” 垃圾收集机制 (Garbage Collection)不再使用的内存空间应回收—— 垃圾回收。在C/C++等语言中，由程序员负责回收无用内存。Java 语言消除了程序员回收无用内存空间的责任：它提供一种系统级线程跟踪存储空间的分配情况。并在JVM空闲时，检查并释放那些可被释放的存储空间。垃圾回收在Java程序运行过程中自动进行，程序员无法精确控制和干预。 什么是JDK，JRE JDK(Java Development Kit Java开发工具包)JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JRE(Java Runtime Environment Java运行环境)包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 HelloWorld javac xx.java 编译 java xx 运行class 注释 单行注释 //注释文字 多行注释 /* 注释文字 */ 文档注释 (java特有)123456/**@author 指定java程序的作者@version 指定源文件的版本*/// 注释内容可以被JDK提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。$ javadoc -d mydoc -author -version HelloWorld.java API文档http://www.oracle.com/technetwork/java/javase/downloads/index.html 总结应用程序 = 算法+数据结构 123456789101112131415161718对第一个java程序进行总结1. java程序编写-编译-运行的过程编写：我们将编写的java代码保存在以&quot;.java&quot;结尾的源文件中编译：使用javac.exe命令编译我们的java源文件。格式：javac 源文件名.java运行：使用java.exe命令解释运行我们的字节码文件。 格式：java 类名2.在一个java源文件中可以声明多个class。但是，只能最多有一个类声明为public的。而且要求声明为public的类的类名必须与源文件名相同。3. 程序的入口是main()方法。格式是固定的。4. 输出语句：System.out.println():先输出数据，然后换行System.out.print():只输出数据5.每一行执行语句都以&quot;;&quot;结束。6.编译的过程：编译以后，会生成一个或多个字节码文件。字节码文件的文件名与java源文件中的类名相同。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"前端周刊【202012-2】","slug":"weeks/2020/202012-2","date":"2020-12-13T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/12/13/weeks/2020/202012-2/","link":"","permalink":"http://yoursite.com/2020/12/13/weeks/2020/202012-2/","excerpt":"","text":"使用webpack4提升180%编译速度18 张图彻底弄懂 HTTPS 的原理！","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202012-1】","slug":"weeks/2020/202012-1","date":"2020-12-06T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/12/06/weeks/2020/202012-1/","link":"","permalink":"http://yoursite.com/2020/12/06/weeks/2020/202012-1/","excerpt":"","text":"前端高效开发必备的 js 库梳理 Typescript代码整洁之道","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"Docker Note","slug":"build/Docker笔记","date":"2020-12-05T10:42:04.000Z","updated":"2022-06-05T14:08:41.961Z","comments":true,"path":"2020/12/05/build/Docker笔记/","link":"","permalink":"http://yoursite.com/2020/12/05/build/Docker%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一. Docker介绍1.1 引言 我本地运行没问题啊。 1环境不一致 哪个哥们又写死循环了，怎么这么卡？ 1在多用户的操作系统下，会互相影响。 淘宝在双11的时候，用户量暴增。 1运维成本过高的问题。 学习一门技术，学习安装成本过高。 1关于安装软件成本过高。 1.2 Docker的由来 一帮年轻人创业，创办了一家公司，2010年的专门做PAAS平台。 到了2013年的时候，像亚马逊、微软、Google都开始做PAAS平台。 2013年，将公司内的核心技术对外开源，核心技术就是Docker。 到了2014年的时候，得到了C轮融资，$4000W 到了2015年的时候，得到了D轮融资，$9500W 全神贯注的维护Docker。 所罗门主要作者之一。 Docker的作者已经离开了维护Docker的团队。 1.3 Docker的思想 集装箱： 会将所有需要的内容放到不同的集装箱中，谁需要这些环境就直接拿到这个集装箱就可以了 标准化： 运输的标准化：Docker有一个码头，所有上传的集装箱都放在了这个码头上，当谁需要某一个环境，就直接指派大海豚去搬运这个集装箱就可以了。 命令的标准化：Docker提供了一系列的命令，帮助我们去获取集装箱等等操作。 提供了REST的API：衍生出了很多图形化界面，Rancher。 隔离性： Docker在运行集装箱内的内容时，会在LInux的内核中，单独的开辟一片空间，这片空间不会影响到其他程序。 注册中心。（超级码头，上面放的就是集装箱） 镜像。（集装箱） 容器。（运行起来的镜像） 二. Docker的基本操作2.1 安装Docker12# 1. 下载关于Docker的依赖环境yum -y install yum-utils device-mapper-persistent-data lvm2 12# 2. 设置一下下载Docker的镜像源yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 123# 3. 安装Dockeryum makecache fastyum -y install docker-ce 1234567# 4. 启动，并设置为开机自动启动，测试# 启动Docker服务systemctl start docker# 设置开机自动启动systemctl enable docker# 测试docker run hello-world 2.2 Docker的中央仓库 Docker官方的中央仓库：这个仓库是镜像最全的，但是下载速度很慢。https://hub.docker.com 国内的镜像网站：网易蜂巢、daoCloud… https://c.163yun.com/hub#/home http://hub.daocloud.io (推荐使用) 在公司内部会采用私服的方式拉取镜像。（添加配置） 12345678# 需要在/etc/docker/daemon.json&#123; \"registry-mirrors\":[\"https://registry.docker-cn.com\"], \"insecure-registries\":[\"ip:port\"]&#125;# 重启两个服务systemctl daemon-reloadsystemctl restart docker 2.3 镜像的操作1234# 拉取镜像到本地docker pull 镜像名称[:tag]# 举个例子docker pull tomcat daocloud.io/library/tomcat:8.5.15-jre8 12# 2. 查看全部本地的镜像docker images 12# 3. 删除本地镜像docker rmi 镜像的标识 1234567# 4. 镜像的导入导出（不规范）# 将本地的镜像导出docker save -o 导出的路径 镜像id# 加载本地的镜像文件docker load -i 镜像文件# 修改镜像名称docker tag 镜像id 新镜像名称:版本 2.4 容器的操作12345678# 1. 运行容器# 简单操作docker run 镜像的标识|镜像名称[:tag]# 常用的参数docker run -d -p 宿主机端口:容器端口 --name 容器名称 镜像的标识|镜像名称[:tag]# -d：代表后台运行容器# -p 宿主机端口:容器端口：为了映射当前Linux端口和容器端口# --name 容器名称：指定容器的名称 1234# 2. 查看正在运行的容器docker ps [-qa]# -a：查看全部的容器，包括没有运行# -p：只查看容器得到标识 123# 3. 查看容器的日志docker logs -f 容器id# -f：可以滚动查看日志的最后几行 12# 4. 进入到容器内部docker exec -it 容器id bash 123456789# 5. 删除容器（删除容器前，需要停止容器）# 停止指定的容器docker stop 容器id# 停止全部容器docker stop $(docker pa -qa)# 删除指定的容器docker rm 容器id# 删除全部容器docker rm $(docker pa -qa) 12# 6. 启动容器docker start 容器id 三. Docker应用3.1 准备SSM工程1# MySQL数据库的连接用户名和密码改变了，修改db.properties 3.2 准备MySQL容器12# 运行MySQL容器docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=root daocloud.io/library/mysql:5.7.4 3.3 准备Tomcat容器12345# 运行Tomcat容器，前面已经搞定，只需要将SSM项目的war包部署到Tomcat容器内部即可# 可以通过命令将宿主机的内容服务到容器内部docker cp 文件名称 容器id:容器内部路径# 举个例子docker cp ssm.war fe:/usr/local/tomcat/webapps 3.4 数据卷 为了部署SSM的工程，需要使用到cp命令将宿主机内的ssm.war文件复制到容器内部。 数据卷：将宿主机的一个目录映射到容器的一个目录中。 可以在宿主机中操作目录中的内容，那么容器内部映射的文件，也会跟着一起改变。 123# 1. 创建数据卷docker volume create 数据卷名称# 创建数据卷之后，默认会存放在一个目录下 /war/lib/docker/volumes/数据卷名称/_data 12# 2. 查看数据卷的详细信息docker volume inspect 数据卷名称 12# 3. 查看全部数据卷docker volume ls 12# 4. 删除数据卷docker volume rm 数据卷名称 12345# 5. 应用数据卷# 当你映射数据卷时，如果数据卷不存在，Docker会自动帮你创建，会将容器内部自带的文件，存储在默认的存放路径中docker run -v 数据卷名称:容器内部的路径 镜像id# 直接指定一个路径作为数据卷的存放位置，这个路径下是空的。docker run -v 路径:容器内部的路径 镜像id 四. Docker自定义镜像 中央仓库上的镜像，也是Docker的用户自己上传过去的。 123456789# 1. 创建一个Dockerfile文件，并且指定自定义镜像信息# Dockerfile文件中常用的内容from：指定当前自定义镜像依赖的环境copy：将相对路径下的内容复制到自定义镜像中workdir：声明镜像的默认工作目录cmd：需要执行的命令（在workdir下执行的，cmd可以写多的，只以最后一个为准）# 举个例子，自定义一个Tomcat镜像，并且将ssm.war部署到Tomcat中from daocloud.io/library/tomcat:8.5.15-jre8copy ssm.war /usr/local/tomcat/webapps 12# 2. 将准备好的Dockerfile和相应的文件拖拽到Linux操作系统中，通过Docker的命令制作镜像docker build -t 镜像名称:[tag] 五. Docker-Compose 之前运行一个镜像，需要添加大量的参数。 可以通过Docker-Compose编写这些参数。 Docker-Compose可以帮助我们批量的管理容器。 只需要通过一个docker-compose.yml文件去维护即可。 5.1 下载Docker-Compose1234567891011121314# 1. 去GitHub官网搜索docker-compose，下载最新版本的Docker-Compose# 2. 将下载好的文件，拖拽到Linux操作系统中# 3. 需要将Docker-Compose文件名称修改一下，给予DockerCompose文件一个可执行的权限mv docker-compose-Linux-x86_64 docker-composechmod 777 docker-compose# 4. 方便后期操作，配置一个环境变量# 将docker-compose文件移动到/usr/local/bin，修改了/etc/profile文件，给/usr/local/bin配置到PATH中mv docker-compose /usr/local/binvi /etc/profile export PATH=$JAVA_HOME:/usr/local/bin:$PATHsource /etc/profile # 5. 测试一下# 在任意目录下输入docker-compose 5.2 Docker-Compose管理MySQL和Tomcat容器 yml文件以key:value方式指定配置信息 多个配置信息以换行+缩进的方式来区分 在docker-compose.yml文件中，不要使用制表符 12345678910111213141516171819202122232425version:'3.1'services: mysql: # 服务的名称 restart: always # 代表只要Docker启动，那么这个容器就跟着一起启动 image: daocloud.io/library/mysql:5.7.4 # 指定镜像路径 container_name: mysql # 指定容器名称 ports: - 3306:3306 # 指定端口号的映射 environment: MYSQL_ROOT_PASSWORD: root # 指定MySQL的ROOT用户登录密码 TZ: Asia/Shanghai # 指定时区 volumes: - /opt/docker_mysql-tomcat/mysql_data:/var/lib/mysql # 映射数据卷 tomcat: restart: always # 代表只要Docker启动，那么这个容器就跟着一起启动 image: daocloud.io/library/tomcat:8.5.15-jre8 # 指定镜像路径 container_name: tomcat # 指定容器名称 ports: - 8080:8080 # 指定端口号的映射 environment: MYSQL_ROOT_PASSWORD: root # 指定MySQL的ROOT用户登录密码 TZ: Asia/Shanghai # 指定时区 volumes: - /opt/docker_mysql-tomcat/tomcat_webapps:/usr/local/tomcat/webapps # 映射数据卷 - /opt/docker_mysql-tomcat/tomcat_logs:/usr/local/tomcat/logs # 映射数据卷 5.3 使用Docker-Compose命令管理容器 在使用docker-compose的命令时，默认会在当前目录下找docker-compose.yml文件 12# 1. 基于docker-compose.yml启动管理的容器docker-compose up -d 12# 2. 关闭并删除容器docker-compose down 12# 3. 开启|关闭|重启已经存在的由docker-compose维护的容器docker-compose start|stop|restart 12# 4. 查看由docker-compose管理的容器docker-compose ps 12# 5. 查看日志docker-compose logs -f 5.4 docker-compose配置Dockerfile使用 使用docker-compose.yml文件以及Dockerfile文件在生成自定义镜像的同时启动当前镜像，并且由docker-compose去管理容器 docker-compose.yml1234567891011121314# yml文件version: '3.1'services: ssm: restart: always build: # 构建自定义镜像 context: ../ # 指定Dockerfile文件所在路径 dockerfile: Dockerfile # 指定Dockerfile文件名称 image: ssm:1.0.1 container_name: ssm ports: 8081:8080 environment: TZ: Asia/Shanghai Dockerfile文件12from daocloud.io/library/tomcat:8.5.15-jre8copy ssm.war /usr/local/tomcat/webapps 12345678# 可以直接启动基于docker-compose.yml以及Dockerfile文件构建的自定义镜像docker-compose up -d# 如果自定义镜像不存在，会帮助我们构建出自定义镜像，如果自定义镜像已经存在，会直接运行这个自定义镜像# 重新构建的话# 重新构建自定义镜像docker-compose build# 运行前，重新构建docker-compose up -d --build 六. Docker DI、CD6.1 引言 项目部署 将项目通过maven进行编译打包 将文件上传到指定的服务器中 将war包放到tomcat的目录中 通过Dockerfile将Tomcat和war包转成一个镜像，由DockerCompose去运行容器 项目更新了 将上述流程再次的从头到尾的执行一次 6.2 CI介绍 CI（ continuous intergration ）持续集成 持续集成：编写代码时，完成了一个功能后，立即提交代码到Git仓库中，将项目重新的构建并且测试 快速发现错误 防止代码偏离主分支 6.3 实现持续集成6.3.1 搭建GItLab服务器 1、创建一个全新的虚拟机，并且至少指定4G的运行内存 2、安装docker以及docker-compose 3、将ssh的默认22端口，修改为60022端口 123vi /etc/ssh/sshd_configPORT 22 -&gt; 60022systemctl restart sshd 4、docker-compose.yml问价去安装GitLab 1234567891011121314151617181920212223version: '3.1'services: gitlab: image: 'twang2218/gitlab-ce-zh:11.1.4' container_name: \"gitlab\" restart: always privileged: true hostname: 'gitlab' environment: TZ: 'Asia/Shanghai' GITLAB_OMNIBUS_CONFIG: external_url 'http://192.168.199.110' gitlab_rails['time_zone'] = 'Asia/Shanghai' gitlab_rails['smtp_enable'] = true gitlab_rails['gitlab_shell_ssh_port'] = 22 ports: - '80:80' - '443:443' - '22:22' volumes: - /opt/docker_gitlab/config:/etc/gitlab - /opt/docker_gitlab/data:/var/opt/gitlab - /opt/docker_gitlab/logs:/var/log/gitlab 6.3.2 搭建GitLab-Runner 查看资料中的gitlab-runner文件即可安装 6.3.3 整合项目入门测试 1、创建maven工程，添加web.xml文件，编写html页面 2、编写gitlab-ci.yml文件 1234567stages: - test test: stage: test script: - echo first test ci # 输入的命令 3、将maven工程推送到Gitlab中 4、可以在Gitlab中查看到gitlab-ci.yml编写的内容 6.3.4 编写gitlab-ci.yml文件 1、编写gitlab-ci.yml测试命令使用 12345678stages: - test test: stage: test script: - echo first test ci # 输入的命令 - /usr/local/maven/apache-maven-3.6.3/bin/mvn package 2、编写关于Dockerfile以及docker-compose文件的具体内容 123# 1. DockerfileFROM daocloud.io/library/tomcat:8.5.15-jre8COPY testci.war /usr/local/tomcat/webapps 123456789# 2. docker-compose.ymlversion: \"3.1\"services: testci: build: docker restart: always container_name: testci ports: - 8080:8080","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"}]},{"title":"前端周刊【202011-4】","slug":"weeks/2020/202011-4","date":"2020-11-28T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/11/28/weeks/2020/202011-4/","link":"","permalink":"http://yoursite.com/2020/11/28/weeks/2020/202011-4/","excerpt":"","text":"10 个 GitHub 上超火和超好看的管理后台模版 10 个 GitHub 上超火的 CSS 奇技淫巧项目","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202011-3】","slug":"weeks/2020/202011-3","date":"2020-11-20T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/11/20/weeks/2020/202011-3/","link":"","permalink":"http://yoursite.com/2020/11/20/weeks/2020/202011-3/","excerpt":"","text":"前端性能优化 24 条建议（2020） 手把手教你搭建 Vue 服务端渲染项目","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"开源轻社区收藏","slug":"others/20201116开源轻社区收藏","date":"2020-11-16T01:00:00.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/11/16/others/20201116开源轻社区收藏/","link":"","permalink":"http://yoursite.com/2020/11/16/others/20201116%E5%BC%80%E6%BA%90%E8%BD%BB%E7%A4%BE%E5%8C%BA%E6%94%B6%E8%97%8F/","excerpt":"","text":"Flarum 演示：https://forum.cloudreve.org/ 官网：https://flarum.org.cn/ Tipask 演示：https://wenda.tipask.com/ 官网：https://www.tipask.com/ Xiuno BBS 演示和官网：https://bbs.xiuno.com/ 开源地址：https://gitee.com/xiuno/xiunobbs PHPWIND http://bbs.phpwind.net.cn/ DISCUZ https://www.discuz.net","categories":[],"tags":[{"name":"bbs","slug":"bbs","permalink":"http://yoursite.com/tags/bbs/"},{"name":"forum","slug":"forum","permalink":"http://yoursite.com/tags/forum/"}]},{"title":"前端周刊【202011-2】","slug":"weeks/2020/202011-2","date":"2020-11-15T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/11/15/weeks/2020/202011-2/","link":"","permalink":"http://yoursite.com/2020/11/15/weeks/2020/202011-2/","excerpt":"","text":"CSR、SSR、Prerender 原理全解密 微前端官网 前端赋能业务：Node实现自动化部署平台 扩展 VUE-SSR SPA 缺点 首屏渲染速度慢 SEO不友好 浏览器性能问题 SSR缺点 开发条件受限 构建部署要求多，NODEJS 服务端负载变大 实现VUE SSR过程 创建工程 vue create ssr 安装依赖 [ 渲染器 vue-server-render ] [ 服务器express ]","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"GO Note","slug":"others/20201112GO语言笔记","date":"2020-11-12T10:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/11/12/others/20201112GO语言笔记/","link":"","permalink":"http://yoursite.com/2020/11/12/others/20201112GO%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/","excerpt":"","text":"安装包go1.15.4.darwin-amd64.pkg https://golang.org/dl/ goPath goModule 跨平台编译GOOS 代表要编译的目标是操作系统 GOARCH代表要维护的目标处理器架构","categories":[],"tags":[{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"}]},{"title":"前端周刊【202011-1】","slug":"weeks/2020/202011-1","date":"2020-11-07T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/11/07/weeks/2020/202011-1/","link":"","permalink":"http://yoursite.com/2020/11/07/weeks/2020/202011-1/","excerpt":"","text":"前端菜鸡让接口提速50%的实践与原理 大厂的前端代码规范 图解九种常见的设计模式","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202009-4】","slug":"weeks/2020/202009-4","date":"2020-09-27T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/09/27/weeks/2020/202009-4/","link":"","permalink":"http://yoursite.com/2020/09/27/weeks/2020/202009-4/","excerpt":"","text":"一位架构师的感悟：过度忙碌使你落后 32个手写JS，巩固你的JS基础","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202009-3】","slug":"weeks/2020/202009-3","date":"2020-09-20T01:00:00.000Z","updated":"2022-06-05T14:08:41.968Z","comments":true,"path":"2020/09/20/weeks/2020/202009-3/","link":"","permalink":"http://yoursite.com/2020/09/20/weeks/2020/202009-3/","excerpt":"","text":"JavaScript错误处理完全指南 Moment.js 的 2kB 轻量化方案，拥有同样强大的 API 领域驱动设计在前端中的应用","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202009-2】","slug":"weeks/2020/202009-2","date":"2020-09-13T01:00:00.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/09/13/weeks/2020/202009-2/","link":"","permalink":"http://yoursite.com/2020/09/13/weeks/2020/202009-2/","excerpt":"","text":"技术专题第四期 | 我们的微前端是如何炼成的 网页布局都有哪种？一般都用什么布局？","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202009-1】","slug":"weeks/2020/202009-1","date":"2020-09-06T01:00:00.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/09/06/weeks/2020/202009-1/","link":"","permalink":"http://yoursite.com/2020/09/06/weeks/2020/202009-1/","excerpt":"","text":"基于HTTP网络层的前端性能优化1234567891011121314151617181920212223242526272829/* * 1.利用缓存 * + 对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？） * + 对于不经常更新的接口数据采用本地存储做数据缓存（扩展：cookie / localStorage / vuex|redux 区别？） * 2.DNS优化 * + 分服务器部署，增加HTTP并发性（导致DNS解析变慢） * + DNS Prefetch * 3.TCP的三次握手和四次挥手 * + Connection:keep-alive * 4.数据传输 * + 减少数据传输的大小 * + 内容或者数据压缩（webpack等） * + 服务器端一定要开启GZIP压缩（一般能压缩60%左右） * + 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少） * + 减少HTTP请求的次数 * + 资源文件合并处理 * + 字体图标 * + 雪碧图 CSS-Sprit * + 图片的BASE64 * + ...... * 5.CDN服务器“地域分布式” * 6.采用HTTP2.0 * ============== * 网络优化是前端性能优化的中的重点内容，因为大部分的消耗都发生在网络层，尤其是第一次页面加载，如何减少等待时间很重要“减少白屏的效果和时间” * + LOADDING 人性化体验 * + 骨架屏：客户端骨屏 + 服务器骨架屏 * + 图片延迟加载 * + .... */ 48张小图带你领略flex布局之美","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"Webpack 编译优化之速度篇","slug":"frame/vue/Webpack 编译优化之速度篇","date":"2020-09-03T10:42:04.000Z","updated":"2022-06-05T14:08:41.965Z","comments":true,"path":"2020/09/03/frame/vue/Webpack 编译优化之速度篇/","link":"","permalink":"http://yoursite.com/2020/09/03/frame/vue/Webpack%20%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%E4%B9%8B%E9%80%9F%E5%BA%A6%E7%AF%87/","excerpt":"","text":"一、减小文件搜索范围 使 Webpack 更快寻找到目标，将对打包速度产生很是积极的影响 1、配置 resolve.modules12345678910111213141516171819202122function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; resolve: &#123; extensions: ['.js', '.vue', '.json'], modules: [ resolve('src'), resolve('node_modules') ], alias: &#123; 'vue$': 'vue/dist/vue.common.js', 'src': resolve('src'), 'assets': resolve('src/assets'), 'components': resolve('src/components'), // ... 'store': resolve('src/store') &#125; &#125;, ...&#125; 2、设置 test &amp; include &amp; exclude 合理的设置 include &amp; exclude，将会极大地提升 Webpack 打包优化速度 test：必须满足的条件（正则表达式，不要加引号，匹配要处理的文件） exclude：不能满足的条件（排除不处理的目录） include：导入的文件将由加载程序转换的路径或文件数组（把要处理的目录包括进来） loader：一串“！”分隔的装载机（2.0版本以上，”-loader”不可以省略） loaders：作为字符串的装载器阵列123456789101112131415161718192021222324252627282930313233module: &#123; preLoaders: [ &#123; test: /\\.js$/, loader: 'eslint', include: [resolve('src')], exclude: /node_modules/ &#125;, &#123; test: /\\.svg$/, loader: 'svgo?' + JSON.stringify(svgoConfig)， include: [resolve('src/assets/icons')], exclude: /node_modules/ &#125; ], loaders: [ &#123; test: /\\.vue$/, loader: 'vue-loader', include: [resolve('src')], exclude: /node_modules\\/(?!(autotrack|dom-utils))|vendor\\.dll\\.js/ &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', exclude: /assets\\/icons/, query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125; ]&#125; 二、增强代码压缩工具1、合理使用uglifyJS Webpack 默认提供的 UglifyJS 插件，由于采用单线程压缩，速度颇慢 ；推荐采用 webpack-parallel-uglify-plugin 插件，她可以并行运行 UglifyJS 插件，更加充分而合理的使用 CPU 资源，这可以大大减少的构建时间；当然，该插件应用于生产环境而非开发环境 开发环境123456new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125;, sourceMap: true&#125;) 生产环境123456789101112var ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');new ParallelUglifyPlugin(&#123; cacheDir: '.cache/', uglifyJS:&#123; output: &#123; comments: false &#125;, compress: &#123; warnings: false &#125; &#125;&#125;) 2、设置 babel 的 cacheDirectory 为true babel-loader is slow! 所以不仅要使用exclude、include，尽可能准确的指定要转化内容的范畴，而且要充分利用缓存，进一步提升性能。babel-loader 提供了 cacheDirectory特定选项（默认 false）：设置时，给定的目录将用于缓存加载器的结果。 123456789rules: [ &#123; test: /\\.js$/, loader: 'babel-loader?cacheDirectory=true', exclude: /node_modules/, include: [resolve('src'), resolve('test')] &#125;, ... ...] 3、设置 noParse 如果你确定一个模块中，没有其它新的依赖，就可以配置这项， Webpack 将不再扫描这个文件中的依赖，这对于比较大型类库，将能促进性能表现 1234567module: &#123; noParse: /node_modules\\/(element-ui\\.js)/, rules: [ &#123; ... &#125;&#125; 4、拷贝静态文件 引入 DllPlugin 和 DllReferencePlugin 来提前构建一些第三方库，来优化 Webpack 打包。而在生产环境时，就需要将提前构建好的包，同步到 dist 中；这里拷贝静态文件，你可以使用 copy-webpack-plugin 插件：把指定文件夹下的文件复制到指定的目录 12345678910111213var CopyWebpackPlugin = require('copy-webpack-plugin')plugins: [ ... // copy custom static assets new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ])] 三、正确使用 SourceMap source-map 的基本原理是，在编译处理的过程中，在生成产物代码的同时生成产物代码中被转换的部分与源代码中相应部分的映射关系表。有了这样一张完整的映射表，我们就可以通过 Chrome 控制台中的”Enable Javascript source map”来实现调试时的显示与定位源代码功能。 “eval” “cheap” “module” “inline” “hidden” “nosource” “source-map” 在开发环境中通常我们关注的是构建速度快，质量高，以便于提升开发效率，而不关注生成文件的大小和访问方式。 如果对项目代码了如指掌，查看产物代码也可以无障碍地了解对应源代码的部分，那就可以关闭 devtool 或使用 eval 来获得最快构建速度。 反之如果在调试时，需要通过 source map 来快速定位到源代码，则优先考虑使用 eval-cheap-modulesource-map，它的质量与初次/再次构建速度都属于次优级，以牺牲定位到列的功能为代价换取更快的构建速度通常也是值得的。 在其他情况下，根据对质量要求更高或是对速度要求更高的不同情况，可以分别考虑使用 eval-source-map 或 eval-cheap-source-map。 在生产环境中通常我们更关注是否需要提供线上 source map , 生成的文件大小和访问方式是否会对页面性能造成影响等，其次才是质量和构建速度。 四、Tree-Shaking我们的JS文件，将其中用不到的代码”摇”掉 1、禁止Babel将ES6编译到CommonJSBabel在很多应用中已经必不可少。不幸的是，它会让tree shaking变得困难。如果你使用babel-preset-env，它会将你的ES6编译到可兼容性更好的CommonJS。 问题在于对于CommonJS，tree shaking非常困难，而且webpack不知道哪些需要消除掉。不过呢，好在有一个很简单的解法：配置babel-preset-env，让其保持ES6不动，不要翻译。具体的配置放在你配置Babel的地方(.babelrc或则package.json)： 123456789# .babelrc\"presets\": [ [ \"es2015\", &#123; \"modules\": false, &#125; ], \"stage-2\" ], 2、谨记副作用(Side Effect)应用中使用模块是否有副作用，若需要配置package.json,但谨慎使用。在操作全局函数的时候，会导致其他使用此函数的地方带来副作用。 通过配置&quot;sideEffects&quot;:false表示模块是安全的，没有副作用的。 1&quot;sideEffects&quot;: false 3、按需导入1import &#123; SwipeCell, Toast &#125; from 'vant' 五、抽出第三方库由于第三方库太多,容易导致vendor.js过大。可优化使用CDN或者外链 static 的JS文件，在index.html进行引入，不参与webpack构建。 vendor.js &gt;5m index.html gzip on .gzip 5m 1m nginx gzip on 123456//build/webpack.base.conf.jsexternals: &#123; 'vue': 'Vue', 'vue-router': 'VueRouter', 'element-ui': 'ELEMENT', &#125;, 六、图片引入要点以下方式容易导致vendor.js过大，可优化使用高性能图片服务器进行图片引入，外网图片可使用CDN图床等方式来引入。或放入static中 不会被打包 1234567&lt;img src=\"../assets/images/logo.png\"/&gt;&lt;img :src=\"photosrc\"/&gt;import photo from 'xx.png'data:&#123;photosrc:photo&#125;&lt;img src=\"static/logo.png\"/&gt; 七、升级webpack4 vue-cli...待完善 webpack4对打包构建提速有明显的效果 目前受限于浏览器兼容的影响 未升级w4 有兴趣可百度研究","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"前端进阶知识","slug":"book/video/202008前端进阶基础","date":"2020-08-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.960Z","comments":true,"path":"2020/08/30/book/video/202008前端进阶基础/","link":"","permalink":"http://yoursite.com/2020/08/30/book/video/202008%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、你不知道的HTML标签meta 标签：自动刷新/跳转12&lt;meta http-equiv=\"Refresh\" content=\"5; URL=page2.html\"&gt;&lt;meta http-equiv=\"Refresh\" content=\"60\"&gt; title 标签与 Hack 手段：消息提醒12345678910111213let msgNum = 1 // 消息条数let cnt = 0 // 计数器const inerval = setInterval(() =&gt; &#123; cnt = (cnt + 1) % 2 if(msgNum===0) &#123; // 通过DOM修改title document.title += `聊天页面` clearInterval(interval) return &#125; const prefix = cnt % 2 ? `新消息($&#123;msgNum&#125;)` : '' document.title = `$&#123;prefix&#125;聊天页面`&#125;, 1000) 性能优化：script 标签：调整加载顺序提升渲染速度 async 属性。立即请求文件，但不阻塞渲染引擎，而是文件加载完毕后阻塞渲染引擎并立即执行文件内容。 defer 属性。立即请求文件，但不阻塞渲染引擎，等到解析完 HTML 之后再执行文件内容。 HTML5 标准 type 属性，对应值为“module”。让浏览器按照 ECMA Script 6 标准将文件当作模块进行解析，默认阻塞效果同 defer，也可以配合 async 在请求完成后立即执行。 性能优化：link 标签：通过预处理提升渲染速度 dns-prefetch。当 link 标签的 rel 属性值为“dns-prefetch”时，浏览器会对某个域名预先进行 DNS 解析并缓存。这样，当浏览器在请求同域名资源的时候，能省去从域名查询 IP 的过程，从而减少时间损耗。下图是淘宝网设置的 DNS 预解析。 preconnect。让浏览器在一个 HTTP 请求正式发给服务器前预先执行一些操作，这包括 DNS 解析、TLS 协商、TCP 握手，通过消除往返延迟来为用户节省时间。 prefetch/preload。两个值都是让浏览器预先下载并缓存某个资源，但不同的是，prefetch 可能会在浏览器忙时被忽略，而 preload 则是一定会被预先下载。 prerender。浏览器不仅会加载资源，还会解析执行页面，进行预渲染。 搜索优化：meta 标签：提取关键信息1&lt;meta content=\"拉勾,拉勾网,拉勾招聘,拉钩, 拉钩网 ,互联网招聘,拉勾互联网招聘, 移动互联网招聘, 垂直互联网招聘, 微信招聘, 微博招聘, 拉勾官网, 拉勾百科,跳槽, 高薪职位, 互联网圈子, IT招聘, 职场招聘, 猎头招聘,O2O招聘, LBS招聘, 社交招聘, 校园招聘, 校招,社会招聘,社招\" name=\"keywords\"&gt; 搜索优化：link 标签：减少重复有时候为了用户访问方便或者出于历史原因，对于同一个页面会有多个网址，又或者存在某些重定向页面，比如：https://lagou.com/a.html https://lagou.com/detail?id=%22abcd%22 1&lt;link href=\"https://lagou.com/a.html\" rel=\"canonical\"&gt; 二、如何高效操作 DOM 元素？在循环外操作元素123456789101112const times = 10000;console.time('switch')for (let i = 0; i &lt; times; i++) &#123; document.body === 1 ? console.log(1) : void 0;&#125;console.timeEnd('switch') // 1.873046875msvar body = JSON.stringify(document.body)console.time('batch')for (let i = 0; i &lt; times; i++) &#123; body === 1 ? console.log(1) : void 0;&#125;console.timeEnd('batch') // 0.846923828125ms 批量操作元素12345678910111213141516171819202122232425262728const times = 10000;console.time('createElement')for (let i = 0; i &lt; times; i++) &#123; const div = document.createElement('div') document.body.appendChild(div)&#125;console.timeEnd('createElement')// 54.964111328125msconsole.time('innerHTML')let html=''for (let i = 0; i &lt; times; i++) &#123; html+='&lt;div&gt;&lt;/div&gt;'&#125;document.body.innerHTML += html // 31.919921875msconsole.timeEnd('innerHTML')const times = 20000;let html = ''for (let i = 0; i &lt; times; i++) &#123; html = `&lt;div&gt;$&#123;i&#125;$&#123;html&#125;&lt;/div&gt;`&#125;document.body.innerHTML += htmlconst div = document.querySelector('div')for (let i = 0; i &lt; times; i++) &#123; div.style.fontSize = (i % 12) + 12 + 'px' div.style.color = i % 2 ? 'red' : 'green' div.style.margin = (i % 12) + 12 + 'px'&#125; 缓存元素集合123456789for (let i = 0; i &lt; document.querySelectorAll('div').length; i++) &#123; document.querySelectorAll(`div`)[i].innerText = i&#125;//如果能够将元素集合赋值给 JavaScript 变量，每次通过变量去修改元素，那么性能将会得到不小的提升。const divs = document.querySelectorAll('div')for (let i = 0; i &lt; divs.length; i++) &#123; divs[i].innerText = i&#125; 总结 尽量不要使用复杂的匹配规则和复杂的样式，从而减少渲染引擎计算样式规则生成 CSSOM 树的时间； 尽量减少重排和重绘影响的区域； 使用 CSS3 特性来实现动画效果。 三、3 个使用场景助你用好 DOM 事件防抖有一个搜索输入框，为了提升用户体验，希望在用户输入后可以立即展现搜索结果，而不是每次输入完后还要点击搜索按钮。最基本的实现方式应该很容易想到，那就是绑定 input 元素的键盘事件，然后在监听函数中发送 AJAX 请求。 l la lag lago 前面进行了 4 次无效查询 123456789101112131415161718192021222324252627282930313233343536// 代码2const debounce = (func, wait = 0) =&gt; &#123; let timeout = null let args function debounced(...arg) &#123; args = arg if(timeout) &#123; clearTimeout(timeout) timeout = null &#125; // 以Promise的形式返回函数执行结果 return new Promise((res, rej) =&gt; &#123; timeout = setTimeout(async () =&gt; &#123; try &#123; const result = await func.apply(this, args) res(result) &#125; catch(e) &#123; rej(e) &#125; &#125;, wait) &#125;) &#125; // 允许取消 function cancel() &#123; clearTimeout(timeout) timeout = null &#125; // 允许立即执行 function flush() &#123; cancel() return func.apply(this, args) &#125; debounced.cancel = cancel debounced.flush = flush return debounced&#125; 节流实现节流函数的过程和防抖函数有些类似，只是对于节流函数而言，有两种执行方式，在调用函数时执行最先一次调用还是最近一次调用，所以需要设置时间戳加以判断。 节流与防抖都是通过延迟执行，减少调用次数，来优化频繁调用函数时的性能。不同的是，对于一段时间内的频繁调用，防抖是延迟执行后一次调用，节流是延迟定时多次调用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const throttle = (func, wait = 0, execFirstCall) =&gt; &#123; let timeout = null let args let firstCallTimestamp function throttled(...arg) &#123; if (!firstCallTimestamp) firstCallTimestamp = new Date().getTime() if (!execFirstCall || !args) &#123; console.log('set args:', arg) args = arg &#125; if (timeout) &#123; clearTimeout(timeout) timeout = null &#125; // 以Promise的形式返回函数执行结果 return new Promise(async(res, rej) =&gt; &#123; if (new Date().getTime() - firstCallTimestamp &gt;= wait) &#123; try &#123; const result = await func.apply(this, args) res(result) &#125; catch (e) &#123; rej(e) &#125; finally &#123; cancel() &#125; &#125; else &#123; timeout = setTimeout(async () =&gt; &#123; try &#123; const result = await func.apply(this, args) res(result) &#125; catch (e) &#123; rej(e) &#125; finally &#123; cancel() &#125; &#125;, firstCallTimestamp + wait - new Date().getTime()) &#125; &#125;) &#125; // 允许取消 function cancel() &#123; clearTimeout(timeout) args = null timeout = null firstCallTimestamp = null &#125; // 允许立即执行 function flush() &#123; cancel() return func.apply(this, args) &#125; throttled.cancel = cancel throttled.flush = flush return throttled&#125; 代理事件代理的实现原理就是利用上述 DOM 事件的触发流程来对一类事件进行统一处理。比如对于上面的列表，我们在 ul 元素上绑定事件统一处理，通过得到的事件对象来获取参数，调用对应的函数。 1234567891011121314const ul = document.querySelector('.list')ul.addEventListener('click', e =&gt; &#123; const t = e.target || e.srcElement if (t.classList.contains('item')) &#123; getInfo(t.id) &#125; else &#123; id = t.parentElement.id if (t.classList.contains('edit')) &#123; edit(id) &#125; else if (t.classList.contains('delete')) &#123; del(id) &#125; &#125;&#125;) 四、掌握 CSS 精髓：布局单列布局单列布局是最常用的一种布局，它的实现效果就是将一个元素作为布局容器，通常设置一个较小的（最大）宽度来保证不同像素宽度屏幕下显示一致。 2 列布局2 列布局使用频率也非常的高，实现效果就是将页面分割成左右宽度不等的两列，宽度较小的列设置为固定宽度，剩余宽度由另一列撑满。为了描述方便，我们暂且称宽度较小的列父元素为次要布局容器，宽度较大的列父元素为主要布局容器。 3 列布局3 列布局按照左中右的顺序进行排列，通常中间列最宽，左右两列次之。 五、如何管理你的 CSS 代码？1234567base/，模板代码，比如默认标签样式重置；components/，组件相关样式；layout/，布局相关，包括头部、尾部、导航栏、侧边栏等；pages/，页面相关样式；themes/，主题样式，即使有的项目没有多个主题，也可以进行预留；abstracts/，其他样式文件生成的依赖函数及 mixin，不能直接生成 css 样式；vendors/，第三方样式文件。 六、浏览器如何渲染页面？ 字节流解码 输入流预处理 令牌化 构建 DOM 树 构建渲染树 布局 绘制 七、JavaScript 的数据类型，你知多少？JavaScript 的数据类型可以分为 7 种：空（Null）、未定义（Undefined）、数字（Number）、字符串（String）、布尔值（Boolean）、符号（Symbol）、对象（Object）。 UndefinedUndefined 是一个很特殊的数据类型，它只有一个值，也就是 undefined。可以通过下面几种方式来得到 undefined： 1if(typeof key === 'undefined')&#123;&#125; // 判断正解 NullNull 数据类型和 Undefined 类似，只有唯一的一个值 null，都可以表示空值，甚至我们通过 “==” 来比较它们是否相等的时候得到的结果都是 true，但 null 是 JavaScript 保留关键字，而 undefined 只是一个常量。 Number两个重要值Number 是数值类型，有 2 个特殊数值得注意一下，即 NaN 和 Infinity。 NaN（Not a Number）通常在计算失败的时候会得到该值。要判断一个变量是否为 NaN，则可以通过 Number.isNaN 函数进行判断。 Infinity 是无穷大，加上负号 “-” 会变成无穷小，在某些场景下比较有用，比如通过数值来表示权重或者优先级，Infinity 可以表示最高优先级或最大权重。 八、一等公民this 关键字this 是 JavaScript 的一个关键字，一般指向调用它的对象。 这句话其实有两层意思，首先 this 指向的应该是一个对象，更具体地说是函数执行的“上下文对象”。其次这个对象指向的是“调用它”的对象，如果调用它的不是对象或对象不存在，则会指向全局对象（严格模式下为 undefined）。 箭头函数和普通函数相比，有以下几个区别，在开发中应特别注意： 不绑定 arguments 对象，也就是说在箭头函数内访问 arguments 对象会报错 不能用作构造器，也就是说不能通过关键字 new 来创建实例； 默认不会创建 prototype 原型属性； 不能用作 Generator() 函数，不能使用 yeild 关键字。 原型原型是 JavaScript 的重要特性之一，可以让对象从其他对象继承功能特性，所以 JavaScript 也被称为“基于原型的语言”。 什么是原型和原型链？简单地理解，原型就是对象的属性，包括被称为隐式原型的 proto 属性和被称为显式原型的 prototype 属性。 隐式原型通常在创建实例的时候就会自动指向构造函数的显式原型。例如，在下面的示例代码中，当创建对象 a 时，a 的隐式原型会指向构造函数 Object() 的显式原型。 new 操作符实现了什么？ 创建一个临时的空对象，为了表述方便，我们命名为 fn，让对象 fn 的隐式原型指向函数 F 的显式原型 执行函数 F()，将 this 指向对象 fn，并传入参数 args，得到执行结果 result 判断上一步的执行结果 result，如果 result 为非空对象，则返回 result，否则返回 fn。 作用域作用域是指赋值、取值操作的执行范围，通过作用域机制可以有效地防止变量、函数的重复定义，以及控制它们的可访问性。 命名提升对于使用 var 关键字声明的变量以及创建命名函数的时候，JavaScript 在解释执行的时候都会将其声明内容提升到作用域顶部，这种机制称为“命名提升”。 闭包在函数内部访问外部函数作用域时就会产生闭包。闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。这种关联不只是跨作用域引用，也可以实现数据与函数的隔离。 12345678910111213// 通过闭包来实现单例模式var SingleStudent = (function () &#123; function Student() &#123;&#125; var _student; return function () &#123; if (_student) return _student; _student = new Student() return _student; &#125;&#125;())var s = new SingleStudent()var s2 = new SingleStudent()s === s2 // true 九、执行顺序异步和同步同步:程序在同步调用函数的时候，会立即执行操作并等待得到返回结果后再继续运行，也就是说同步执行是阻塞的。 异步:而异步会将操作和结果在时间上分隔开来，在当下执行操作，在未来某个时刻返回结果，在这个等待返回结果的过程中，程序将继续执行后面的代码。也就是说异步执行是非阻塞的。 异步与回调 异步操作都采用回调函数的形式 异步原理 事件循环 对于大多数语言而言，实现异步会通过启动额外的进程、线程或协程来实现，而我们在前面已经提到过，JavaScript 是单线程的。 事件队列 数组 eventLoop 表示事件队列（也有称作“任务队列”），用来存放需要执行的任务事件（可以理解为回调函数），对象 event 变量表示当前需要执行的任务事件。 处理异步 异步串行 将异步转化为串行执行是非常常见的操作，先通过一个简单的例子来回顾基本实现方式。 异步并行 （1）Promise.all([promise1 …… promiseN]) 调用函数 Promise.all 会返回一个新的 Promise 实例，该实例在参数内所有的 promise 都完成 (resolved) 时回调完成 (resolve)；如果参数中 promise 有一个失败（rejected），那么此实例返回第一个失败 promise 的结果。 当执行的异步函数具有强一致性时可以使用它，比如要更新一个较大的表单数据，会发送多个请求分别更新不同的数据，如果一个请求更新失败则放弃本次提交。 （2）Promise.allSettled([promise1……promiseN]) 调用函数 Promise.allsellted 会返回一个新的 Promise 实例，该实例会在所有给定的 promise 已经执行完成时返回一个对象数组，每个对象表示对应的 promise 结果。 这个函数适用于需要并发执行多个异步函数，这些异步函数的执行结果相互独立。比如同时发送多个 AJAX 请求来分别更新多条数据。 （3）Promise.race([promise1……promiseN]) 调用函数 Promise.race 会返回一个新的 promise 实例，一旦参数中的某个 promise 执行完成，新的 promise 实例就会返回对应 promise 的执行结果。 这个函数会让多个并发函数产生“竞争”，从而挑选出最先执行完成的。比如尝试从多个网址加载图片资源。 异常处理 Promise 有一个隐藏的“坑”，那就是内部的异常不能在外部通过 try/catch 所捕获，当内部发生异常时，会自动进入失败状态（rejected）。 十、区分浏览器中进程与线程 进程是操作系统进行资源分配和调度的基本单位 线程是操作系统进行运算的最小单位 一个程序至少有一个进程，一个进程至少有一个线程 线程需要由进程来启动和管理 十一、TCP 是怎样建立/断开连接的三次握手在建立 TCP 连接之前，客户端和服务器之间会发送三次数据，以确认双方的接收和发送能力，这个过程称为三次握手（Three-way Handshake）。 三次握手的具体过程如下所示。 第一次握手：刚开始客户端处于 CLOSED 的状态，服务端处于 LISTEN 状态。客户端给服务端发送一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。 第二次握手：当服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。 第三次握手：当客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也同样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方成功建立起了连接。 四次挥手当客户端和服务端断开连接时要发送四次数据，这个过程称之为四次挥手。 四次挥手的具体过程如下所示。 第一次挥手：在挥手之前服务端与客户端都处于 ESTABLISHED 状态。客户端发送一个 FIN 报文，用来关闭客户端到服务器的数据传输，此时客户端处于 FIN_WAIT_1 状态。 第二次挥手：当服务端收到 FIN 之后，会发送 ACK 报文，并且把客户端的序列号值加 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。 第三次挥手：如果服务端同意关闭连接，则会向客户端发送一个 FIN 报文，并且指定一个序列号，此时服务端处于 LAST_ACK 的状态。 第四次挥手：当客户端收到 ACK 之后，处于 FIN_WAIT_2 状态。待收到 FIN 报文时发送一个 ACK 报文作为应答，并且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。等待一段时间后会进入 CLOSED 状态，当服务端收到 ACK 报文之后，也会变为 CLOSED 状态，此时连接正式关闭。 十二、multirepo &amp;&amp; monorepomultirepomultirepo 就是将项目中的模块拆分出来，放在不同的仓库中进行独立管理。例如，用于 Node.js 的 Web 框架 Koa，它依赖的模块 koa-convert 和 koa-compose 分别拆分成了两个仓库进行管理。 这种方式的好处是保证仓库的独立性，方便不同团队维护对应的仓库代码，可以根据团队情况选择擅长的工具、工作流等。 但这种方式也会存在一些问题，具体如下。 开发调试及版本更新效率低下。比如在仓库 A 用到的仓库 B 中发现了一个 bug，就必须到仓库 B 里修复它、打包、发版本，然后再回到仓库 A 继续工作。在不同的仓库间，你不仅需要处理不同的代码、工具，甚至是不同的工作流程；还有，你只能去问维护这个仓库的人，能不能为你做出改变，然后等着他们去解决。 团队技术选型分散。不同的库实现风格可能存在较大差异（比如有的库依赖 Vue，有的依赖 React），还有可能会采用不同的测试库及校验规则，维护起来比较困难。 而 monorepo 方式恰好就能解决这些问题。 monorepomonorepo 就是将所有相关的模块放在同一个项目仓库中。这种方式在管理上会更加方便，项目所有代码可以使用统一的规范及构建、测试、发布流程。 很多著名的开源项目都采取了这种管理方式，比如开源项目 babel，它依赖的模块都放在了 packages 目录下。 十三、前端性能优化思路 以从两个方向入手：加载性能优化和渲染性能优化。 虽然不同方向的优化手段不同，但大体上都遵循两个思路：做减法和做除法。做减法是直接减少耗时操作或资源体积，做除法是在耗时操作和资源体积无法减少的情况下，对其进行拆分处理或者对不可拆分的内容进行顺序调换。 下面来进行举例分析。加载性能的优化手段中，做减法的有： 采用 gzip 压缩，典型的减少资源的传输体积； 使用缓存，强制缓存可以减少浏览器请求次数，而协商缓存可以减少传输体积； 使用雪碧图，减少浏览器请求次数。 做除法的有： HTTP2 多路复用，把多个请求拆分成二进制帧，并发传输； 懒加载，将 Web 应用拆分成不同的模块或文件，按需加载； 把 script 标签放到 body 底部，通过调整顺序来控制渲染时间。 而在渲染性能优化的手段中，做减法的有： 避免重排与重绘，减少渲染引擎的绘制； 防抖操作，减少函数调用或请求次数； 减少 DOM 操作，减少渲染引擎和脚本引擎的切换，同时也减少渲染引擎绘制。 做除法的有： 骨架屏，将页面内容进行拆分，调整不同部分的显示顺序； 使用 Web Worker，将一些长任务拆分出来，放到 Web Worker 中执行； React Fiber，将同步视图的任务进行拆分，可调换顺序，可暂停。 十四、安全跨站脚本（Cross Site Scripting，XSS）XSS 攻击示例一般我们把 XSS 分为反射型、存储型、DOM 型 3 种类型。反射型 XSS 也叫非持久型 XSS，是指攻击者将恶意代码拼写在 URL 中提交给服务端，服务端返回的内容，也带上了这段 XSS 代码，最后导致浏览器执行了这段恶意代码。 XSS 防御手段 参数校验。对于 HTTP 请求的 URL 参数和请求体 payload 的数据进行校验，比如我们接收的数据是用户年龄，那么在后端，需要判断一下数据是否是 Number，对于不符合校验规则的数据及时抛出错误。 字符转义。对于一些特殊符号，比如“&lt;”“&gt;”“&amp;”“””“’”“/”，我们需要对其进行转义，后端接收这些代码时候的转义存储，前端在显示的时候，再把它们转成原来的字符串进行显示。 跨站请求伪造（Cross-site Request Forgery，CSRF/XSRF）CSRF 攻击就是在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在并未授权的情况下执行在权限保护之下的操作。和 XSS 攻击方式相比，CSRF 并不需要直接获取用户信息，只需要“借用”用户的登录信息相关操作即可，隐蔽性更强。 CSRF 防御手段通过前面的例子可以看到 CSRF 大多来自第三方网站，所以浏览器会在请求头带上 Refer 字段，服务器可以判断 Refer 来拒绝不受信任的源发出的请求。 由于攻击者在大多数情况下利用 cookie 来通过验证，所以可以在请求地址中添加其他头部字段，比如 token，服务端只有接收到正确的 token 后才响应正确的内容。 攻击者是在不知情的情况下，自动发起恶意的请求，那么可以通过用户确认来防御攻击，比如加入图形或短信验证码让用户输入，确认该操作是用户本人发起的。但是加入验证码会影响用户的体验，所以验证码不能频繁使用。 点击劫持（C lickJacking ）攻击者创建一个网页利用 iframe 包含目标网站，然后通过设置透明度等方式隐藏目标网站，使用户无法察觉目标网站的存在，并且把它遮罩在网页上。在网页中诱导用户点击特定的按钮，而这个按钮的位置和目标网站的某个按钮重合，当用户点击网页上的按钮时，实际上是点击目标网站的按钮。 ClickJacking 防御通过例子可以看到 ClickJacking 的攻击原理主要是利用了 iframe，所以可以通过设置响应头部字段 X-Frame-Options HTTP 来告诉浏览器允许哪些域名引用当前页面。X-Frame-Options 的值有 3 个，具体如下。 DENY：表示页面不允许在 iframe 中引用，即便是在相同域名的页面中嵌套也不允许，GitHub 首页响应头部使用的就是这个值。 SAMEORIGIN：表示该页面可以在相同域名页面的 iframe 中引用，知乎网站首页响应头部使用的就是这个值。 ALLOW-FROM [URL]：表示该页面可以在指定来源的 iframe 中引用。 十五、综合能力 数据结构 算法 编程方式 设计模式 Serverless","categories":[],"tags":[{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/tags/%E8%BF%9B%E9%98%B6/"}]},{"title":"敏捷项目管理入门","slug":"book/video/202008敏捷项目管理","date":"2020-08-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.960Z","comments":true,"path":"2020/08/30/book/video/202008敏捷项目管理/","link":"","permalink":"http://yoursite.com/2020/08/30/book/video/202008%E6%95%8F%E6%8D%B7%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","excerpt":"","text":"敏捷的十二大原则 我们最重要的目标，是通过持续不断地及早交付有价值的软件使客户满意。 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。 业务人员和开发人员必须互相合作，项目中的每一天都不例外。 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。 可工作的软件是进度的首要度量标准。 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。 以简洁为本，它是极力减少不必要工作量的艺术。 最好的架构、需求和设计出自自组织团队。 团队定期地反思如何提高成效，并依此调整自身的举止表现。 敏捷的最佳实践我们是通过这些具体的内容来评判是否是最佳实践的： 稳定的团队：我们需要稳定、有默契的团队，即在很长一段时间内团队成员是固定不变的。 可预见的速率：我们需要在一个迭代当中形成团队的速率，方便知道下一个迭代我们可以做完哪些工作。 单件流：我们需要集中精力一次做好一件事情，所以不欢迎并行任务。 质量内建：我们需要在每一个环节保证好自己的质量，不让质量问题留到下游。 日事日毕：我们需要把任务粒度拆分成至多1天，以方便每天知道我们的工作进展。 设有紧急停车带：我们需要给紧急任务加上紧急停车带，以便分析紧急任务的插入情况。 滚动迭代：我们需要通过迭代交付来完善我们的产品。 持续改进：我们需要通过回顾和总结，不断强化我们的团队能力。 尽早交付：我们希望尽早交付版本，更快得到用户反馈，以便于更快满足用户所需。 敏捷实践方式：基于迭代每次迭代的结束是严格被时间框死的，也就是说，针对团队的迭代，我们要根据团队的能力，给定一个固定的可用时间。 敏捷实践方式：基于流程每次迭代必须要把所有的功能做完。如果在迭代过程当中一旦出现变更，变更的工作量也会加到总工作量里，迭代的时间也会相应延长。 混合敏捷实践 Scrum 为 PO（Product Owner）、SM（Scrum Master）以及 Team（跨职能团队）的使⽤提供指导，包括 Sprint 计划、每⽇晨会、Sprint Review 和回顾会议。 看板帮助团队进⼀步提⾼效率，⽅法是将⼯作流可视化，使项目瓶颈更容易被察觉，以及通过调整 WIP（在制品限制）来实现流程管理。 极限编程 XP，运用⼯程实践如使⽤用户故事卡片、持续集成、重构、⾃动化测试和 TDD（测试驱动开发），针对开发过程可以提高开发效率。 让敏捷思维在实践中成长 建立干净透明的环境 负责人发挥灯塔作用 从快速交付中尽早获得反馈 整个团队根据所有的任务建立产品待办事项列表（Product Backlog）； 产品经理从产品待办事项列表中选取价值高的需求列入迭代待办事项（Sprint Backlog）； 研发人员用 1—2 周的时间快速迭代； 测试完成后发布； 产品经理收集用户反馈后整理成需求，并重复第 1 步。 清晰团队及团队外成员的职责 每日站会 团队人数不超过 10 名。因为沟通的路径是 N*(N-1)/2，这就意味着人数越多，沟通效率越低，所以我们应当尽量保持 10 人以内的小团队。 需每天进行。敏捷的核心是小步快跑，因此我们把任务粒度拆分到1天内，每个人每天至少可以完成1个任务，这样团队每天都有新的进展，但是也会遇到新的问题，所以需要每日开展站会同步信息。 固定的时间且每次不超过15分钟。我建议在每天上午上班15分钟后开始，团队成员可以用 15 分钟梳理昨天完成的工作。Scrum Master 要控制会议时间以保证效率。 固定的地点。团队在固定的时间就可以到指定地点集合，更加快速、直接。 需站立，这样容易集中注意力，大家在潜意识里容易想赶紧结束会议，所以就会提高效率。 不解决问题。如果站会过程中解决问题，会让这个会议主题发散，我们把问题抛出来，在站会之后 Scrum Master 可以安排专项会议解决问题。 相关人员都需出席，所有与项目相关的人员都需要出席会议。 团队以外的人不能发言，以免不熟悉团队的外人干扰团队正常工作流程。 可以使用“发言令牌”，如网球，毛绒玩具等，随机抛向团队成员，拿到“发言令牌”的成员才可发言。这样使得团队成员要随时准备下一个发言，大家会更专注。 擅用信息同步工具 白板 议题的清晰度与会议的连贯性是视频会议成功的关键，我们需要事先协定好会议规程以避免混乱。规程包括发言的时间、用哪个统一的通讯平台。 规定写得越清楚越好， 除非团队事先就已经定义好，否则少用一些英文缩写或专有名词。 不要给团队发过多的信息，在发送之前，自己要仔细斟酌要表达的内容，避免产生歧义。 注意团队中性格内向的人，这些人比较擅长书面沟通，远程沟通实际上是为那些不喜欢在集体中发言的人提供更公平的竞争环境 最后，找一些远程庆祝和社交的方法，比如发微信红包、举办远程生日会等，增强团队的凝聚力和合作能力。 0-1导入敏捷第一种是 与加速交付相关 的转型。企业往往都是从百人以下的小团队开始发展，随着成长人数会越来越多，曾经的工作方式愈发不合适，组织效率就会越来越低，尤其是人数过千以后，管理者意识到要提高交付效率，加速交付过程，而敏捷可以帮助企业达成此目标，所以他们就想导入敏捷。这种状况多发生在互联网行业或传统软件行业，他们一般会以业绩成果来度量敏捷导入的产出。 第二种是 与敏捷方法相关 的转型。敏捷在中国已经推广了十几年，已经有很多公司导入了敏捷并取得不错的效果，比如腾讯公司。这就引起了其他大型企业的关注，如果敏捷能够使公司发展得更好，那为什么我不试试呢？所以他们也想导入敏捷，而且通常以改变协作方式为切入口，因为他们希望敏捷能帮助自己的团队与其他部门、供应商之间更频繁地交流与协作。他们比较重视敏捷过程的度量，比如某些环节的效率是否提升，跟同行业佼佼者比较还有多大差距。这种状况多见于银行业中。 消极因素 工作被分解为部门孤岛，从⽽创造出阻碍加速交付的依赖关系，而不是构建在能⼒中⼼指导下的跨职能团队，也就是说，部门墙越厚就越不利于敏捷转型； 短期交付型的项目不适合用敏捷。比如我们承接甲方的需求开发，甲方要求交付的产品特别明确，其间产生变更也会以补充合同进行说明，交付时间也会清楚地写进合同中， 因为这个项目不存在频繁的变化，所以并不需要敏捷； 团队优化的依据是部分效率而不是端到端的项目交付流或整体优化情况， 因为如果只想着提升研发效率，那么敏捷转型带来的效果是有限的，而敏捷可以带来的是全方位的优化，所以在导入的过程中，我们要着眼于全局； 员工属于特定领域人才，实现技能多元化的工具或激励有限，不重视培养T型专家⼈才。因为敏捷是跨职能团队，每个人除了自己的领域之外，最好还有其他领域的专业知识，比如开发工程师具备产品思维。 敏捷鼓励 T 型专家人才，即 在某一领域具有专长，同时又能在其他多个领域有一定的经验和见解的人 。 如果团队只是强调培养特定领域人才，这就只是在培养螺丝钉， 并不能为跨职能团队带来很多收益； 分散化项目组合即使员工同时分配到过多的项目，而无法专注于单个项目。敏捷宣言提到“可工作的软件胜于面面俱到的文档”，说明敏捷团队提倡简化文档。正是因为这点，所以我们要使团队保持稳定，主要就是团队成员相对固定，如果员工分配到过多的项目，就会打破这种稳定的团队结构，敏捷转型也就很难获得成功。 积极因素 管理层具有强烈的转型意愿。任何转型都是自上而下的，敏捷转型也不例外，管理层的转型意愿越强，企业的敏捷转型也越容易获得成功； 员工的认知和改变意愿。如果员工在认知上认可敏捷，认为 敏捷转型能解决自己目前的问题，且愿意在工作方式上作出改变。比如开始组建跨职能团队、开展晨会和回顾会，认知和改变的意愿越强，也就越容易获得成功； 组建跨职能团队。如果领导愿意把原来的组织结构调整为跨职能团队，为敏捷提供天然的适合生长的土壤，那么团队更容易转型成功。比如腾讯，就是按照跨职能组织的典型，产品、开发、测试和运营以项目为单位组织，大家共同背负业绩 KPI，树立共同的目标。除此之外，员工的涨薪并不直接由自己的职能领导给出评价，而是由通道委员会决定员工的职级 ，HR 再根据职级进行调薪。这样的团队只为达成产品目标服务，非常敏捷； 专注于短期目标而不是⻓期目标。敏捷团队需要不断试错以获得短期利益，所以敏捷团队更关注短期目标的达成，如果团队属于这种特性，那么更适合敏捷转型； ⼈才管理成熟度和能力。敏捷对于团队的要求是比较高的，一是由于敏捷鼓励自组织型团队，所以团队得有自我管理的能力，这就对团队成员要求较高；二是敏捷需要团队有很强的自动化能力，例如自动化测试、自动化构建和自动化部署。团队自我管理能力越强，团队的自动化能力越强，敏捷转型也越容易获得成功。","categories":[],"tags":[{"name":"敏捷","slug":"敏捷","permalink":"http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"}]},{"title":"前端周刊【202008-4】","slug":"weeks/2020/202008-4","date":"2020-08-30T01:00:00.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/08/30/weeks/2020/202008-4/","link":"","permalink":"http://yoursite.com/2020/08/30/weeks/2020/202008-4/","excerpt":"","text":"前端实现Promise所有方法","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202008-3】","slug":"weeks/2020/202008-3","date":"2020-08-24T01:00:00.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/08/24/weeks/2020/202008-3/","link":"","permalink":"http://yoursite.com/2020/08/24/weeks/2020/202008-3/","excerpt":"","text":"CSS Grid 系列(上)-Grid布局完整指南 CSS Grid 系列(下)-使用Grid布局构建网站首页","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"IE6789兼容性浅析","slug":"basic/htmlcss/IE兼容性浅析","date":"2020-08-21T01:00:00.000Z","updated":"2022-06-05T14:08:41.948Z","comments":true,"path":"2020/08/21/basic/htmlcss/IE兼容性浅析/","link":"","permalink":"http://yoursite.com/2020/08/21/basic/htmlcss/IE%E5%85%BC%E5%AE%B9%E6%80%A7%E6%B5%85%E6%9E%90/","excerpt":"","text":"1. IE11下 文字溢出…变成方框123456// 解决方案：添加字体font-family:microsoft yahei;max-width: 100%;overflow: hidden; white-space: nowrap; text-overflow: ellipsis; 2. placeholder IE8解决方案1&lt;input type=\"text\" onblur=\"if (this.value == '') &#123;this.value = 'Search';&#125;\" onfocus=\"if (this.value == 'Search') &#123;this.value = '';&#125;\" value=\"Search\" &gt; 3. css zoom ie hack 写法 zoom是为了兼容IE6 而写的 其实Zoom属性是IE浏览器的专有属性，Firefox等浏览器不支持。它可以设置或检索对象的缩放比例。除此之外，它还有其他一些小作用，比如触发ie的hasLayout属性，清除浮动、清除margin的重叠等。 12345678910111213/* 所有IE浏览器(ie6+)支持 ；但是IE8不能识别“*”和“_”的css hack；所以我们可以这样写hack */ color:#0000FF\\9; [color:#000000;color:#00FF00; /* SF,CH支持 */ *color:#FFFF00; /* IE7支持 */ _color:#FF0000; /* IE6支持 */ background-color:#0ff\\0;/* ie 8/9 */ background-color:#0f0\\9\\0;/* ie9 */ *background-color:#00f;/*ie7*/ _background-color:#ff0;/*ie6*/ background-color//:#090;/*非IE*/ background-color:#900\\9;/*所有ie*/ …","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ie","slug":"ie","permalink":"http://yoursite.com/tags/ie/"}]},{"title":"前端开发知识手册","slug":"basic/htmlcss/前端开发知识手册","date":"2020-08-21T01:00:00.000Z","updated":"2022-06-05T14:08:41.948Z","comments":true,"path":"2020/08/21/basic/htmlcss/前端开发知识手册/","link":"","permalink":"http://yoursite.com/2020/08/21/basic/htmlcss/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86%E6%89%8B%E5%86%8C/","excerpt":"","text":"CSS&amp;JS是这样阻塞DOM解析和渲染的 关于 CSS，大家肯定都知道的是标签放在头部性能会高一点，少一点人知道如果与同时在头部的话，在上可能会更好。 CSS 不会阻塞 DOM 的解析，但会阻塞 DOM 渲染。 JS 阻塞 DOM 解析，但浏览器会\"偷看\"DOM，预先下载相关资源。 浏览器遇到 且没有 defer 或 async 属性的 标签时，会触发页面渲染，因而如果前面 CSS 资源尚未加载完毕时，浏览器会等待它加载完毕在执行脚本。 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。 有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。 width_auto和width_100%的区别123456&lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt;&lt;style&gt; div&#123;width:600px;overflow:auto;&#125; p&#123;width:100%;padding:10px;&#125; p&#123;width:auto;padding:10px;&#125;&lt;/style&gt; 如果是width:100%，则说明p的width会得到600px就已经充满div区域，然后自己又有padding，所以会出现滚动条。 而width:auto则比较聪明，它是总体宽度（广义，包括width，margin,padding,border这些）等于父级宽度（狭义，内容区，仅指width），所以如果padding已经左右占去20px的空间，那么width给的值就是580px。 所以，如果： 123456p&#123; width:auto; background-color: red; margin:10px; padding:10px;&#125; 其实最后实际的width值为560px。但无论是width:100%还是auto，其计算的参照都是父级 *内容区 *width值，而非总宽度值。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JavaScript运行机制 & 节流防抖","slug":"basic/js/JS运行机制&防抖节流","date":"2020-08-21T01:00:00.000Z","updated":"2022-06-05T14:08:41.949Z","comments":true,"path":"2020/08/21/basic/js/JS运行机制&防抖节流/","link":"","permalink":"http://yoursite.com/2020/08/21/basic/js/JS%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6&%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/","excerpt":"","text":"JS运行机制1234567891011121314151617181920212223242526console.log('script start');setTimeout(function()&#123; console.log('settimeout'); &#125;,0)new Promise(resolve=&gt;&#123; console.log('promise1'); resolve()&#125;).then(function()&#123; console.log('promise2'); &#125;).then(function()&#123; console.log('promise3'); &#125;)console.log('script end');// 执行环境 执行环境会被顺序的加入到执行栈中 如果遇到异步的代码 会被挂起并且加入到Task队列当中// 一旦执行栈为空 Event loop 就会从task队列当中 拿出需要执行的代码并放入到执行栈中执行 // js的异步行为也是同步行为// 不同的任务源 会被分配到不同的Task队列当中 任务源可以分为 微任务(microtask) 宏任务 (macrotask)// 微任务 promise// 宏任务 setTimeout script// 1 执行同步代码 属于宏任务 2 执行栈为空 需要查询是否有微任务需要执行 3 执行所有的微任务 4 必要的话渲染ui 5 执行宏任务中的异步代码// 宏任当中 大量的需要操作dom 为了更快的页面响应 可以把操作dom放到微任务中 防抖和节流123456789101112131415161718192021222324252627282930313233343536373839404142// 防抖// 当我们连续触发事件的时候 一定时间段没有触发事件 事件处理函数才会执行一次// 如果设定的时间内又触发了事件 会重新开始计时 计时的点是在你最后一次点击开始function deb(fn,wait)&#123; var timeout = null return function()&#123; if(timeout !== null) clearTimeout(timeout) timeout = setTimeout(fn,wait) &#125;&#125;function handel()&#123; // 发送ajax请求 console.log(Math.random()); &#125;document.getElementById('btn').onclick= deb(handel,1000)// 触发事件保证一段时间内只调用一次 休息时间5秒 5秒内就是休息 一旦过了5秒开始营业// 滚动条function handeler()&#123; console.log(Math.random()); &#125;function thr(fn,delay)&#123; let flag = true; return function()&#123; if(!flag)&#123; // 休息 return false &#125; // 营业 flag = false fn() setTimeout(()=&gt;&#123; flag = true &#125;,delay) &#125;&#125;document.getElementById('btn').onclick= thr(handeler,3000)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"节流防抖","slug":"节流防抖","permalink":"http://yoursite.com/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"}]},{"title":"Vue2事件修饰符浅析","slug":"frame/vue/Vue2事件修饰符浅析","date":"2020-08-21T01:00:00.000Z","updated":"2022-06-05T14:08:41.965Z","comments":true,"path":"2020/08/21/frame/vue/Vue2事件修饰符浅析/","link":"","permalink":"http://yoursite.com/2020/08/21/frame/vue/Vue2%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E6%B5%85%E6%9E%90/","excerpt":"","text":"capture实现捕获触发事件的机制；各自触发各自的作用域 123&lt;div class=\"inner\" @click.capture=\"divHandel\"&gt; &lt;input type=\"button\" value=\"点击\" @click.capture=\"btnHandel\"&gt;&lt;/div&gt; prevent阻止默认行为，无论多少次都只触发进入方法 不会触发跳转href 1&lt;a href=\"http://www.baidu.com\" @click.prevent=\"linkClick\"&gt;有问题去百度&lt;/a&gt; prevent.once第一次触发进入方法 第二次触发跳转href 1&lt;a href=\"http://www.baidu.com\" @click.prevent.once=\"linkClick\"&gt;有问题去百度&lt;/a&gt; stop阻止冒泡，触发后，btnHandler该函数执行完成后，阻止会触发div的函数 divHandler 1234&lt;div class=\"inner\" @click=\"divHandler\"&gt; &lt;!-- 使用 .stop 阻止冒泡 --&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt;&lt;/div&gt; self触发后，btnHandler该函数执行完成后，阻止会触发div的函数 divHandler 123&lt;div class=\"inner\" @click.self=\"divHandel\"&gt; &lt;input type=\"button\" value=\"点击\" @click=\"btnHandel\"&gt;&lt;/div&gt; self stop 区别 .self 只会阻止自己身上冒泡行为的触发，并不会真正阻止 冒泡的行为 .stop 会阻止所有的冒泡的行为 123456789101112 &lt;!--点击【戳他】后只执行【戳他】对应的函数，往上的两个div中的函数不执行。--&gt; &lt;div class=\"outer\" @click=\"div2Handler\"&gt; &lt;div class=\"inner\" @click=\"divHandler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click.stop=\"btnHandler\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--点击【戳他】后，会执行 btnHandler和div2Handler函数，而不执行divHandler函数。--&gt; &lt;div class=\"outer\" @click=\"div2Handler\"&gt; &lt;div class=\"inner\" @click.self=\"divHandler\"&gt; &lt;input type=\"button\" value=\"戳他\" @click=\"btnHandler\"&gt; &lt;/div&gt;&lt;/div&gt;","categories":[],"tags":[{"name":"vue2","slug":"vue2","permalink":"http://yoursite.com/tags/vue2/"},{"name":"修饰符","slug":"修饰符","permalink":"http://yoursite.com/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}]},{"title":"极客70天算法训练营[未完]","slug":"book/video/202008算法训练营","date":"2020-08-20T12:42:04.000Z","updated":"2022-06-05T14:08:41.961Z","comments":true,"path":"2020/08/20/book/video/202008算法训练营/","link":"","permalink":"http://yoursite.com/2020/08/20/book/video/202008%E7%AE%97%E6%B3%95%E8%AE%AD%E7%BB%83%E8%90%A5/","excerpt":"","text":"一、数据结构与算法总览数据结构一维 数组array 链表link list 高级（栈stack 队列queue 双端队列deque 集合set 映射map、hash ） 二维 树tree 图graph 高级（二叉搜索树 binary search tree/red-black tree ,AVL）堆、并查集disjoint set 、字典树Trie 特殊 位运算bitwise 布联系吧过滤器bloomFilter LRU Cache 算法 if..else , switch -&gt; branch while loop , for –&gt; lteration 递归 Recursion 搜索：深度优先DFS 广度优先BFS 动态规划Dynamic Programming 二分查找 Binary Search 贪心 Greedy 数学 Math 几何 Geometry 切题四步法 反复看题 clarification 想所有可能的解法 Possible Solutions 时间空间复杂度 多写coding 测试样例多写下 test cases 五毒神掌 五遍刷题法 刷题第一遍 5分钟 读题+思考 最多15分钟 直接看解法 ：多解法 再比较复杂度 背记 默写 刷题第二遍 马上自己写 多解法比较 体会 优化！ 刷题第三遍 过了一天后，重复做题 不同的解法熟练程度 并进行专项练习 刷题第四遍 过了一周后，重复做题，国际站看大神解题 刷题第五遍 面试前一周恢复性训练 二、复杂度时间复杂度O(1) 常数复杂度 若执行了3次还是常数，依然是O(1) O(logn) 对数复杂度 O(n) 线性时间复杂度 for循环 并列循环 O(n^2) 平方 嵌套for循环 O(n^3) 立方 3层嵌套for循环 O(2^n) 指数 斐波拉数列 k的n次方 k是常数 O(n!) 阶乘 主定理算递归复杂度 二分查找 二分树遍历 二维距阵进行二分查找 归并排序 空间复杂度 数组长度 递归的深度 三、数组、链表、跳表​ 链表 数组 prepend O(1) O(1) append O(1) O(1) lookup O(n) O(1) insert O(1) O(n) delete O(1) O(n) 跳表：只能用于有序的情况，对标的平衡数和二分查找。优势原理简单容易实现，方便扩展，效率更高。 Redis.LRU缓存机制","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"覃超","slug":"覃超","permalink":"http://yoursite.com/tags/%E8%A6%83%E8%B6%85/"}]},{"title":"漫谈设计模式-从面向对象开始","slug":"book/2020/漫谈设计模式","date":"2020-08-20T12:00:00.000Z","updated":"2022-06-05T14:08:41.958Z","comments":true,"path":"2020/08/20/book/2020/漫谈设计模式/","link":"","permalink":"http://yoursite.com/2020/08/20/book/2020/%E6%BC%AB%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、模式介绍1. 面向对象和模式什么是对象任何事物，不管有形无形，都是对象。包含一些行为和属性。 封装：封装其实就是指隐藏，隐藏了数据，隐藏了实现细节。 继承：使不同对象具有相同的行为。 多态：以相同的方式处理不同类型的对象。 重用重用从方法、结构体、类的重用，从而上升软件的重用。 模式就是能够让我们从思想上重有有经验的开发人员的解决方案来解决问题。 模式每个模式都描述了一个在我们周转不断发生的问题，以及该问题的解决方案的核心，这样，你就能无数次地使用该解决方案而不用按照同样的方式重做一遍。 模式是某一上下文环境中一个问题的解决方案。 设计模式，描述了在一个特定上下文环境，如何定制这些互相通信的对象和类来解决一个常见设计问题。 2.模板方法世界上唯独不变的就是变化本身。 DRY - 不要复制自己、复制即魔鬼。 OAOO - 仅此一次 避免代码重复、应该整洁、不要坏味道 模板方法模式 Template Method 使用继承 使用回调 二、创建对象 单例模式 工厂模式、静态工厂模式：把对象实例化的过程进行了封闭客户对象再也不必为实例化而考虑太多。正是分离了实例化的逻辑，使得对象间耦合性大大降低。 原型模式：克隆以方便复制使用。深拷贝、浅拷贝。 控制反转IOC 好莱坞原则：不要找我们，我们会找你。 外部逻辑负责调用客户化的逻辑。 三、构建复杂结构四、行为模式五、终点还是起点","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"}]},{"title":"运维知识入门修炼","slug":"book/video/202008运维知识入门","date":"2020-08-17T01:00:00.000Z","updated":"2022-06-05T14:08:41.961Z","comments":true,"path":"2020/08/17/book/video/202008运维知识入门/","link":"","permalink":"http://yoursite.com/2020/08/17/book/video/202008%E8%BF%90%E7%BB%B4%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8/","excerpt":"","text":"牧客Jeson 一、Shell命令合集操作快捷键 ctrl + r 可以快速查找历史命令 ctrl + l 可以清空控制台屏幕 ctrl + a \\ ctrl + e 移动光标到命令行首、尾部 ctrl + w \\ ctrl + k 删除光标之前、之后的内容 VIM shift + zz 文件保存并退出 进程操作快捷键 ctrl + c 强行终止程序的执行 ctrl + z 挂起一个进程 ctrl + d 终端中输入exit后回车 linux命令中快捷键 shift + p 根据cpu使用率排序 shift + m 根据内存占有用排序 空间分析 硬盘空间不足，需快速定位日志目录 1du -x --max-depth=1 /|sort -k1 -nr du命令 -x 表示跳过其他文件系统 –max-depth=1 可以统计出根目录下第一级目录中所有文件大小 sort命令 -k 参数致命具体按照哪一列 -n 只对数值进行排序 -r 表示反向排序 整体指 第一列并按照数据大小做反序排列 系统产生很多碎片文件，导致inode资源不足 1find -type f|awk -F/-v OFS=/'&#123;$NF=\"\";dir[$0]++&#125;END&#123;or(i in dir)print dir[i]\"\"i&#125;'|sort -k1 -nr|head find -type -f 查找指定类型的文件，然后将结果通过管道传递给awk -F/ 指定处理文件时字符串之间以/进行分割 -v OPS=/表示文件显示结果以/进行分割展示 awk命令整体规则而言有个{}END{}格式，前面{}表示行处理操作，后面表示行处理后需要进行整体结果展示 文件操作 批量查找文件作内容替换 1find ./-type f -name consumer.xml -exec sed -i\"s/aaaaaa/bbbbbb/g\"&#123;&#125;\\; -name指定查找的文件名 -exec参数将查找到内容传递给下一个命令去继续执行相关逻辑 sed命令主要对文件内容进行替换，这里会将consumer文件中的aaaaaa替换成bbbbbb 批量查找文件作拷贝打包 1(find .-name \"*.txt\"|xargs tar -cvf test.tar)&amp;&amp;cp -f test.tar /home/. 括号中 包含两条命令 他们使用管道符进行连接 括号外 通过&amp;&amp; 与第三条命令连接 最终再拷贝 网络连接状态分析 1netstat -n|awk '/^tcp/&#123;++$[$NE]END&#123;for (a in S)print a,S[a]&#125;' netstat -n负责查看主机上所有TCP UDP连接信息 awk 负责对这些 信息进行进一步处理 / 括起来的正则表达式 IP信息提取 提取主机上的IP信息 1ip a|grep \"gobal\"|awk'&#123;print $2&#125;' |awk -F/'&#123;print $1&#125;' ip a 查看主机上所有网卡信息 通过grep进行条件过滤 再通过awk实现第二列内容输出 最后通过awk指定/作为分隔符来打印第一列信息 二、nginx基础配置优化 gzip 缓存配置优化 浏览器缓存 静态文件设置 expires 代理缓存（动静分离） proxy_cache_path cache levels my_cache:10m max_size https ssl ssl_session_cache shared-SSL:10m; ssl_session_timeout 10m; 后端缓存 redis memcache 打开文件缓存 元数据jpg open_file_cache max=1000 inactive=20s; open_file_cache_valid 30s; open_file_cache_min_uses 2; open_file_cache_errors on; 经验 能放在客户端就放客户端 能缓存越多越好 命中率越高越好 三、nginx负载均衡123456789101112http&#123; upstream app_servers&#123; server ip1:port1; server ip2:port2; server ip3:port3; &#125; server&#123; location /&#123; proxy_pass http://app_servers; &#125; &#125;&#125; 常见问题 客户端IP地址获取问题：服务端获取不到用户的IP 域名挟带问题 proxy_set_header Host $host 负载均衡导致session丢失问题 session保持ip_hash,url_hash session复制 session共享 动态负载均衡问题 真实的realserver状态检测 nginx_upstream_check_module 淘宝技术 四、入口网关服务注册发现openresty 动态upstream 开源组件方案confd nginx-upsync-module 开源AP网关方案 五、curl命令最常见使用方式123456789101112131415161718192021查看bodycurl http://www.baidu.com查看头部curl -I http://www.baidu.com重定向到文件里curl -I http://www.baidu.com -o output.txt查看请求服务端是否已经发送出去curl -v http://www.baidu.com文件下载curl -O -u user:password ftp://...curl -O http://...sh断点续传curl -C http://...sh GETcurl -v http://POSTcurl -v -X POST http://PUTcurl -v -X PUT http://DELETEcurl -v -X DELETE http:// 六、系统性能验收Unixbench基于linux unix基准测试工具。 FIO性能压测是一个开源的主流的LINUX磁盘IO测试工具。 devops(开发测试部署- 持续集成、运维) 自动化 各项流程需要无缝打通 交给统一平台进行可视化管理 七、持续集成gitlab docker jenins ansible 八、CMDB平台自动化资产管理：物理资产、虚拟资产、信息资产 IMOOCC.OPS Python + ansible + django 九、自动化任务平台八、K8S打造ci/cd核心思路 jenkins部署高可用 主从架构、部署到K8S中 通过pipeline创建管理job 通过API接口创建管理job 十、割接 服务内容 同构割接：对同构服务进行升级，主体结构是不变的，只是进行例行性的升级，或内容版本修改。 异构割接：整个主体结构做了改变 分类 局部割接：只操作了其中的一小部份内容，只对一小部分产生影响 全局割接：影响 整体功能，大部份内容需要做检查。 关键思路：停机维护、无缝升级如何设计","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"},{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"CMDB","slug":"CMDB","permalink":"http://yoursite.com/tags/CMDB/"},{"name":"K8S","slug":"K8S","permalink":"http://yoursite.com/tags/K8S/"},{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"}]},{"title":"架构知识入门修炼","slug":"book/video/202008架构知识入门修炼","date":"2020-08-16T01:00:00.000Z","updated":"2022-06-05T14:08:41.961Z","comments":true,"path":"2020/08/16/book/video/202008架构知识入门修炼/","link":"","permalink":"http://yoursite.com/2020/08/16/book/video/202008%E6%9E%B6%E6%9E%84%E7%9F%A5%E8%AF%86%E5%85%A5%E9%97%A8%E4%BF%AE%E7%82%BC/","excerpt":"","text":"阿里巴巴技术专家李智慧 一、架构强烈的好奇心、敏锐业务嗅觉、扎实技术基础、出色编程能力、深刻领悟主流技术产品和模式 基础 数据结构 操作系统 算法 设计模式 技术 缓存 异步 分布式存储 微服务 架构 高可用 高性能 安全 二、大型架构演进之路 &amp; 系统处理能力提升性能提升 垂直伸缩（传统企业 银行等） 硬件升级 费用 、硬件有物理极限、操作系统也有限制 水平伸缩（互联网企业） 演进之路 少量用户：单机系统 万级用户：数据库与应用分离 十万级用户：使用缓存改善性能应用服务集群化 百万级用户：使用反向代理和CDN加速响应、数据库读写分离 千万级用户：使用分布式文件系统和分布式数据库系统 亿级用户：使用搜索引擎、NOSQL、消息队列、分布式服务 三、分布式缓存 缓存特点 技术简单 性能提升显著 缓存关键指标 缓存键集合 缓存空间 缓存寿命 缓存类型 代理缓存 （通读缓存 read-through） 反向代理缓存（通读缓存 read-through） cdn缓存（通读缓存 read-through） 对象缓存（旁路缓存cache-aside） 分布式缓存 分布式缓存架构 分布式缓存模型 一致性HASH算法 缓存注意事项 频繁修改的数据 没有热点的数据 数据不一致 缓存雪崩 通读缓存：给客户端返回缓存资源，或在请求未命中缓存 时获取实际数据 旁路缓存：通常是一个独立的键值对存储 key-value 四、分布式消息队列 同步与异步 同步调用 异步调用（2个重要模型） 点对点模型 发布订阅模型 异步架构 异步调用实现架构 消息生产者：消息生产者是客户端的一部份代码，用来初始化异步处理 消息消费者：消息消费者，由应用开发者实现，主要职责是从消息队列中接收并处理消息。 分布式消息队列：消息队列是消息发送的目的地和发给消费者的缓冲。 点对点架构模型 发布订阅模型 消息队列异步架构好处 异步处理 易于伸缩 消峰填谷，使峰值变平缓 隔离失败机器 及自我修复 解耦（发布者视角、消费这视角） 常用消息队列产品 RabbitMQ * ActiveMQ RocketMQ Kafka ** 消息队列异步架构的反模式 阻塞式调用 （同步） 生产者消费显式依赖 耦合消息生产者和消费者 缺乏坏消息处理机制 消息队列异步架构的挑战 消息无序 消息重入队列 竞态条件 复杂度 五、分布式数据存储 mysql复制 主从复制： 一主一从 一主多从：分摊负载、专机专用、便于冷备、高可用 主主复制 数据分片 分片原理 分片方案 分片扩容 数据库部署 单一部署：主从复制实现伸缩 分库：两个web服务器和两个数据库 分片 将数据集切分成较小的分片，以便 于将它们分散存储在多台服务器上，避免一台机器处理整个数据集 数据库之间互相独立，不共享任何信息，通过分片键定位分片 将数据以某种方式切分，以便每台服务器都只存储一部份数据 综合部署都使用以上方案 NOSQL CAP原理 A数据可用性：任何时候任何应用程序 都可以读写访问 P分区耐受性 系统可以跨网络分区线性伸缩 C数据一致性 数据的多个备份任何时候都是一致性的 最终一致性的数据存储 六、微服务 单体系统的困难 编译部署困难 数据库连接耗尽 服务复用困难 新增业务困难 微服务框架 架构 服务消费者 服务提供者 注册中心 dubbo 阿里 spring cloud 微服务最佳实践 微服务模式 事件溯源 CQRS 命令与查询职责隔离 断路器：关闭 打开 半开 hystrix 超时 七、高性能系统架构 性能测试（主观视角 使用者体验上的快慢 ；客观视角 性能指标优劣） 性能指标：响应时间、并发数、性能计数器、吞吐量 测试方法：性能测试、负载测试、压力测试、稳定性测试 性能曲线：吞吐量、响应用时间性能特性 硬件优化 机房与骨干网络优化 异地多活的多机房架构 专线网络与自主CDN建设 服务器与硬件配置优化 使用SSD、网卡等 中间件优化 操作系统优化 虚拟机优化：垃圾回收器 基础组件优化：tomcat等 代码优化 多线程：并发编程，多线程与锁 数据结构：数组、链表、HASH表、树、图等 设计模式：遵循编码规范 面向对象 避免烂代码 资源复用：线程池和对象池 架构优化 缓存：缓存结果为对象、优化读操作、减少数据库访问，降低存储设备负载压力 集群 异步：优化写操作，控制消费速度，合适的负载压力，即时响应，更好用户体验 八、高可用系统架构 可用性度量 可用性指标 年度可用性指标 =（1-不可用时间/年度总时间）*100% 通常用N个9来说明互联网应用可用性 故障分 事故级故障：严重故障，整体不可用：权重100 A类故障：网站访问不顺畅或核心功能不可用：权重20 B类故障：非核心功能不可用或核心功能少数用户不可用：权重5 C类故障 ：以上故障以外的其它故障：权重1 故障分 = 故障时间 * 故障权重 高可用架构 负载均衡：HTTP、DNS、反向代理、IP层、数据链路层 备份与失效转移 消息队列隔离 限流降级：通过对并发访问进行限流，降低并发的请求数据来保护系统；关闭部份非核心功能，降低对系统的资源消耗，保证系统在高并发的情况下仍然保持可用。 异地多活多机房 高可用运维 自动化部署 自动化监控 自动化测试 预发布测试 九、系统的安全架构 WEB攻击 XXS攻击 SQL注入攻击 CSRF攻击 WEB防护 过滤消毒 SQL参数绑定：防御SQL注入 验证码 ：防御CSRF WEB防火墙：modsecurity 加密 单项散列加密：明文转密文 不可以解密的 加密是单项的 对称加密：密钥 非对称加密：公钥、私钥 信息过滤反垃圾 分类算法 布隆过滤器","categories":[],"tags":[{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"},{"name":"消息队列","slug":"消息队列","permalink":"http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"数据存储","slug":"数据存储","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"}]},{"title":"前端周刊【202008-2】","slug":"weeks/2020/202008-2","date":"2020-08-15T12:42:04.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/08/15/weeks/2020/202008-2/","link":"","permalink":"http://yoursite.com/2020/08/15/weeks/2020/202008-2/","excerpt":"","text":"前端性能优化之雅虎35条军规 Web开发应了解的5种设计模式 那些前端开发必不可少的生产力工具","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"VUE3核心源码","slug":"book/video/202008VUE3核心源码","date":"2020-08-15T06:42:04.000Z","updated":"2022-06-05T14:08:41.960Z","comments":true,"path":"2020/08/15/book/video/202008VUE3核心源码/","link":"","permalink":"http://yoursite.com/2020/08/15/book/video/202008VUE3%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81/","excerpt":"","text":"一、vue-next 源码结构目录lerna npm i lerna 管理包的工具 二、手写reactivity响应式模块 @vue/reactivity响应式模块 reactive把对象变为响应式对象 effect 副作用 effect里的变量发生变化时默认重新执行 computed 计算属性 ref 使用模块 use reactivity1234567891011// import &#123; reactive, effect, computed, ref&#125; from '@vue/reactivity'// 手写import &#123; reactive, effect, computed, ref&#125; from './index.js'const state = reactive(&#123;name:'zf',age:'30'&#125;);effect(()=&gt;&#123; //默认执行一次 改变后又执行一次 console.log(state.name);&#125;)state.name = 'jw';// watchEffect 基于effect （批量更新的策略）// vue3兼容vue2 手写reactive.js12345678910111213141516171819202122232425262728293031323334353637383940export function reactive(target)&#123; // 创建响应式对象 目标对象不一定是数组 或者 对象 return createReactiveObject(target,&#123; get(target,key,receiver)&#123; // proxy + reflect ES6 API const res = Reflect.get(target,key,receiver);// === target[key] track(target,'get'); if(isObject(res))&#123; return reactive(res); &#125; return res; &#125;, set()&#123; // 需要判断修改的属性还是增加的属性 如果是原来的值则不做任何操作 const hadKey = Object.prototype.hasOwnPrototype.call(target,key); const oldValue = target[key]; const res = Reflect.set(target,key,receiver);// === target[key] if(!hadKey)&#123; console.log('新增操作'); trigger(target,'add',key,value); //触发依赖新增 &#125;else if(value !== oldValue)&#123; console.log('修改操作'); trigger(target,'set',key,value); //触发依赖更新 &#125; return res; &#125; // 除了代理这些方法之外 可能还有很多逻辑 &#125;);&#125;function createReactiveObject(target,baseHandler)&#123; if(!isObject(target))&#123; return target; &#125; //是对象 根据当前对象进行代理 const observed = new Proxy(target,baseHanlder); return observed;&#125; computed.js123456789101112131415161718192021222324252627282930313233343536373839404142export function computed(getterOrOptions)&#123; let getter; let setter; if(isFunction(getterOrOptions))&#123; getter = getterOrOptions setter = () =&gt;&#123;&#125; &#125;else&#123; getter = getterOrOptions.get; setter = getterOrOptions.get; let dirty = true; //默认第一次取值执行getter let computed; // 计算属性也是一个effect let value; let runner = effect(getter,&#123; lazy:true,// 懒加载 computed:true, //仅仅是个标识是个计算属性而已 scheduler:() =&gt;&#123; if(!dirty) &#123; dirty = true; // 等会就算属性依赖的值发生变化后 就会执行这个scheduler trigger(computed,TriggerOpTypes.SET,'value') &#125; &#125; &#125;) let value; computed = &#123; get value()&#123; if(dirty) &#123; //多次取值不会重新执行effect value = runner(); dirty = false; track(computed,TrackOpTypes.GET,'value') &#125; return value; &#125;, set value(newValue)&#123; setter(newValue); &#125; &#125; return computed;&#125; ref.js123export function ref()&#123;&#125; effect.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394export function effect(fn,options = &#123;&#125;)&#123; const effect = createReactiveEffect(fn,options); if(!optinos.lazy)&#123; effect(); //默认就要执行 &#125; return effect;&#125;// 创建响应式的方法let uid = 0;let activeEffect;const effectStack =[]; // 栈结构function createReactiveEffect(fn,options)&#123; const effect = function reactiveEffect()&#123; if(!effectStack.includes(effect))&#123; // 避免死循环 try&#123; effectStack.push(effect); activeEffect = effect;// 将effect放到activeEffect return fn(); &#125;finally&#123; effectStack.pop(); activeEffect = effectStack[effectStack.length - 1]; &#125; &#125; &#125; effect.options = options; effect.id = uid++; effect.deps = []; return effect;&#125;const targetMap = new WeakMap(); // 用法和MAP一致 但弱引用 不会导致内存泄露export function track(target,type,key)&#123; if(activeEffect === undefined)&#123; return; //说明 取值的属性不依赖于effect &#125; let depsMap = targetMap.get(target); if(!depsMap)&#123; targetMap.set(target,(depsMap = new Map())) &#125; let dep = depsMap.get(key) if(!dep)&#123; depsMap.set(key,(dep = new Set())) &#125; if(!dep.has(activeEffect))&#123; dep.add(activeEffect) acctiveEffect.deps.push(dep) &#125;&#125;export function trigger(target,type,key,value,oldValue)&#123; let depsMap = targetMap.get(target); // 获取当前对应的map if(!depsMap)&#123; return &#125; // 计算属性要优先于effect执行 const effects = new Set(); const computedRunners = new Set(); const add =(effectsToAdd) =&gt;&#123; if(effectsToAdd)&#123; effectsToAdd.forEach(res=&gt;&#123; if(res.options.computed)&#123; computedRuners.push(effect); &#125;else&#123; effects.add(); &#125; &#125;) &#125; &#125; //const run = (effects)&#123; // if(effects) effects.forEach(res =&gt; effect()) //&#125; if(key !== null)&#123; add(depsMap.get(key)) &#125; if(key === 'add')&#123; // 数组新增属性，会触发length 对应的依赖 在取值的时候回对length属性进行依赖收集 add(depsMap.get(Array.isArray(target)?'length':'')) &#125; const run = (effect) =&gt; &#123; if (effect.options.scheduler) &#123; effect.options.scheduler(); &#125; else &#123; effect(); &#125; &#125; computedRunners.forEach(run); effects.forEach(run);&#125; index.js 整合以上模块1234export &#123;computed&#125; from './computed'export &#123;effect&#125; from './effect'export &#123;ref&#125; from './ref'export &#123;reactive&#125; from './reactive' 三、手写createApp()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// import &#123; createApp &#125; from 'vue'; // 高阶函数的使用 内部会自动传入dom操作的方法import App from './App.vue'import &#123; createRenderer, createApp,nextTick &#125; from '@vue/runtime-dom'; // 拿到创建渲染器的方法// 原生vue3 中可以直接创建应用 ， 我希望底层变成小程序的// vue3 的底层还是操作dom元素 setData()// createApp(App).mount('#app')let canvas;let ctx;const d2a = (n)=&gt;&#123; return n * Math.PI / 180&#125;const drawCircle = (start,end,color,cx,cy,r)=&gt;&#123; // Math.cos sin 他都是基于弧度来计算的 let x = cx + Math.cos(d2a(start)) * r; // 已知 角度 和 斜边 求临边 cos // 将角度转化成弧度 let y = cy + Math.sin(d2a(start)) * r; // 已知 角度 和 斜边 求对标 sin ctx.beginPath(); // 固定用法 ctx.moveTo(cx,cy); ctx.lineTo(x,y); ctx.arc(cx,cy,r,d2a(start),d2a(end)); ctx.fillStyle = color; ctx.fill(); ctx.stroke(); // 线条方式展示 ctx.closePath();&#125;const draw = (el,noClear) =&gt; &#123; // 要识别哪些我能渲染 // div 我就不识别了 没有意义 if(!noClear)&#123; ctx.clearRect(0,0,canvas.width,canvas.height); &#125; if (el.tag == 'circle') &#123; // 这是我要画个圆 let &#123; data, x, y, r &#125; = el; // console.log(data, x, y, r); // 用canvas 来画饼图 // 饼图 总共数量 每个占比 let total = data.reduce((memo, current) =&gt; memo + current.count, 0) // 一共360° 每个占多少° let start = 0, end = 0; data.forEach(item =&gt; &#123; end += item.count / total * 360; drawCircle(start, end, item.color, x, y, r); start = end; // 不停的向下便宜 &#125;); &#125; if (el.tag === 'rect') &#123; // 柱状图 console.log('开始绘制矩形') &#125; el.childs &amp;&amp; el.childs.forEach(child =&gt; &#123; // 渲染儿子 draw(child,true) &#125;);&#125;const ops = &#123; // 自己重新定义的方法 mpvue源码, 这里我可以增添自己的渲染逻辑 insert: (child, parent, anchor) =&gt; &#123; // 插入的过程是由子及父 先将circle 插入到div 中 在将div中插入到canvas // 插入时 先创建父子关系 child.parent = parent; // dom元素的children只能读不能写, 树的操作 内部创建时会遍历节点，遍历的时候 我就可以创建父子关系，等会渲染的时候 我需要这个父子关系 if (!parent.childs) &#123; parent.childs = [child] &#125; else &#123; parent.childs.push(child); &#125; if (parent.nodeType == 1) &#123; // 遇到canvas了，我就需要重新将这棵树渲染到canvas中 // canvas &gt; div &gt; circle draw(child); if(child.onClick) &#123; canvas.addEventListener('click',()=&gt;&#123; child.onClick(); // 触发定义的事件 nextTick(()=&gt;&#123; draw(child); // 重新绘制canvas &#125;) &#125;) &#125; &#125; &#125;, remove: child =&gt; &#123;&#125;, createElement: (tag, isSVG, is) =&gt; &#123; // 创建元素的过程 深度遍历的过程 有儿子 先创建儿子 将儿子绑定到父亲上 return &#123; tag &#125;; // 虚拟节点 这个&#123;&#125; 是对象 &#125;, createText: text =&gt; &#123;&#125;, createComment: text =&gt; &#123;&#125;, setText: (node, text) =&gt; &#123;&#125;, setElementText: (el, text) =&gt; &#123;&#125;, parentNode: node =&gt; &#123;&#125;, nextSibling: node =&gt; &#123;&#125;, querySelector: selector =&gt; &#123;&#125;, setScopeId(el, id) &#123;&#125;, cloneNode(el) &#123;&#125;, insertStaticContent(content, parent, anchor, isSVG) &#123;&#125;, patchProp(el, key, prevValue, nextValue) &#123; // 这里以前可能做的是 样式处理 事件处理 el[key] = nextValue; // 相当于给自己自定义的对象添加了属性 // draw() 方法 &#125;&#125;const createCanvasApp = (...args) =&gt; &#123; // 这里创建渲染器时可以传入底层你想操作的方法 let app = createRenderer(ops).createApp(...args); // app.mount let &#123; mount &#125; = app; // 内部的mount方法 app.mount = function(selector) &#123; let el = document.querySelector(selector); // todo... // 实现canvas 得有canavas的画布 canvas = document.createElement('canvas'); canvas.width = window.innerWidth; canvas.height = window.innerHeight; el.appendChild(canvas); ctx = canvas.getContext('2d') mount(canvas); &#125; return app;&#125;createCanvasApp(App).mount('#app'); 四、手写vite1234// 安装npm install create-vite-app -g create-vite-app projectNamenpm init vite-app projectName 默认采用的是es6原生模块 import语法会默认发送一个请求 默认会给VUE的模块增加一个前缀/@modules 把.vue文件在后端给解析成一个对象了 唯一就是编译了.vue文件 123456789101112131415161718192021222324252627282930313233const Koa = require('koa');const &#123;serveStaticPlugin&#125; = require('./plugins/serverPluginServeStatic');const &#123;moduleRewritePlugin&#125; = require('./plugins/serverPluginModuleRewrite.js');const &#123;moduleResolvePlugin&#125; = require('./plugins/serverPluginModuleResolve.js');const &#123;htmlRewritePlugin&#125; = require('./plugins/serverPluginHtml');const &#123;vuePlugin&#125; = require('./plugins/serverPluginVue')function createServer()&#123; const app = new Koa(); // 创建一个koa实例 const root = process.cwd(); // 当用户运行 npm run my-dev时 会创建服务 // koa是基于中间件来运行的 const context = &#123; app, root // 当前的根的位置 &#125; // koa的中间件的执行顺序 中间件的原理 const resolvedPlugins = [ // 插件的集合 htmlRewritePlugin, // 2) 解析import重写路径 moduleRewritePlugin, // 3) 解析 以/@modules文件开头的内容 找到对应的结果 moduleResolvePlugin, // 1) 要实现静态服务的功能 vuePlugin, serveStaticPlugin // 功能是读取文件将文件的结果放到了ctx.body上 ]; resolvedPlugins.forEach(plugin=&gt;plugin(context)) return app; // 返回app 中有listen方法&#125;module.exports = createServer;","categories":[],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://yoursite.com/tags/vue3/"},{"name":"diff","slug":"diff","permalink":"http://yoursite.com/tags/diff/"},{"name":"proxy","slug":"proxy","permalink":"http://yoursite.com/tags/proxy/"}]},{"title":"产品体验设计与实操","slug":"book/video/202008产品体验设计思维","date":"2020-08-15T06:42:04.000Z","updated":"2022-06-05T14:08:41.960Z","comments":true,"path":"2020/08/15/book/video/202008产品体验设计思维/","link":"","permalink":"http://yoursite.com/2020/08/15/book/video/202008%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4/","excerpt":"","text":"一、基础界面1、启动页 纯色背影 Logo靠下 、吉祥物、SOLGON 大片拍摄、气质第一（美食、旅行、电商、影院） 微信：设计简单、寓意深远 容易采坑（选图不适、版权） 自如：风景城市名片 故事渲染、直戳人心（大爱题材） 场景故事渲染，引起共鸣，吸引用户目光 引领趋势、打破常规（时尚、动漫、视频、游戏） 创新和突破，打破用户的审美疲劳。 3D建模：闲鱼、百度、天猫 二次元：BILIBILI 短视频：难度大成本高 效率低 2、启动页实例（适合的才是最好的）操作流程 排列方式 设计形式 规范格式：不同分辨率来投放 3、首页入口留住用户 解决功能层级的分组问题 让用户在无意识状态下 格式塔理论的接近原则 直观呈现信息 找到功能入口 不是目的 主要是为了找到具体的内容 设计技法 图标风格分功能 色彩区块更直接 卡分分割显气质 文字和线做对比 标签留白齐参与 4、首页三种设计类型 功能入口型、信息列表型、即时体验型 信息列表型和即时体验型的表象 发现其信息列表要突出的重心，围绕这个重心选择适合的排列方式 上下排列 左右排列 第一，提升即时体验场景的准确度，比如地图的定位准确才能找到目的地，不至于走冤枉路； 第二，注重引导用户的操作体验，比如导航，箭头显示引导用户一直向前，无须用户判断东南西北； 第三，即时反馈的交互，比如“游戏开黑”场景中放了个大招，结果出现延迟，被对方翻盘了，这体验玩家得多郁闷。 怎么融合三种首页设计类型 1.明确设计需求、分组功能层级 2.选择适合的设计技法 图标风格分功能 颜色区块更直接 卡片分割显气质 文字和线做对比 标签、留白齐参与 3.信息列表的融合、提升内容转化 4.即时体验型设计 5、实用性强的图标设计 特征 高辨识度，无须注释 美观大方，吸引用户 凸显功能，体现特征 : 帮助用户快速识别产品功能 国际范儿，通用性强 怎么设计 找到品牌符号 : 品牌色、VI 形象的延展、吉祥物的延展、公司文化、Slogan、行业特征 找准表达图标的方式 : 拟物化表达 比喻的手法 将字做主体 模拟出场景 二、细节设计1、优化弹框 1.选择好出现的时机 2.避开阻断性影响 3.体现独立性，降低跳出感 4.交互方式上实现统一 Toast （提示框）： 一般用来显示操作结果，作为提醒或消息反馈来用，这是对用户操作影响最小的弹窗，所以在产品中被用得也最多。比如下图 1 新闻发现新消息之后提示用户。 Dialog（对话框）： 主要用于一些比较重要的操作，必须用户做出反馈，多以阻断性的弹窗出现，按理说是对用户的困扰最大，但其涉及的操作往往也比较重要，比如下图 2 需要用户确认，可以有效防止用户误操作。 ActionBar（功能框）： 可以看成是 Dialog 的一种延伸设计，但增加了更多的功能选择，同样也需要用户必须做出操作，但基本上自带取消按钮。比如下图 3 所示，更多的选项供用户选择。 Snackbar（提示对话框）： 是安卓系统的特色弹窗之一，不会打断用户正常的操作流程，用户可以点击功能按钮进行回应也可以忽略。如下图所示，弹窗一闪而过，还可以操作。 一致性 弹窗出来方式和停留的位置： 提示框、对话框、功能框、提示功能框都可以从页面底部弹出，也可以都停留在底部，这样远比居中显示对用户的困扰要小得多，用户对弹窗的出现也会有一定的心理预期。 退出弹窗方式可控： 弹窗带有关闭按钮，但关闭的位置却哪里都有，从用户可控热区来说，关闭放置在弹窗下面更容易被用户触碰到；带有取消按钮的弹窗也尽量靠下放置在用户可触碰区域，用户可以轻松关闭不需要的弹窗，这样远比不知道怎么关闭的困扰要小得多。 弹窗设计上的统一： 弹窗上可操作区域和重点信息应该被着重设计，最先被用户 get 到。设计上尽量简洁，突出信息层级的主次。比如下图中，简洁的界面设计清晰地呈现出弹窗上的关键信息和可操作区域，右图还显示安装的进度，给用户的清晰的反馈，降低用户在等待中的困扰。 2、状态 1.提示引导用户操作的状态 2.体验中的即时响应提高用户的效率 3.体验完成结果反馈提示用户结束状态 怎么设计状态才能让用户实时感知？ 1.设计要容易理解且醒目 2.动效要引人入胜 3.要注重情感化的表达 3、表单 切断用户的后顾之忧： 抓住用户痛点去想解决方案，比如信息填到一半网络中断未保存。 改变表单展现的形式： 减少用户因填写信息过多而产生的焦虑感，你要从交互体验层面去创新，比如填写信息的方式由输入型变为选择型。 新技术带来的全新交互形式： 了解前沿技术很重要，因为新技术能带来体验的革新。比如我们可以用 OCR 技术，通过扫描提取到图片的文字信息，节省输入信息的操作成本。 4、签到页 好处 促进日活： 这是签到页最直接的作用，也是产品运营的基本诉求，比如资讯产品会用实时推送的通知来带动日活。对签到页来讲，设计醒目的福利展示，无疑是最能调动用户进行签到的方式了。比如图 1 展示了签到积分可兑换的礼品，会促使用户签到。 稳定留存： 留存就是要留住用户。我们经常用留存来反推产品的体验设计好不好，产品能帮用户解决问题，体验设计做得也好，留存自然会提高。而在签到页设计中稳定留存最好的办法就是设计好签到的周期，让用户坚持打卡，打卡时还要让用户轻松点击一下就能领取福利。这样一来，福利吸引到用户，体验也很轻，用户很容易坚持。比如图 2 中每天浇浇水就能开宝箱，连续完成几次还有别的奖励，这些都能吸引用户持续签到。 带动拉新： 产品发展到一定阶段会面临增长瓶颈，因为用户的圈层和基数有限，所以产品运营会不断扩大推广的圈层，但这不是靠几个人的力量就能完成的。签到页中有邀请好友、成就展示、好友排名等功能展示，都能通过分享带来裂变拉新。比如图 3 中邀请好友助力领水，当日邀请 6 个人还有更丰厚的奖励。 扩大营收： 营收是任何产品都无法回避的现实，在签到设计中也不能错过营收环节，不过根据产品类型的不同，追求的营收指标是不一样的。比如资讯类产品任务是增加文章阅读量来扩大营收，而电商产品任务是引导用户下单来扩大营收，下图中去拼单就能获得化肥奖励，领取奖励后，弹窗还会提醒你继续去拼单，还添加了任务失效时间节点，制造了一些紧迫感。 上隐模型触发（设计带入）&gt; 行动（签到体验）&gt; 多变的筹赏（签到周期）&gt; 投入（持续签到）。 HOW 通过设计增强代入感 签到体验暴露隐性设计的魅力 签到的周期增强用户黏性 领取福利要贴近实际 5、缺省页 1.传达品牌形象，体现品牌温度 2.趣味性的表达，触动用户情感 3.提供新任务的引导，带来转化 三、全链路思维篇1、体验不等于视觉 1.按界面的功能区分视觉表现2.选择适合的视觉方法视觉对体验的影响主要表现在视觉设计所呈现出来的结果上，比如改变用户体验的视觉层级，这样用户的聚焦点、触发点都可能会发生变化，由此可能触发一些错误的操作。我们归纳一下视觉设计呈现出这些结果所用的方法，主要有比例、平衡、对比、重心等。 比例： 视觉占据的比例大了，用户视线都转移到了视觉上，势必对体验产生影响。比如图1中开启通知的设计，“引导用户立即开启”的设计比例很大，暂不开启比例很小被弱化，视觉和体验上引导用户正确操作，表达很到位。 平衡： 视觉元素中对称、径向、呼应等关系维系着整个画面的平衡，如果做不到这一点就会使得画面失衡，从而影响用户对体验的判断。比如图2的设计，两个按钮之间明显不平衡，画面比例明显失调。 对比： 视觉设计中经常用对比来表现体验顺序，可这个对比设计用不好，就可能会让用户错误操作。比如图3中的设计，两个按钮虽然对称，而且立即开启的设计对比明显强过暂不开启的设计，可用户的操作却落在了暂不开启的操作上，因为手指的操作热区更容易触碰到。 重心： 视觉设计改变了体验中的功能层级，影响用户的视觉重心发生了转移，用户的体验自然随重心偏移而发生转变。比如图4的设计，虽然两者的视觉层级等同，但却区分不出两个功能按钮的主次了，很可能引导用户点击了暂不开启。 保持“克制”的设计理念：保持“克制”的设计理念，就是要在视觉表现力上的适度原则，不要用力过猛。 2、深色模式 打造沉浸式体验的设计方式 沉浸式体验需要尽可能地调动五感（形、声、闻、味、触），长时间吸引用户的注意力，尽可能排除其他的干扰。 高度沉浸：注意力高度集中，完全沉浸在正在做的事情中。 体验惊喜：在探索的过程中会不断地收获到意外的惊喜。 内心通透：清晰地知道自己在做什么、需要达到什么目标。 有胜任感：知道这件事有难度，但依然是自己能胜任。 内心宁静：丧失自我察觉，甚至忘记基本生理需求，例如废寝忘食。 忘记时间：全身心投入后，时间在不知不觉中流逝。 找到内在动机：你觉得自己在做的事情源于内心的渴望和对目标的认同。 而这些心流特点表现在体验设计中，就是在营造一种“代入感”引人入胜，然后通过体验、情境、视觉等吸引用户全身心投入，我将这种“代入感”在设计中表现形式总结为如下四种： 场景化的表达； 抓眼球的视觉； 故事化的情境； 情感化的感染。 3、数据可视化 数据可视化设计不是为了炫酷，而是为了将数据化繁为简，更好地传达给用户。 我从用户对数据的理解层面出发，总结了数据可视化里的 4 个设计要点： 数据中的视觉色彩 数据比对的关联性 数据中的图形释义 数据结果的直观性 4、设计中台 这跟企业复用平台一样，只不过针对的是设计层面，是设计规范产品化思路的一种体现，我们从所有的业务设计中梳理出可形成统一规范、可复用的设计样式，将这些样式设计成灵活的通用组件。这里包括交互、视觉、UI、GUI、产品原型、设计流程、规范、品牌形象等设计，可以在很大程度上提高设计师的工作效率。 选择适合的平台； 建立设计项目； 建立设计规范； 建立设计情绪板。","categories":[],"tags":[{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"},{"name":"UX","slug":"UX","permalink":"http://yoursite.com/tags/UX/"},{"name":"UED","slug":"UED","permalink":"http://yoursite.com/tags/UED/"}]},{"title":"Rollup 浅析","slug":"basic/js/Rollup浅析","date":"2020-08-12T15:42:04.000Z","updated":"2022-06-05T14:08:41.949Z","comments":true,"path":"2020/08/12/basic/js/Rollup浅析/","link":"","permalink":"http://yoursite.com/2020/08/12/basic/js/Rollup%E6%B5%85%E6%9E%90/","excerpt":"","text":"画个重点 开发应用时使用 Webpack，开发库时使用 Rollup Rolluphttps://www.rollupjs.com/Rollup 是一个 JavaScript 模块打包器，可以将小块代码编译成大块复杂的代码，例如 library 或应用程序 通过 rollup 打包后的代码，相比与 webpack 打出来的包体积会更小，而且代码会更加简洁，不会有过多的冗余代码。 rollup 也对 es 模块输出及 iife 格式打包有很好的支持 Tree Shaking: 自动移除未使用的代码, 输出更小的文件 Scope Hoisting: 所有模块构建在一个函数内, 执行效率更高 Config 文件支持通过 ESM 模块格式书写 可以一次输出多种格式: 不用的模块规范: IIFE, AMD, CJS, UMD, ESM Development 与 production 版本: .js, .min.js 文档精简 构建UMD12345678910111213141516171819202122import typescript from 'rollup-plugin-typescript2';import &#123; version &#125; from './package.json';export default &#123; input: 'src/utils.ts', // 入口文件 output: &#123; name: 'my_utils', // umd 模式必须要有 name 此属性作为全局变量访问打包结果 file: `dist/@$&#123;version&#125;/index.js`, format: 'umd', sourcemap: true, &#125;, plugins: [ typescript(&#123; tsconfigOverride: &#123; compilerOptions: &#123; declaration: false, // 输出时去除类型文件 &#125;, &#125;, &#125;), ],&#125;;rollup -c babel 编译1npm i -D @babel/core @babel/plugin-transform-runtime @babel/preset-env @rollup/plugin-babel @babel/preset-typescript 123456789101112131415161718192021222324252627//.babelrc&#123; \"presets\": [ [ \"@babel/preset-env\", &#123; \"modules\": false, \"loose\": true, \"targets\": &#123; \"browsers\": \"&gt; 1%, IE 11, not op_mini all, not dead\", \"node\": 8 &#125; &#125; ], [\"@babel/preset-typeScript\"] ]&#125;// rollup.configimport &#123; babel &#125; from '@rollup/plugin-babel';plugins:[ babel(&#123; extensions: [\".js\", \".ts\"], exclude: \"node_modules/**\", babelHelpers: 'bundled' &#125;),] 压缩12345678// shnpm install -D rollup-plugin-terser// rollup.config.jsimport &#123; terser &#125; from 'rollup-plugin-terser';plugins: [ terser(),] 打包库常用12345678910111213141516171819202122232425262728import resolve from 'rollup-plugin-node-resolve' // 告诉 Rollup 如何查找外部模块import commonjs from 'rollup-plugin-commonjs' // 将CommonJS模块转换为 ES2015 供 Rollup 处理import vue from 'rollup-plugin-vue' // 处理vue文件import babel from 'rollup-plugin-babel' // rollup 的 babel 插件，ES6转ES5import css from 'rollup-plugin-css-only' // 提取css，压缩能力不行import CleanCSS from 'clean-css' // 压缩cssimport &#123; writeFileSync &#125; from 'fs' // 写文件export default &#123; //目录 input: 'index.js', output: &#123; name:'crud', file: 'bundle.js', format: 'umd' &#125;, plugins: [ resolve(&#123; extensions: ['.vue'] &#125;), commonjs(), vue(), babel(), css(&#123; output(style) &#123; // 压缩 css 写入 dist/vue-rollup-component-template.css writeFileSync('dist/vue-rollup-component-template.css', new CleanCSS().minify(style).styles) &#125; &#125;), // css: false 将&lt;style&gt;块转换为导入语句，rollup-plugin-css-only可以提取.vue文件中的样式 vue(&#123; css: false &#125;), ]&#125;; 基础插件 rollup-plugin-alias: 提供 modules 名称的 alias 和 reslove 功能. rollup-plugin-babel: 提供 Babel 能力, 需要安装和配置 Babel (这部分知识不在本文涉及) rollup-plugin-eslint: 提供 ESLint 能力, 需要安装和配置 ESLint (这部分知识不在本文涉及) rollup-plugin-node-resolve: 解析 node_modules 中的模块 rollup-plugin-commonjs: 转换 CJS -&gt; ESM, 通常配合上面一个插件使用 rollup-plugin-replace: 类比 Webpack 的 DefinePlugin , 可在源码中通过 process.env.NODE_ENV 用于构建区分 Development 与 Production 环境. rollup-plugin-filesize: 显示 bundle 文件大小 rollup-plugin-uglify: 压缩 bundle 文件 rollup-plugin-serve: 类比 webpack-dev-server, 提供静态服务器能力","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"rollup","slug":"rollup","permalink":"http://yoursite.com/tags/rollup/"},{"name":"treeshaking","slug":"treeshaking","permalink":"http://yoursite.com/tags/treeshaking/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"前端处理表格数据思路","slug":"basic/js/前端处理EXCEL表格数据思路","date":"2020-08-08T12:42:04.000Z","updated":"2022-06-05T14:08:41.949Z","comments":true,"path":"2020/08/08/basic/js/前端处理EXCEL表格数据思路/","link":"","permalink":"http://yoursite.com/2020/08/08/basic/js/%E5%89%8D%E7%AB%AF%E5%A4%84%E7%90%86EXCEL%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE%E6%80%9D%E8%B7%AF/","excerpt":"","text":"目的在于减轻服务端压力 一部份数据转换方法前端处理后再传给服务端存库 通过xlsx包 可以实现一些快速 一、读取File中的数据，转换为JSON12345678910111213141516// utils 使用JS原生方法将文件按照二进行读取export function readFile()&#123; return new Promise((resolve,reject)=&gt;&#123; let reader = new FileReader(); reader.readAsBinaryString(file); reader.onload = ev =&gt;&#123; resolve(ev.target.result); &#125; &#125;)&#125;// 读取file中的数据 变为JSON格式import xlsx from 'xlsx'let data = await readFile(file);let workbook = xlsx.read(data,&#123;type:\"binary\"&#125;);let worksheet = workbook.Sheets[workbook.SheetNames[0]];data = xlsx.utils.sheet_to_json(worksheet); 二、把JSON转化为符合接口格式的数据1234567891011121314151617181920212223242526272829303132333435363738// JSON转为提交服务端的格式let arr = [];data.forEach(item=&gt;&#123; let obj = &#123;&#125;; for(let key in character)&#123; if(!character.hasOwnProperty(key)) return; let v=character[key], text = v.text, type = v.type; v = item[text] || ''; type === 'string' ? (v = String(v)) : null; type === 'number' ? (v = Number(v)) : null; obj[key] = v; &#125; arr.push(obj);&#125;)await delay(100);this.show = true; //显示视图// utils 字段对应表export const character = &#123; name:&#123; text:'姓名', type:'string' &#125;, phone:&#123; text:'电话', type:'number' &#125;&#125;// utils设置异步就间隔延迟 可用于防抖export function delay(interval = 0)&#123; return new Promise((resolve,reject)=&gt;&#123; let timer = setTimeout(_=&gt;&#123; clearTimeout(timer); resolve(); &#125;,interval) &#125;&#125; 三、导出1234567891011let arr = this.selection.map(item=&gt;&#123; return &#123; 编号:item.id, 姓名:item.name, 电话:item.phone &#125;&#125;)let sheet = xlsx.utils.json_to sheet(arr);let book = xlsx.utils.book_new();xlsx.utils.book_append_sheet(book,sheet,'sheet1');xlsx.writeFile(book,'file.xls'); 四、xlsx 核心源码https://github.com/SheetJS/sheetjs/blob/master/dist/xlsx.js","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"xlsx","slug":"xlsx","permalink":"http://yoursite.com/tags/xlsx/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"前端周刊【202008-1】","slug":"weeks/2020/202008-1","date":"2020-08-08T12:42:04.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/08/08/weeks/2020/202008-1/","link":"","permalink":"http://yoursite.com/2020/08/08/weeks/2020/202008-1/","excerpt":"","text":"你或许不知道Vue的这些小技巧 Vue 数组/对象更新 视图不更新 this.$set(你要改变的数组/对象，你要改变的位置/key，你要改成什么value) vue filters 过滤器的使用 1234567891011121314151617181920&lt;!-- 在双花括号中 --&gt;&#123;&#123; message | filterTest &#125;&#125;&lt;!-- 在 `v-bind` 中 --&gt;&lt;div :id=\"message | filterTest\"&gt;&lt;/div&gt;export default &#123; data() &#123; return &#123; message:1 &#125; &#125;, filters: &#123; filterTest(value) &#123; // value在这里是message的值 if(value===1)&#123; return '最后输出这个值'; &#125; &#125; &#125;&#125; 深度watch与watch立即触发回调 选项：deep 在选项参数中指定 deep: true，可以监听对象中属性的变化。 选项：immediate 在选项参数中指定 immediate: true, 将立即以表达式的当前值触发回调，也就是立即触发一次。 123456789101112131415watch: &#123; obj: &#123; handler(val, oldVal) &#123; console.log('属性发生变化触发这个回调',val, oldVal); &#125;, deep: true // 监听这个对象中的每一个属性变化 &#125;, step: &#123; // 属性 //watch handler(val, oldVal) &#123; console.log(\"默认立即触发一次\", val, oldVal); &#125;, immediate: true // 默认立即触发一次 &#125;,&#125;, [vue-cli2升级webpack4]","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"手写ToyReact笔录 JSX+生命周期+虚拟DOM [未完]","slug":"frame/react/ToyReact","date":"2020-08-04T14:42:04.000Z","updated":"2022-06-05T14:08:41.965Z","comments":true,"path":"2020/08/04/frame/react/ToyReact/","link":"","permalink":"http://yoursite.com/2020/08/04/frame/react/ToyReact/","excerpt":"","text":"JSX原理浅析1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// ToyReact.jsclass Wrapper&#123; constructor(content)&#123; this.root = document.createElement(content) &#125; setAttribute(name,value)&#123; this.root.setAttribute(name,value) &#125; appendChild(vchild)&#123; vchild.mountTo(this.root) &#125; mountTo(parent) &#123; parent.appendChild(this.root) &#125;&#125;class TextWrapper&#123; constructor(content)&#123; this.root = document.createTextNode(content) &#125; mountTo(parent) &#123; parent.appendChild(this.root) &#125;&#125;export class Component&#123; setAttribute(name, value)&#123; this[name] = value; &#125; mountTo(parent)&#123; let vdom = this.render() vdom.mountTo(parent) &#125;&#125;export let ToyReact = &#123; createElement(type,attributes,...children)&#123; let element if(typeof type === 'string') element = new Wrapper(type) else element = new type for(let name in attributes)&#123; element.setAttribute(name,attributes[name]) &#125; let insertChildren=(children)=&gt;&#123; for(let child of children)&#123; if(typeof child === 'object' &amp;&amp; child instanceof Array)&#123; insertChildren(child) &#125;else&#123; if(!(child instanceof Component) &amp;&amp; !(child instanceof Wrapper) &amp;&amp; !(child instanceof TextWrapper))&#123; child = String(child) &#125; if(typeof child === 'string') child = new TextWrapper(child); element.appendChild(child) &#125; &#125; &#125; insertChildren(children) return element &#125;, render(vdom, element)&#123; vdom.mountTo(element) &#125;&#125;// main.jsimport &#123;ToyReact,Component&#125; from './ToyReact'class MyComponent extends Component&#123; render()&#123; return &lt;div&gt; &lt;span&gt;dog&lt;/span&gt; &lt;span&gt;cat&lt;/span&gt; &lt;div&gt;&#123;true&#125;&lt;/div&gt; &lt;/div&gt; &#125;&#125;let a = &lt;MyComponent name=\"a\" id=\"aaa\"&gt;&lt;/MyComponent&gt;ToyReact.render( a, document.body) 生命周期原理虚拟DOM原理main.js ToyReact.js","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"JSX","slug":"JSX","permalink":"http://yoursite.com/tags/JSX/"},{"name":"vdom","slug":"vdom","permalink":"http://yoursite.com/tags/vdom/"}]},{"title":"Vue2 + Webpack3 打包压缩及缓存优化相关方案","slug":"frame/vue/Vue2+Webpack3 打包优化","date":"2020-08-04T10:42:04.000Z","updated":"2022-06-05T14:08:41.965Z","comments":true,"path":"2020/08/04/frame/vue/Vue2+Webpack3 打包优化/","link":"","permalink":"http://yoursite.com/2020/08/04/frame/vue/Vue2+Webpack3%20%E6%89%93%E5%8C%85%E4%BC%98%E5%8C%96/","excerpt":"","text":"一、开启gzip * 客户端访问资源时，服务端先对资源进行压缩，再返回 客户端自动解压，无需另行处理 12345678910111213141516171819// vue2.6 + webpack3 只能配置compression-webpack-plugin1.1.12npm install --save-dev compression-webpack-plugin@1.1.12// webpack4 需要配置更高版本compression-webpack-pluginvar CompressionWebpackPlugin = require('compression-webpack-plugin')if (config.build.productionGzip) &#123; webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125; 部署 12345678910111213141516171819// 直接使用压缩后的文件http &#123; # 开启gzip gzip on; gzip_static on;&#125;//不使用webpack打包后的.gz文件，客户端访问资源时再压缩 会造成一定的解压性能消耗http &#123; gzip on; gzip_static on; gzip_min_length 10k; gzip_buffers 4 16k; gzip_comp_level 8; # 根据需要添加文件类型 gzip_types application/javascript text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png; gzip_vary off; gzip_disable \"MSIE [1-6]\\.\";&#125; 开启gzip_static 的问题 通过nginx配置开启解压缩静态文件gzip_static on后，启动nginx会提示nginx: [emerg] unknown directive &quot;gzip_static&quot; in，访问页面会发现有些js找不到，在目录下查找文件时发现是已gz结尾的，系统没有自动识别解压。此时可用在nginx的安装目录的sbin中使用./nginx -V查看当前nginx的配置信息，看有没有配置--with-http_gzip_static_module通过以上信息中的configure arguments看出我们没有配置该信息。这时需要我们进入原来的nginx解压的目录中，进行配置并重新安装。 123456## NGINX安装包下配置./configure --prefix=/usr/local/nginx --with-http_gzip_static_module## 重新安装make &amp;&amp; make install## 重载NGINX./nginx -s reload 二、引入外部库CDN 图床 七牛部分依赖无需webpack打包处理 index.html引入 静态资源或cdn资源 若是static引入效果不明显 外网项目使用CDN时优选此方案 * 1234567891011// webpack.base.conf.js 设置打包忽略externals: &#123; 'vue' : 'Vue', 'vue-router':'VueRouter', 'vuex':'Vuex', 'axios':'axios', 'element-ui':'ElementUI', 'mockjs': 'Mock', 'echarts': 'echarts', 'ueditor': 'UE' &#125; 三、缓存处理1、Hash hash是跟整个项目的构建相关，只要项目里有文件更改，整个项目构建的hash值都会更改，并且全部文件都共用相同的hash值 2、chunkhash chunkhash，它根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。 简单来说这种是根据不同入口来配置的，比如vue-router、vuex、vue等公共入口文件，只要这些没有改变，那么他对应生成的js的hash值也不会改变。 3、contenthash contenthash主要是处理关联性，比如一个js文件中引入css，但是会生成一个js文件，一个css文件，但是因为入口是一个，导致他们的hash值也相同，所以当只有js修改时，关联输出的css、img等文件的hash值也会改变，这种情况下就需要contenthash了。 12345678910111213// webpack.prod.conf.js// 1 使用hash而不是chunkhash 2 时间戳是为了避免源码无改动下的多次构建var timeString = new Date().getTime()output: &#123; path: config.build.assetsRoot, filename: utils.assetsPath('js/[name].[hash].'+timeString+'.js'), chunkFilename: utils.assetsPath('js/[id].[hash].'+timeString+'.js'), publicPath: config.build.assetsPublicPath&#125; new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[hash].'+timeString+'.css')&#125;) 设置HTML强制清除缓存 （谷歌火狐某些版本会自动忽略此设置 无效） 1234567// index.html // 通知浏览器 页面不缓存 但存在兼容性问题 谷歌之类的无效 // 或者会被NGINX服务端的一些配置盖掉&lt;meta http-equiv=\"Pragram\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Cache-control\" content=\"no-cache, no-store, must-revalidate\"&gt;&lt;meta http-equiv=\"Cache\" content=\"no-cache\"&gt;&lt;meta http-equiv=\"Expires\" content=\"0\"&gt; nginx 服务器强制清理缓存 12345678910location / &#123; #proxy_cache ... #如果expires 和 add_header 同时开启的情况下，则add_header优于expires生效 #Cache-Control比Expires可以控制的多一些， 而且Cache-Control会重写Expires的规则 #设置禁止浏览器缓存，每次都从服务器请求 add_header Cache-Control no-cache; add_header Cache-Control private; #设置缓存上面定义的后缀文件缓存到浏览器的生存时间 expires -1s;&#125; 设置缓存 12345# 设置服务器内存缓存open_file_cache max=2000 inactive=20s;open_file_cache_valid 60s;open_file_cache_min_uses 5;open_file_cache_errors off; 四、升级webpack4…待完善 webpack4对打包构建提速有明显的效果 目前受限于浏览器兼容的影响 未升级w4 有兴趣可百度研究","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"gzip","slug":"gzip","permalink":"http://yoursite.com/tags/gzip/"}]},{"title":"落地微前端","slug":"basic/js/落地微前端","date":"2020-08-03T12:42:04.000Z","updated":"2022-06-05T14:08:41.950Z","comments":true,"path":"2020/08/03/basic/js/落地微前端/","link":"","permalink":"http://yoursite.com/2020/08/03/basic/js/%E8%90%BD%E5%9C%B0%E5%BE%AE%E5%89%8D%E7%AB%AF/","excerpt":"","text":"一、概述2018年 Single-SPA诞生了， single-spa 是一个用于前端微服务化的 JavaScript 前端解决方案 (本身没有处理样式隔离， js 执行隔离) 实现了路由劫持和应用加载。 2019年 qiankun 基于Single-SPA, 提供了更加开箱即用的 API （ single-spa + sandbox+ import-html-entry ） 做到了，技术栈无关、并且接入简单（像i frame 一样简单） 总结：子应用可以独立构建，运行时动态加载,主子应用完全解耦，技术栈无关，靠的是协议接入（子应用必须导出 bootstrap、mount、unmount方法） 微前端架构核心价值 技术栈无关主框架不限制接入应用的技术栈，微应用具备完全自主权 独立开发、独立部署微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新 增量升级在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略 独立运行时每个微应用之间状态隔离，运行时状态不共享 应用通信 基于URL来进行数据传递，但是传递消息能力弱 基于 CustomEvent 实现通信 基于props主子应用间通信 使用全局变量、 Redux 进行通信 公共依赖 CDN - externals webpack 联邦模块 二、single-spa1.构建子应用123456789101112131415161718192021222324252627import singleSpaVue from 'single-spa-vue';const appOptions = &#123; el: '#vue', router, render: h = &gt;h(App)&#125;// 在非子应用中正常挂载应用 if (!window.singleSpaNavigate) &#123; delete appOptions.el; new Vue(appOptions).$mount('#app');&#125;const vueLifeCycle = singleSpaVue(&#123; Vue, appOptions&#125;);// 子应用必须导出 以下生命周期 bootstrap、mount、unmount export const bootstrap = vueLifeCycle.bootstrap;export const mount = vueLifeCycle.mount;export const unmount = vueLifeCycle.unmount;export default vueLifeCycle;const router = new VueRouter(&#123; mode: 'history', base: '/vue', routes&#125;) 2.配置库打包 (将子模块打包成类库)1234567891011module.exports = &#123; configureWebpack: &#123; output: &#123; library: 'singleVue', libraryTarget: 'umd' &#125;, devServer: &#123; port: 10000 &#125; &#125;&#125; 3.主应用搭建(将子应用挂载到 id=”vue” 标签中)1234567891011121314151617181920212223242526272829import Vue from 'vue'import App from './App.vue'import router from './router'import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI);const loadScript = async(url) = &gt;&#123; await new Promise((resolve, reject) = &gt;&#123; const script = document.createElement('script'); script.src = url; script.onload = resolve; script.onerror = reject; document.head.appendChild(script) &#125;);&#125;import &#123; registerApplication, start&#125; from 'single-spa';registerApplication('singleVue', async() = &gt;&#123; await loadScript('http://localhost:10000/js/chunk-vendors.js'); await loadScript('http://localhost:10000/js/app.js'); return window.singleVue&#125;,location = &gt;location.pathname.startsWith('/vue')) start();new Vue(&#123; router, render: h = &gt;h(App)&#125;).$mount('#app') 4.动态设置子应用 publicPath123if (window.singleSpaNavigate) &#123; __webpack_public_path__ = 'http://localhost:10000/'&#125; 三、qiankun1.主应用12345678910111213141516171819// qiankun.config.jsimport &#123; registerMicroApps, start&#125;from 'qiankun'const apps = [&#123; name: 'vueApp', entry: '//localhost:10000', container: '#vue', activeRule: '/vue'&#125;,&#123; name: 'reactApp', entry: '//localhost:20000', container: '#react', activeRule: '/react'&#125;] registerMicroApps(apps);start(); 2.子应用 vue1234567891011121314151617181920let instance = null;function render() &#123; instance = new Vue(&#123; router, render: h = &gt;h(App) &#125;).$mount('#app')&#125;if (window.__POWERED_BY_QIANKUN__) &#123; __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;&#125;if (!window.__POWERED_BY_QIANKUN__) &#123; render()&#125;export async function bootstrap() &#123;&#125;export async function mount(props) &#123; render();&#125;export async function unmount() &#123; instance.$destroy();&#125; 123456789101112131415// 打包配置module.exports = &#123; devServer: &#123; port: 10000, headers: &#123; 'Access-Control-Allow-Origin': '*' &#125; &#125;, configureWebpack: &#123; output: &#123; library: 'vueApp', libraryTarget: 'umd' &#125; &#125;&#125; 3.子应用react1234567891011121314151617import React from 'react';import ReactDOM from 'react-dom';import './index.css';import App from './App';function render() &#123; ReactDOM.render( &lt; React.StrictMode &gt; &lt;App / &gt;&lt;/React.StrictMode&gt;, document.getElementById('root') ); &#125;if(!window.__POWERED_BY_QIANKUN__)&#123; render() &#125;export async function bootstrap() &#123;&#125; export async function mount() &#123;render();&#125; export async function unmount() &#123; ReactDOM.unmountComponentAtNode(document.getElementById(\"root\")); &#125; 重写 react 中的 webpack 配置文件 ( config-overrides.js )yarn add react-app-rewired –save-dev 1234567891011121314151617module.exports = &#123; webpack: (config) = &gt;&#123; config.output.library = `reactApp`; config.output.libraryTarget = \"umd\"; config.output.publicPath = 'http://localhost:20000/' return config &#125;, devServer: function(configFunction) &#123; return function(proxy, allowedHost) &#123; const config = configFunction(proxy, allowedHost); config.headers = &#123; \"Access-Control-Allow-Origin\": \"*\", &#125;; return config; &#125;; &#125;,&#125;; 配置 .env 文件 12PORT=20000 WDS_SOCKET_PORT=20000 React路由配置 12345678910import &#123; BrowserRouter, Route, Link&#125; from \"react-router-dom\"const BASE_NAME = window.__POWERED_BY_QIANKUN__ ? \"/react\": \"\";function App() &#123; return ( &lt; BrowserRouter basename = &#123; BASE_NAME &#125; &gt; &lt;Link to = \"/\" &gt; 首页 &lt; /Link&gt; &lt;Link to=\"/about \"&gt;关于&lt;/Link&gt; &lt;Route path=\" / \" exact render=&#123;() =&gt; &lt;h1&gt;hello home&lt;/h1&gt;&#125;&gt;&lt;/Route&gt; &lt;Route path=\" / about \" render=&#123;() =&gt; &lt;h1&gt;hello about&lt;/h1&gt;&#125;&gt;&lt;/Route&gt; &lt;/BrowserRouter&gt; ); &#125;\" 四、CSS隔离方案子应用之间样式隔离 Dynamic Stylesheet 动态样式表，当应用切换时移除老应用样式，添加新应用样式 主应用和子应用之间的样式隔离 BEM (Block Element Modifier) 约定项目前缀 CSS-Modules 打包时生成不冲突的选择器名 Shadow DOM 真正意义上的隔离 css-in-js 五、沙箱机制 快照沙箱，在应用沙箱挂载或卸载时记录快照，在切换时依据快照恢复环境 (无法支持多实 例) Proxy 代理沙箱,不影响全局环境","categories":[],"tags":[{"name":"single-spa","slug":"single-spa","permalink":"http://yoursite.com/tags/single-spa/"},{"name":"qiankun","slug":"qiankun","permalink":"http://yoursite.com/tags/qiankun/"}]},{"title":"快手大前端 08/01","slug":"others/20200801快手大前端分享","date":"2020-08-01T10:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/08/01/others/20200801快手大前端分享/","link":"","permalink":"http://yoursite.com/2020/08/01/others/20200801%E5%BF%AB%E6%89%8B%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%88%86%E4%BA%AB/","excerpt":"","text":"快手直播观后感《前端高可用性保障实践》可用性方案设计一、页面功能可用性保障 技术选型 动态配置能力 请求压力 降级限流 埋点监控 二、基础服务保障 1.Nodejs服务可用性 压力评估 GPS 8020、业务模型、春晚模型 服务优化 缓存优化、连接优化、接口代理优化、日志优化 健康检查 node服务可用性检查、API可性检查、硬件配置检查、报警检查 容灾互备 多机器、异地多机房 2.Nginx 负载能力：https握手优化 ssl_session_ticket 分级限流 缓存代理 proxy_cache 预压缩 gzip实时压缩、brotli实时压缩、gzip预压缩、brotli预压缩、 容灾互备 多机器、异地多机房 3.CDN 压力评估 边缘节点预更新 多cdn调度 错误重试 三、完整链路可用性 内部服务依赖：风险控制、数据统计、内容审核、帐号、支付提现 外部服务依赖：分享、短信验证、CDN、三方登录 可用性验证压力测试 单功能点压测 全链路压测 功能修改后重新压测 故障演练 模拟真实会发生的故障 检查相关降级 熔断流程是否触发正常 是否有相关报警 线上预演 整体流程演练 容量推算 如何保障前端可用性？一、规范的开发流程 技术选项、代码准入规范、安全检查、测试上线流程、降级流程 二、完善基础服务的支持 端能力：预加载、通信通道、性能优化 中台能力：分享、支付 、提现、埋点 工程架构：可扩展性 可伸缩性 三、高效的监控排障能力 可用性指标体系、业务指标监控、性能指标监控、分级监控规范 四、定期总结演练 提升重视程度、团队练兵、故障操作手册、总结反思提高 《点到面 如何系统化的解决工程问题》一、开发流程的提效web-ops 泛域名打通nginx+端口自动分配 环境隔离 进行BASE IMAGE的进一步隔离 类n8n式的ci组合 权限管理 构建完成通知 二、monorepo的落地实践 思考：单业务逻辑内的复用、多业务逻辑内的复用、单工程、多工程、开源 三、Open Tracing的Web化场景落地 ![image-20200803211547074](/Users/marong/Library/Application Support/typora-user-images/image-20200803211547074.png)","categories":[],"tags":[]},{"title":"JavaScript语言精髓与编程实践 第3版 绿皮书 [未完]","slug":"book/2020/JS语言精髓与编程实践","date":"2020-07-31T12:42:04.000Z","updated":"2022-06-05T14:08:41.956Z","comments":true,"path":"2020/07/31/book/2020/JS语言精髓与编程实践/","link":"","permalink":"http://yoursite.com/2020/07/31/book/2020/JS%E8%AF%AD%E8%A8%80%E7%B2%BE%E9%AB%93%E4%B8%8E%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"第 1 章 二十年来的 JavaScript省略… 第 2 章 JavaScript 的语法2.1 语法综述语法：语法关键字、变量常量、绑定 2.2 JavaScript 的语法：声明 2.2.2 变量声明 45 2.2.4 其他声明 53 2.2.4.1 常量声明 ..53 2.2.4.2 符号声明 ..54 2.2.4.3 函数声明 ..55 2.3 JavaScript 的语法：表达式运算 2.3.1 一般表达式运算 …..59 2.3.2 比较运算 61 2.3.3 赋值运算 67 2.3.4 函数相关的表达式 .6 2.3.5 特殊作用的运算符 .72 2.3.6 运算优先级 …76 2.4 JavaScript 的语法：语句 2.4.1 表达式语句 …80 2.4.2 变量声明语句 ..86 2.4.3 分支语句 87 2.4.4 循环语句 89 2.4.5 流程控制：一般子句 ….91 2.4.6 流程控制：异常 …..96 2.5 JavaScript 的语法：模块 2.5.1 模块的声明与加载 .98 2.5.2 名字空间的特殊性 ……101 2.6 严格模式下的语法限制 2.6.1 语法限制 2.6.2 执行限制 …..108 2.6.3 严格模式的范围 … 110 2.7 运算符的二义性 2.7.1 加号“+”的二义性 …. 114 2.7.2 括号“( )”的二义性 … 114 2.7.3 冒号“:”与标签的二义性 116 2.7.4 大括号“{ }”的二义性 ….. 117 2.7.5 逗号“,”的二义性 …..122 2.7.6 方括号“[ ]”的二义性 ……123 2.7.7 语法设计中对二义性的处理…..127 第 3 章 JavaScript 的面向对象语言特性3.1 面向对象编程的语法概要 ……130 3.1.1 对象声明与实例创建 ..132 3.1.2 使用类继承体系 …141 3.1.3 对象成员 …..147 3.1.4 使用对象自身 157 3.1.5 符号 ……158 3.2 JavaScript 的原型继承 ……161 3.2.1 空（null）与空白对象（empty） ……161 3.2.2 原型链的维护 171 3.2.3 原型继承的实质 …175 3.3 JavaScript 的类继承 179 3.3.1 类是静态的声明 …179 3.3.2 super 是全新的语法元素 ….181 3.3.3 类是用构造器（函数）来实现的 189 3.3.4 父类的默认值与 null 值 …..192 3.4 JavaScript 的对象系统 ……196 3.4.1 封装与多态 .196 3.4.2 属性 ……201 3.4.3 构造对象系统的方法 ..206 3.4.4 内置的对象系统 …214 3.4.5 特殊效果的继承 …226 3.5 可定制的对象属性 .229 3.5.1 属性描述符 .230 3.5.2 定制对象属性 233 3.5.3 属性表的状态 239 3.6 运行期侵入与元编程系统 ……242 3.6.1 关于运行期侵入 …243 3.6.2 类类型与元类继承 ……257 3.6.3 元编程模型 .266 第 4 章 JavaScript 语言的结构化4.1 概述 ….269 4.1。1 命令式语言 .270 4.1.2 面向对象语言 275 4.1.3 再论语言的分类 …281 4.1.4 JavaScript 的语源 ..283 4.2 基本的组织元素 …..284 4.2.1 标识符 ..285 4.2.2 表达式 ..286 4.2.3 语句 ……288 4.2.4 模块 ……289 4.2.5 组织的原则 .290 4.3 声明 ….294 4.3.1 声明名字 …..295 4.3.2 确定性 ..296 4.3.3 顶层声明 …..297 4.4 语句与代码分块 …..300 4.4.1 块 …301 4.4.2 块与语句的语法结构 ..303 4.4.3 块与声明语句 309 4.4.4 块与语句的值 312 4.5 组织形式分块的方法 318 4.5.1 词法作用域 .319 4.5.3 词法作用域之间的相关性 .336 4.5.4 执行流程变更的内涵 ..337 4.6 层次结构程序设计 .340 4.6.1 属性的可见性 341 4.6.2 多态的逻辑 .343 4.6.3 私有作用域的提出 ……347 4.7 历史遗产：变量作用域 …349 4.7.1 变量作用域 .350 4.7.2 变量的特殊性与变量作用域的关系 353 4.8 私有属性与私有字段的纷争356 4.8.1 私有属性的提出 357 4.8.2 从私有属性到私有成员 361 4.8.3 “类字段”提案的实现概要364 4.8.4 “私有属性”提案的设计与提议 368 4.8.5 “私有属性”提案的实现 .373 第 5 章 JavaScript 的函数式语言特性 ….. 381 5.1 概述 ….381 5.1.1 从代码风格说起 …382 5.1.2 为什么常见的语言不赞同连续求值 …383 5.1.3 函数式语言的渊源 ……384 5.2 从运算式语言到函数式语言…386 5.2.1 JavaScript 中的几种连续运算 …386 5.2.2 如何消灭语句 391 5.2.3 运算式语言 .394 5.2.4 重新认识函数 397 5.2.5 函数式语言 .401 5.3 JavaScript 中的函数 405 5.3.1 参数 ……405 5.3.2 函数 ……418 5.3.3 函数的数据性质 …431 5.3.4 函数与逻辑结构 …439 5.4 函数的行为 ……443 5.4.1 构造 ……444 5.4.2 调用 ……448 5.4.3 方法调用 …..455 5.4.4 迭代 ……461 5.4.5 生成器中的迭代 …466 5.5 闭包 ….475 5.5.1 闭包与函数实例 …476 5.5.2 闭包的使用 .481 5.5.3 与闭包类似的实例化环境 .487 5.5.4 与闭包相关的一些特性 …..496 第 6 章 JavaScript 的动态语言特性6.1 概述 ….506 6.1.1 动态数据类型的起源 ..507 6.1.2 动态执行系统 507 6.1.3 脚本系统的起源 …509 6.1.4 脚本只是表现形式 ……510 6.2 动态类型：对象与值类型之间的转换 .512 6.2.1 包装类：面向对象的妥协 .512 6.2.2 从对象到值 .520 6.2.3 显式的转换 .529 6.3 动态类型：值类型的转换 ……532 6.3.1 值运算：类型转换的基础 .532 6.3.2 值类型之间的转换 ……535 6.3.3 值类型之间的显式转换 …..540 6.4 动态类型：对象与数组的动态特性 …..545 6.4.1 关联数组与索引数组 ..545 6.4.2 索引数组作为对象的问题 .546 6.4.3 类数组对象：对象作为索引数组的应用 ..552 6.4.4 其他 ……554 6.5 重写 ….555 6.5.1 标识符的重写及其限制 …..555 6.5.2 原型重写 …..567 6.5.3 构造器重写 .569 6.5.4 对象成员的重写 …573 6.5.5 引擎对重写的限制 ……578 6.6 动态执行 …582 6.6.1 eval()作为函数名的特殊性 582 6.6.2 eval()在不同上下文环境中的效果 …..584 6.6.3 Eval 环境的独特性 ……586 6.6.4 动态执行过程中的语句、表达式与值 ……593 6.6.5 序列化与反序列化 ……595 6.6.6 eval 对作用域的影响 …600 6.6.7 其他的动态执行逻辑 ..601 6.7 动方法调用（call、apply 与 bind） .605 6.8 通用执行环境的实现 615 6.8.1 通用 DSL 的模型 ..616 6.8.2 实现 ECMAScript 引擎 ……624 6.8.3 与 DSL 的概念整合 …..635 第 7 章 JavaScript 的并行语言特性7.1 概述 7.1.1 并行计算的思想 7.1.2 并行程序设计的历史 7.1.3 并行语言特性在 JavaScript 中的历史 7.2 Promise 的核心机制 7.2.1 Promise 的核心过程 7.2.2 Promise 类与对象的基本应用 7.2.3 Promise 的子类 7.2.4 执行逻辑 …..666 7.2.4.1 任务队列 666 7.2.4.2 执行栈 ….667 7.3 与其他语言特性的交集 …668 7.3.1 与函数式特性的交集：异步的函数 …669 7.3.2 与动态特性的交集 ……677 7.3.3 对结构化特性带来的冲击 .683 7.3.3.4 异步方法与存取器 …..687 7.4 JavaScript 中对并发的支持 …..690 7.4.1 Agent、Agent Cluster 及其工作机制 ..691 7.4.2 SharedArrayBuffer 698 7.4.3 Atomics.701 7.5 在分布式网络环境中的并行执行 ..706 7.5.2 构建一个集群环境 ……709 7.5.3 使用 PEDT 执行行任务 .713 7.5.4 可参考的意义 718","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"前端周刊【202007-5】","slug":"weeks/2020/202007-5","date":"2020-07-31T12:42:04.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/07/31/weeks/2020/202007-5/","link":"","permalink":"http://yoursite.com/2020/07/31/weeks/2020/202007-5/","excerpt":"","text":"10 个最佳 CSS 动画库 EggCluster 是如何解决多进程模式下相关问题的","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"vue3 + vite + ts  从无到有 造轮子","slug":"frame/vue/vue3造轮子","date":"2020-07-31T10:42:04.000Z","updated":"2022-06-05T14:08:41.965Z","comments":true,"path":"2020/07/31/frame/vue/vue3造轮子/","link":"","permalink":"http://yoursite.com/2020/07/31/frame/vue/vue3%E9%80%A0%E8%BD%AE%E5%AD%90/","excerpt":"","text":"一、创建项目12npm init vite-app &lt;project&gt;npm install &amp; npm run dev 安装VSCODE插件Snippets 定义vue解析文件123456// config.d.tsdeclare module '*.vue' &#123; import &#123;ComponentOptions&#125; from 'vue' const component : ComponentOptions export default component&#125; vue-router@4yarn add vue-router@4.0.0-beta3 123456789101112131415161718import &#123; createApp &#125; from 'vue'import App from './App.vue'import '../assets/css/index.css'import &#123;createWebHashHistory,createRouter&#125; from 'vue-router'import Frank from '../components/Frank.vue'const history = createWebHashHistory()const router = createRouter(&#123; history, routes:[ &#123; path:'/', component:Frank &#125; ]&#125;)const app = createApp(App)app.use(router)app.mount('#app') sassyarn add sass@1.26.10 -D 二、2和3的一些小知识 90%的写法一致 3支持template支持多个根标签 2不支持 3有createApp(组件) 2是new Vue({template,render}) 新v-model代替以前的v-model 和.sync 新增context.emit 三、组件轮子相关通信 Provide Inject123456789101112131415import &#123; ref, provide&#125; from 'vue'export default &#123; setup()&#123; const menu = ref(false) provide('xxx',menu) // set &#125;&#125;import &#123;inject,Ref&#125; from 'vue'export default &#123; setup()&#123; const menu = inject&lt;Ref&lt;boolean&gt;&gt;('xxx') // get console.log(menu) &#125;&#125; 通信$event 和 context.emit1234567891011121314//父&lt;Switch :value=\"y\" v-model:value=\"y\"&gt;&lt;/Switch&gt;//子props: &#123; value: Boolean&#125;,setup(props,context) &#123;// 初始化 const toggle = () =&gt;&#123; // 重点vue3改变 update:value context.emit('update:value',!props.value) &#125; return &#123;toggle&#125;&#125; 使用REF创建内部数据1234567import &#123;ref&#125; from 'vue'export default &#123; setup()&#123; const menu = ref(false) console.log(menu) &#125;&#125; 四、属性绑定 默认属性都绑定到根元素 使用inheritAttrs:false可取消默认绑定 使用$attrs或者 context.attrs获取所有属性 使用v-bind=“$attr”批量绑定属性 使用const {size,…rest} = context.attrs 将属性分开 props vs attrs props要先声明才能取值，attrs不用 props不包含事件,attrs包含 props支持string以外的类型，attrs只有string类型 可以将proxy转对象来打印 console.log({…props}) 12345678910111213141516&lt;template&gt; &lt;div :size=\"size\"&gt; &lt;button v-bind=\"rest\"&gt; &lt;slot /&gt; &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=\"ts\"&gt;export default &#123; inheritAttrs:false, setup(props,context)&#123; const &#123;size,...rest&#125; = context.attrs return &#123;size,rest&#125; &#125;&#125;&lt;/script&gt; 库 CSS 的两个注意事项 不能使用scoped 因为data-v-xxx中xx每次不同 必须输出稳定不变的class选择器，方便使用者覆盖 必须加前缀 .button .gulu-button 前者更容易比后者被使用者覆盖 .theme-link .gulu-theme-link 前者更容易比后者被使用者覆盖 CSS最小影响原则1234[class^=\"gulu-\"],[class*=\" gulu-\"]&#123; // ^= 属性以什么开着 第二个第三个值*=含有 margin:0;padding:0;box-sizing:border-box;&#125; 组件的小思路12345678910&lt;Button @click=\"onClick\" @focus=\"onClick\" @mouseover=\"onClick\" size=\"small normal big\" theme=\"button link text\" level=\"main normal minor\" disabled loading /&gt; 五、插槽1&lt;template v-slot:header&gt;&lt;/template&gt; 六、TeleportTeleport（以前称为Portal）是将子节点渲染到DOM谱系之外的DOM节点中的安全通道，例如弹出窗口甚至是模式。在此之前，使用CSS通常会遇到很多麻烦，现在Vue允许您使用在模板部分中进行处理。 123456789101112&lt;teleport to=\"#modals\"&gt; &lt;div&gt;A&lt;/div&gt;&lt;/teleport&gt;&lt;teleport to=\"#modals\"&gt; &lt;div&gt;B&lt;/div&gt;&lt;/teleport&gt; &lt;!-- result--&gt;&lt;div id=\"modals\"&gt; &lt;div&gt;A&lt;/div&gt; &lt;div&gt;B&lt;/div&gt;&lt;/div&gt; 七、Suspense12345678&lt;Suspense&gt; &lt;template&gt; &lt;Suspended-component /&gt; &lt;/template&gt; &lt;template #fallback&gt; Loading... &lt;/template&gt;&lt;/Suspense&gt; 八、小技巧函数?表达式用法12if(props.ok?.() !==false)&#123;&#125;// ok是个function 为真 默认执行 返回值与false对比 样式设置12:class=&#123;selected: key ==='1'&#125;&lt;div class=\"selected\"&gt;&lt;/div&gt; REF123456// ref&lt;div :ref=\"ref =&gt;&#123; if(el) navItems[index] &#125;\"/&gt;const navItems = ref([])onMounted(()=&gt;&#123; navItems.value&#125;) 获取宽高和位置const { width , left } = el.getBoundingClientRect()// 重命名const { left:left1 } = el.getBoundingClientRect() 钩子的含义onMounted onUpdated watchEffect watchEffect() 会在挂载前就会执行，因为 有时候放到onMouned再执行12345onMounted(()=&gt;&#123; watchEffect(()=&gt;&#123; &#125;)&#125;) TS泛型const indicator = ref(null) 九、如何判断子组件的对象类型 用JS获取插槽内容12345678910111213import Tab from './Tab.vue'setup(props,context)&#123; const defaults = const.slots.default() console.log(defaults[0].type === Tab) defaults.forEach((tag)=&gt;&#123; if(tag.type !== Tab)&#123; throw new Error('Tabs的子标签必须是Tab') &#125; &#125;) return&#123; defaults &#125;&#125; 十、一键部署SH1234567891011rm -rf distyarn buildcd distgit initgit add.git commit -m \"update\"git brach -M mastergit remote add origin git@github.com:name/x.gitgit push -f -u origin mastercd -echo http://... 十二、VUE2 = &gt; VUE31、官方中文文档 https://v3.cn.vuejs.org/ 2、工具 vue-codemode 十三、相关报错解决 sass报错 打开 package.json 把 dependencies 里的 sass 这一行，移到 devDependencies 重新运行 yarn install 或者 npm install 即可 报 vue/valid-template-root 错误 这个错是因为 VSCode 的 Vetur 插件还没支持 Vue 3，解决办法是在 VSCode 配置里添加一行 “vetur.validation.template”: false, 来关闭检查。 报 ‘X.vue’ is not a module. Vetur(2306) 错误 解决方法是在 X.vue 中添加一个 即可，内容如下： 123&lt;script&gt;export default &#123;&#125;&lt;/script&gt;","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"vue3","slug":"vue3","permalink":"http://yoursite.com/tags/vue3/"},{"name":"vite","slug":"vite","permalink":"http://yoursite.com/tags/vite/"}]},{"title":"前端周刊【202007-4】","slug":"weeks/2020/202007-4","date":"2020-07-26T12:42:04.000Z","updated":"2022-06-05T14:08:41.967Z","comments":true,"path":"2020/07/26/weeks/2020/202007-4/","link":"","permalink":"http://yoursite.com/2020/07/26/weeks/2020/202007-4/","excerpt":"","text":"2020-2021 设计趋势ISUX报告 · 用户体验篇","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"数据结构与算法Javascript描述","slug":"book/2020/数据结构与算法JS描述","date":"2020-07-24T01:42:04.000Z","updated":"2022-06-05T14:08:41.957Z","comments":true,"path":"2020/07/24/book/2020/数据结构与算法JS描述/","link":"","permalink":"http://yoursite.com/2020/07/24/book/2020/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95JS%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"JavaScript 的编程环境和模型一、数组数组是一种特殊的对象，用来表示偏移量的索引是该对象的属性，索引可 能是整数。 Array.isArray() 来判断一个对象是否是数组 【浅复制】新数组依然指向原来的数组。当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用。当 你通过原引用修改了数组的值，另外一个引用也会感知到这个变化。 1234567var nums = [];for (var i = 0; i &lt; 100; ++i) &#123; nums[i] = i+1;&#125;var samenums = nums;nums[0] = 400;print(samenums[0]); // 显示 400 【深复制】将 原数组中的每一个元素都复制一份到新数组中。 12345678var nums = [];for (var i = 0; i &lt; 100; ++i) &#123; nums[i] = i+1;&#125;var samenums = [];copy(nums, samenums);nums[0] = 400;print(samenums[0]); // 显示 1 存取函数 indexOf() 将数组转化为字符串 join() 、toString() 由已有数组创建新数组 合并concat() 、 截取splice() 可变函数 为数组添加元素 push() 和 unshift() 从数组中删除元素 pop() shift() 从数组中间位置添加和删除元素 splice() 为数组排序 reverse()翻转 sort() 迭代器方法forEach()该方法接受一个函数作为参数，对数组中的每个元素 使用该函数 every() 该方法接受一个返回值为布尔类型的函数，对数组中的每 个元素使用该函数。如果对于所有的元素，该函数均返回 true，则该方法返回 true 123456789101112function isEven(num) &#123; return num % 2 == 0;&#125;var nums = [2,4,6,8,10];var even = nums.every(isEven);if (even) &#123; print(\"all numbers are even\");&#125;else &#123; print(\"not all numbers are even\");&#125;//all numbers are even some() 方法也接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回 true， 该方法就返回 true 123456789101112131415161718192021function isEven(num) &#123; return num % 2 == 0;&#125;var nums = [1,2,3,4,5,6,7,8,9,10];var someEven = nums.some(isEven);if (someEven) &#123; print(\"some numbers are even\");&#125;else &#123; print(\"no numbers are even\");&#125;nums = [1,3,5,7,9];someEven = nums.some(isEven);if (someEven) &#123; print(\"some numbers are even\");&#125;else &#123; print(\"no numbers are even\");&#125;//some numbers are even//no numbers are even reduce() 方法接受一个函数，返回一个值。该方法会从一个累加值开始，不断对累加值和 数组中的后续元素调用该函数，直到数组中的最后一个元素，最后【返回得到的累加值】。 reduceRight() 从右到左执行 123456function add(runningTotal, currentValue) &#123; return runningTotal + currentValue;&#125;var nums = [1,2,3,4,5,6,7,8,9,10];var sum = nums.reduce(add);print(sum); // 显示 55 生成新数组的迭代器方法 map() 和 filter() 12345678910111213141516171819202122232425//map forEach有点像 区别！map() 返回一个新的数组function curve(grade) &#123; return grade += 5;&#125;var grades = [77, 65, 81, 92, 83];var newgrades = grades.map(curve);print(newgrades); // 82, 70, 86, 97, 88//filter() 和 every() 类似，传入一个返回值为布尔类型的函数function isEven(num) &#123; return num % 2 == 0;&#125;function isOdd(num) &#123; return num % 2 != 0;&#125;var nums = [];for (var i = 0; i &lt; 20; ++i) &#123; nums[i] = i+1;&#125;var evens = nums.filter(isEven);print(\"Even numbers: \");print(evens);var odds = nums.filter(isOdd);print(\"Odd numbers: \");print(odds); 二维和多维数组二维数组类似一种由行和列构成的数据表格 对象数组二、列表列表是一组有序的数据。每个列表中的数据项称为元素。 12345678910111213141516//列表的抽象数据类型定义listSize（属性） 列表的元素个数pos（属性） 列表的当前位置length（属性） 返回列表中元素的个数clear（方法） 清空列表中的所有元素toString（方法） 返回列表的字符串形式getElement（方法） 返回当前位置的元素insert（方法） 在现有元素后插入新元素append（方法） 在列表的末尾添加新元素remove（方法） 从列表中删除元素front（方法） 将列表的当前位置设移动到第一个元素end（方法） 将列表的当前位置移动到最后一个元素prev（方法） 将当前位置后移一位next（方法） 将当前位置前移一位currPos（方法） 返回列表的当前位置moveTo（方法） 将当前位置移动到指定位置 三、栈后进先出 栈就是和列表类似的一种数据结构，栈是一种高效的数据结构，因为数据只能在栈顶添加或删除，所以这样的操作很快，而且容易实现。 栈的使用遍布程序语言实现的方方面面，从表达式求值到处理函数调用。 1234567function Stack() &#123; this.dataStore = []; this.top = 0; this.push = push; this.pop = pop; this.peek = peek;&#125; 【回文】是指这样一种现象：一个单词、短语或数字，从前往后写和从后往前写都是一样的。 比如，单词“dad”、“racecar”就是回文；如果忽略空格和标点符号，下面这个句子也是回 文，“A man, a plan, a canal: Panama”；数字 1001 也是回文。 使用栈判断一个单词是否是回文 123456789101112131415161718192021222324252627282930function isPalindrome(word) &#123; var s = new Stack(); for (var i = 0; i &lt; word.length; ++i) &#123; s.push(word[i]); &#125; var rword = \"\"; while (s.length() &gt; 0) &#123; rword += s.pop(); &#125; if (word == rword) &#123; return true; &#125; else &#123; return false; &#125;&#125;var word = \"hello\";if (isPalindrome(word)) &#123; print(word + \" is a palindrome.\");&#125;else &#123; print(word + \" is not a palindrome.\");&#125;word = \"racecar\"if (isPalindrome(word)) &#123; print(word + \" is a palindrome.\");&#125;else &#123; print(word + \" is not a palindrome.\");&#125; 使用栈模拟递归过程 12345678910111213function fact(n) &#123; var s = new Stack(); while (n &gt; 1) &#123; s.push(n--); &#125; var product = 1; while (s.length() &gt; 0) &#123; product *= s.pop(); &#125; return product;&#125;print(factorial(5)); // 显示 120print(fact(5)); // 显示 120 四、队列先进先出 队列是一种列表，不同的是队列只能在队尾插入元素，在队首删除元素。队列用于存储按 顺序排列的数据，先进先出，这点和栈不一样，在栈中，最后入栈的元素反而被优先处 理。 队列是一种先进先出（First-In-First-Out，FIFO）的数据结构。队列被用在很多地方，比如 提交操作系统执行的一系列进程、打印任务池等，一些仿真系统用队列来模拟银行或杂货 店里排队的顾客。 五、链表链表是由一组节点组成的集合。每个节点都使用一个对象的引用指向它的后继。指向另一 个节点的引用叫做链。 双向链表 循环链表 六、字典字典是一种以键 - 值对形式存储数据的数据结构，就像电话号码簿里的名字和电话号码一 样。 Dictionay 类的基础是 Array 类，而不是 Object 类。 七、散列散列是一种常用的数据存储技术，散列后的数据可以快速地插入或取用。散列使用的数据 结构叫做散列表。在散列表上插入、删除和取用数据都非常快，但是对于查找操作来说却 效率低下，比如查找一组数据中的最大值和最小值。 碰撞当散列函数对于多个输入产生同样的输出时，就产生了碰撞。 开链法 开链法是指实现散列表的底层数组中，每个数组 元素又是一个新的数据结构，比如另一个数组，这样就能存储多个键了。 线性探测法 线性探测法隶属于一种更一般化的散列技术：开放 寻址散列。当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空， 就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为 止。该技术是基于这样一个事实：每个散列表都会有很多空的单元格，可以使用它们来存 储数据。 八、集合集合是由一组无序但彼此之间又有一定相关性的成员构成的，每个成员在集合中只能出现 一次。在数学上，用大括号将一组成员括起来表示集合，比如 {0,1,2,3,4,5,6,7,8,9}。集合 中成员的顺序是任意的，因此前面的集合也可以写做 {9,0,8,1,7,2,6,3,5,4}，或者其他任意 形式的组合，但是必须保证每个成员只能出现一次。 不包含任何成员的集合称为空集，全集则是包含一切可能成员的集合。 如果两个集合的成员完全相同，则称两个集合相等。 如果一个集合中所有的成员都属于另外一个集合，则前一集合称为后一集合的子集。 并集、交集、补集 Set类 定义 union()、subset() 和 difference() 九、二叉树树是一种非线性的数据结构，以分层的方式 存储数据。树被用来存储具有层级关系的数据，比如文件系统中的文件；树还被用来存储 有序列表。 二叉树。选择树而不是那些基本的数据结构，是因 为在二叉树上进行查找非常快（而在链表上查找则不是这样），为二叉树添加或删除元素 也非常快（而对数组执行添加或删除操作则不是这样）。 二叉查找树BST相对较小的值保存在左节点中，较大的值保存在右节点中。这一特性使得 查找的效率很高，对于数值型和非数值型的数据，比如单词和字符串，都是如此。 123456789function Node(data, left, right) &#123; this.data = data; this.left = left; this.right = right; this.show = show;&#125;function show() &#123; return this.data;&#125; 查找正确插入点(1) 设根节点为当前节点。(2) 如果待插入节点保存的数据小于当前节点，则设新的当前节点为原节点的左节点；反之，执行第 4 步。(3) 如果当前节点的左节点为 null，就将新的节点插入这个位置，退出循环；反之，继续执行下一次循环。(4) 设新的当前节点为原节点的右节点。(5) 如果当前节点的右节点为 null，就将新的节点插入这个位置，退出循环；反之，继续执行下一次循环。 123456789101112131415161718192021222324252627282930function BST() &#123; this.root = null this.insert = insert this.inOrder = inOrder&#125;function insert(data) &#123; var n = new Node(data, null, null) if (this.root == null) &#123; this.root = n &#125; else &#123; var current = this.root var parent while (true) &#123; parent = current if (data &lt; current.data) &#123; current = current.left if (current == null) &#123; parent.left = n break &#125; &#125; else &#123; current = current.right if (current == null) &#123; parent.right = n break &#125; &#125; &#125; &#125;&#125; 遍历二叉查找树三种遍历 BST 的方式：中序、先序和后序。中序遍历按照节点上的键值，以升序访问 BST 上的所有节点。先序遍历先访问根节点，然后以同样方式访问左子树和右子树。后序 遍历先访问叶子节点，从左子树到右子树，再到根节点。 中序遍历使用递归的方式最容易实现。该方法需要以升序访问树中所有节点，先访问左子 树，再访问根节点，最后访问右子树。 12345678910111213141516171819function inOrder(node) &#123; if (!(node == null)) &#123; inOrder(node.left); putstr(node.show() + \" \"); inOrder(node.right); &#125;&#125;var nums = new BST();nums.insert(23);nums.insert(45);nums.insert(16);nums.insert(37);nums.insert(3);nums.insert(99);nums.insert(22);print(\"Inorder traversal: \");inOrder(nums.root);//Inorder traversal://3 16 22 23 37 45 99 在二叉查找树上进行查找(1) 查找给定值 需要比较该值和当前节点上的值的大小。通过比较，就能确定如果 给定值不在当前节点时，该向左遍历还是向右遍历。 123456789101112131415function find(data) &#123; var current = this.root; while (current != null) &#123; if (current.data == data) &#123; return current; &#125; else if (data &lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return null;&#125; (2) 查找最小值 (3) 查找最大值 从二叉查找树上删除节点从 BST 上删除节点的操作最复杂，其复杂程度取决于删除哪个节点。如果删除没有子节点 的节点，那么非常简单。如果节点只有一个子节点，不管是左子节点还是右子节点，就变得稍微有点复杂了。删除包含两个子节点的节点最复杂。 计数BST 的一个用途是记录一组数据集中数据出现的次数。比 十、图图由边的集合及顶点的集合组成。 顶点也有权重，也称为成本。如果一个 图的顶点对是有序的，则可以称之为有向图。 图是无序的，则称之为无序图，或无向图。 1234567891011function Graph(v) &#123; this.vertices = v; this.edges = 0; this.adj = []; for (var i = 0; I &lt; this.vertices; ++i) &#123; this.adj[i] = []; this.adj[i].push(\"\"); &#125; this.addEdge = addEdge; this.toString = toString;&#125; 搜索图 深度优先搜索和广 度优先搜索 深度优先搜索包括从一条路径的起始顶点开始追溯，直到到达最后一个顶点，然后回溯， 继续追溯下一条路径，直到到达最后的顶点，如此往复，直到没有路径为止。 123456789101112131415161718192021222324252627282930313233343536373839404142function Graph(v) &#123; this.vertices = v; this.edges = 0; this.adj = []; for (var i = 0; i &lt; this.vertices; ++i) &#123; this.adj[i] = []; this.adj[i].push(\"\"); &#125; this.addEdge = addEdge; this.showGraph = showGraph; this.dfs = dfs; this.marked = []; for (var i = 0; i &lt; this.vertices; ++i) &#123; this.marked[i] = false; &#125;&#125;function addEdge(v, w) &#123; this.adj[v].push(w); this.adj[w].push(v); this.edges++;&#125;function showGraph() &#123; for (var i = 0; i &lt; this.vertices; ++i) &#123; putstr(i + \" -&gt; \"); for (var j = 0; j&lt; this.vertices; ++j) &#123; if (this.adj[i][j] != undefined) putstr(this.add[i][j] + ' '); &#125; print(); &#125;&#125;function dfs(v) &#123; this.marked[v] = true; if (this.adj[v] != undefined) &#123; print(\"Visited vertex: \" + v); &#125; for each(var w in this.adj[v]) &#123; if (!this.marked[w]) &#123; this.dfs(w); &#125; &#125;&#125; 广度优先搜索从第一个顶点开始，尝试访问尽可能靠近它的顶点。本质上，这种搜索在图 上是逐层移动的，首先检查最靠近第一个顶点的层，再逐渐向下移动到离起始顶点最远的 层。 广度优先搜索对应的最短路径 123456789101112131415161718function bfs(s) &#123; var queue = []; this.marked[s] = true; queue.push(s); // 添加到队尾 while (queue.length &gt; 0) &#123; var v = queue.shift(); // 从队首移除 if (v == undefined) &#123; print(\"Visisted vertex: \" + v); &#125; for each(var w in this.adj[v]) &#123; if (!this.marked[w]) &#123; this.edgeTo[w] = v; this.marked[w] = true; queue.push(w); &#125; &#125; &#125;&#125; 拓扑排序会对有向图的所有顶点进行排序，使有向边从前面的顶点指向后面的顶点。 1234567891011121314151617181920212223242526function topSort() &#123; var stack = []; var visited = []; for (var i = 0; i &lt; this.vertices; i++) &#123; visited[i] = false; &#125; for (var i = 0; i &lt; this.vertices; i++) &#123; if (visited[i] == false) &#123; this.topSortHelper(i, visited, stack); &#125; &#125; for (var i = 0; i &lt; stack.length; i++) &#123; if (stack[i] != undefined &amp;&amp; stack[i] != false) &#123; print(this.vertexList[stack[i]]); &#125; &#125;&#125;function topSortHelper(v, visited, stack) &#123; visited[v] = true; for each(var w in this.adj[v]) &#123; if (!visited[w]) &#123; this.topSortHelper(visited[w], visited, stack); &#125; &#125; stack.push(v);&#125; 十一、排序算法冒泡排序最慢的排序算法之一，但也是一种最容易实现的排 序算法。数据值会像气泡一样从数组的一端漂 浮到另一端。 1234567891011function bubbleSort() &#123; var numElements = this.dataStore.length; var temp; for ( var outer = numElements; outer &gt;= 2; --outer) &#123; for ( var inner = 0; inner &lt;= outer - 1; ++inner ) &#123; if (this.dataStore[inner] &gt; this.dataStore[inner + 1]) &#123; swap(this.dataStore, inner, inner + 1); &#125; &#125; &#125;&#125; 选择排序选择排序从数组的开头开始，将第一个元素和其他元 素进行比较。检查完所有元素后，最小的元素会被放到数组的第一个位置，然后算法会从 第二个位置继续。这个过程一直进行，当进行到数组的倒数第二个位置时，所有的数据便 完成了排序。选择排序会用到嵌套循环。 12345678910111213function selectionSort() &#123; var min, temp; for (var outer = 0; outer &lt;= this.dataStore.length-2; ++outer) &#123; min = outer; for (var inner = outer + 1; inner &lt;= this.dataStore.length-1; ++iner) &#123; if (this.dataStore[inner] &lt; this.dataStore[min]) &#123; min = inner; &#125; swap(this.dataStore, outer, min); &#125; &#125;&#125; 插入排序插入排序类似于人类按数字或字母顺序对数据进行排序。插入排序有两个循环。外循环将数组元素挨个移动，而内循环则对外循环中选中的元素及 它后面的那个元素进行比较。如果外循环中选中的元素比内循环中选中的元素小，那么数 组元素会向右移动，为内循环中的这个元素腾出位置，就像之前介绍的姓氏卡片一样。 123456789101112function insertionSort() &#123; var temp, inner; for (var outer = 1; outer &lt;= this.dataStore.length - 1; ++outer) &#123; temp = this.dataStore[outer]; inner = outer; while (inner &gt; 0 &amp;&amp; (this.dataStore[inner - 1] &gt;= temp)) &#123; this.dataStore[inner] = this.dataStore[inner - 1]; --inner; &#125; this.dataStore[inner] = temp; &#125;&#125; 高级排序算法 希尔排序这个算法在插入排序的基础上做了很大的改善。 工作原理是，通过定义一个间隔序列来表示在排序过程中进行比较的元素之 间有多远的间隔。我们可以动态定义间隔序列，不过对于大部分的实际应用场景，算法 要用到的间隔序列可以提前定义好。有一些公开定义的间隔序列，使用它们会得到不同 的结果。 高级排序算法 归并排序把一系列排好序的子序列合并成一个大的完整有序序列。 自顶向下的归并排序 自底向上的归并排序 高级排序算法 快速排序快速排序是处理大数据集最快的排序算法之一。它是一种分而治之的算法，通过递归的方 式将数据依次分解为包含较小元素和较大元素的不同子序列。该算法不断重复这个步骤直 到所有数据都是有序的。 首先要在列表中选择一个元素作为基准值（pivot）。数据排序围绕基准值进行， 将列表中小于基准值的元素移到数组的底部，将大于基准值的元素移到数组的顶部。 12345678910111213141516function qSort(list) &#123; if (list.length == 0) &#123; return []; &#125; var lesser = []; var greater = []; var pivot = list[0]; for (var i = 1; i &lt; list.length; i++) &#123; if (list[i] &lt; pivot) &#123; lesser.push(list[i]); &#125; else &#123; greater.push(list[i]); &#125; &#125; return qSort(lesser).concat(pivot, qSort(greater));&#125; 十二、检索算法顺序查找（线性查找）最简单的方法就是从列表的第一个元素开始对列表元素逐个进行判 断，直到找到了想要的结果，或者直到列表结尾也没有找到。 查找最小值和最大值 123456789101112131415161718function findMin(arr) &#123; var min = arr[0]; for (var i = 1; i &lt; arr.length; ++i) &#123; if (arr[i] &lt; min) &#123; min = arr[i]; &#125; &#125; return min;&#125;function findMax(arr) &#123; var max = arr[0]; for (var i = 1; i &lt; arr.length; ++i) &#123; if (arr[i] &gt; max) &#123; max = arr[i]; &#125; &#125; return max;&#125; 二分查找算法二分查找算法比顺序查找算法更高效 将数组的第一个位置设置为下边界（0） 将数组最后一个元素所在的位置设置为上边界（数组的长度减 1） 若下边界等于或小于上边界，则做如下操作。 a. 将中点设置为（上边界加上下边界）除以 2。 b. 如果中点的元素小于查询的值，则将下边界设置为中点元素所在下标加 1。 c. 如果中点的元素大于查询的值，则将上边界设置为中点元素所在下标减 1。 d. 否则中点元素即为要查找的数据，可以进行返回 123456789101112131415161718192021222324252627282930313233function binSearch(arr, data) &#123; var upperBound = arr.length-1; var lowerBound = 0; while (lowerBound &lt;= upperBound) &#123; var mid = Math.floor((upperBound + lowerBound) / 2); if (arr[mid] &lt; data) &#123; lowerBound = mid + 1; &#125; else if (arr[mid] &gt; data) &#123; upperBound = mid - 1; &#125; else &#123; return mid; &#125; &#125; return -1; &#125; var nums = []; for (var i = 0; i &lt; 100; ++i) &#123; nums[i] = Math.floor(Math.random() * 101); &#125; insertionsort(nums); dispArr(nums); print(); putstr(\" 输入一个要查找的值：\"); var val = parseInt(readline()); var retVal = binSearch(nums, val); if (retVal &gt;= 0) &#123; print(\" 已找到 \" + val + \" ，所在位置为：\" + retVal); &#125; else &#123; print(val + \" 没有出现在这个数组中。\");&#125; 十三、高级算法动态规划动态规划实例：计算斐波那契数列 动态规划有时被认为是一种与递归相反 的技术。递归是从顶部开始将问题分解，通过解决掉所有分解出小问题的方式，来解决整 个问题。动态规划解决方案从底部开始解决问题，将所有小问题解决掉，然后合并成一个 整体解决方案，从而解决掉整个大问题。 背包问题、寻找最长公共子串 贪心算法贪心算法总是会选择当下的最优解，而不去考虑这一 次的选择会不会对未来的选择造成影响。是一种以寻找“优质解”为手段从而达成整体解决方案的算法。这些优质的解决 方案称为局部最优解。 找零问题、背包问题","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"图解HTTP","slug":"book/2020/图解HTTP","date":"2020-07-18T12:42:04.000Z","updated":"2022-06-05T14:08:41.957Z","comments":true,"path":"2020/07/18/book/2020/图解HTTP/","link":"","permalink":"http://yoursite.com/2020/07/18/book/2020/%E5%9B%BE%E8%A7%A3HTTP/","excerpt":"","text":"1-网络基础网络基础TCP/IPTCP/IP是互联网相关的各类协议族的总称 应用层决定了向用户提供应用服务时通信的活动。FTP 文件传输协议；DNS域名系统；HTTP协议。 传输层 TCP 对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP传输控制层；UDP用户数据报协议。 网络层 IP用来处理网络上流动的数据包。在从多的选项中选择一条传输线。 数据链路层用来处理连接网络的硬件部份。控制操作系统、硬件的设备驱动、NIC网络适配器、光纤等。 与HTTP密切相关的协义 IP负责传输的IP协议，位于网络层，作用是把各种数据包传送给对方。 TCP确保可靠性的TCP协议，位于传输层，提供可靠的字节流服务。为了传输方便，将大块数据分割成以服文段为单位的数据包进行管理。采用了三次握手策略。SYN+ACK DNS位于应用层，提供域名到IP地址之间的解析服务。 URI和URLURL正是使用WEB浏览器等访问WEB页面时需要输入的网页地址。URI是统一资源标识符。Uniform Resource IdentifierUniform 规定统一格式可方便处理多种不同类型的资源。Resource 可标识的任何东西，可以是单一的，也可以多数的集合体。Identifier 可标识的对象，标识符。 2-普通的HTTP协议 HTTP协议用于客户端和服务器端之间的通信 通过请求和响应的交换达成通信 HTTP是不保存状态的协议，无状态的协议，不做持久化处理 告知服务器意图的HTTP方法 GET 获取资源 POST 传输实体主体 PUT 传输文件 HEAD 获取报文首部 DELETE 删除文件 OPTIONS 询问支持的方法 TRACE 追踪路径 不常用 容易引发XST跨站追踪 CONNECT 要求用隧道协议连接代理 使用方法下达命令 持久连接节省通信量 HTTP keep-alive 管线化方式pipelining 使用Cookie状态管理 3-HTTP报文内的HTTP信息用于HTTP协议交互的信息被称为HTTP报文。分为报文首部+报文主体，两者由空行来划分 CR+LF。 请求行 包含用于请求的方法，请求URI和HTTP版本 状态行 包含表明响应结果的状态码，原因短语和HTTP版本 首部字段 包含请求和响应的各种条件和忏悔的各类首部 编码提升传输速率（压缩传输的内容编码） gzip compress deflate identity 4-HTTP状态码 1XX Informational 信息性状态码：接收 的请求正在处理 2XX Success 成功状态码：请求正常处理完毕 3XX Redirection 重定向状态码：需要进行附加操作以完成请求 4XX Client Error 客户端错误状态码：服务器无法处理请求 5XX Server Error 服务器错误状态码：服务器处理请求出错 200 成功处理并返回 204 Not Content 服务器接收的请求已成功处理，但返回相应报文不包含实体的主体部分 206 Partial Content 表示客户端进行了范围请求，而服务器成功执行了这部份GET请求。Content-Range指定范围的实体内容 301 Moved Permanently 永久性得定向，表示请求的资源已被分配新的URI，以后都使用资源现在指定的URI访问 302 Found 临时性重定向，表示请求的资源已被分配新的URI，希望用户本次能使用新的URI访问 303 SeeOther 由于请求对应的资源存在另一个URI，应使用GET方法定向获取请求的资源。 304 Not Modified 允许请求访问资源，但请求未满足条件，服务器资源未改变，直接使用客户端未过期的缓存，与重定向无关。 307 Temporary Redirect 临时重定向 与302相同含义，但不会从POST变成GET。 400 Bad Request 请求报文中存在语法错误，需要修改请求内容后再次发送请求 401 Unauthorized 请求需要通过HTTP认证信息，用户认证失败 403 Forbidden 请求资源的访问被服务器拒绝了 404 Not Found 无法找到请求的资源，也可以在服务器拒绝请求不想说明理由时使用 500 Internal Server Error 服务器在执行请求时发生了错误 503 Service Unavailable 服务器暂时处于超负载或正在进行停机维护，现在无法处理请求 5-与HTTP写作的web服务器用单台虚拟主机实现多个域名通信数据转发程序：代理、网关、隧道 代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端中间人的角色，接收 由客户端发送的请求并转发给服务器，同时也接收 服务器返回的响应并转发给客户端。 网关是转发其它服务器通信 数据的服务器，接收 从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，有时候客户端不会察觉，自己的通信 目标是一个网关。 隧道是在相隔很远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序 缓存 有效期 当源服务器上的资源更新时，就失效了 客户端缓存 不仅可以存在服务器也可以存在浏览器 6-HTTP首部一、常用标准请求头字段 Accept 设置接受的内容类型 Accept-Charset 设置接受的字符编码 Accept-Encoding 设置接受的编码格式 Accept-Datetime 设置接受的版本时间 Accept-Language 设置接受的语言 Authorization 设置HTTP身份验证的凭证 Cache-Control 设置请求响应链上所有的缓存机制必须遵守的指令 Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项 Content-Length 设置请求体的字节长度 Content-MD5 设置基于MD5算法对请求体内容进行Base64二进制编码 Content-Type 设置请求体的MIME类型（适用POST和PUT请求） Cookie 设置服务器使用Set-Cookie发送的http cookie Date 设置消息发送的日期和时间 Expect 标识客户端需要的特殊浏览器行为 Forwarded 披露客户端通过http代理连接web服务的源信息 From 设置发送请求的用户的email地址 Host 设置服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略 If-Match 设置客户端的ETag,当时客户端ETag和服务器生成的ETag一致才执行，适用于更新自从上次更新之后没有改变的资源 If-Modified-Since 设置更新时间，从更新时间到服务端接受请求这段时间内如果资源没有改变，允许服务端返回304 Not Modified If-None-Match 设置客户端ETag，如果和服务端接受请求生成的ETage相同，允许服务端返回304 Not Modified If-Range 设置客户端ETag，如果和服务端接受请求生成的ETage相同，返回缺失的实体部分；否则返回整个新的实体 If-Unmodified-Since 设置更新时间，只有从更新时间到服务端接受请求这段时间内实体没有改变，服务端才会发送响应 Max-Forwards 限制代理或网关转发消息的次数 Origin 标识跨域资源请求（请求服务端设置Access-Control-Allow-Origin响应字段） Pragma 设置特殊实现字段，可能会对请求响应链有多种影响 Proxy-Authorization 为连接代理授权认证信息 Range 请求部分实体，设置请求实体的字节数范围，具体可以参见HTTP/1.1中的Byte serving Referer 设置前一个页面的地址，并且前一个页面中的连接指向当前请求，意思就是如果当前请求是在A页面中发送的，那么referer就是A 页面的url地址（轶事：这个单词正确的拼法应该是”referrer”,但是在很多规范中都拼成了”referer”，所以这个单词也就成为标准用法） TE 设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样 Upgrade 请求服务端升级协议 User-Agent 用户代理的字符串值 Via 通知服务器代理请求 Warning 实体可能会发生的问题的通用警告 二、常用非标准请求头字段 X-Requested-With 标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequest DNT 请求web应用禁用用户追踪 X-Forwarded-For 一个事实标准，用来标识客户端通过HTTP代理或者负载均衡器连接的web服务器的原始IP地址 X-Forwarded-Host 一个事实标准，用来标识客户端在HTTP请求头中请求的原始host,因为主机名或者反向代理的端口可能与处理请求的原始服务器不同 X-Forwarded-Proto 一个事实标准，用来标识HTTP原始协议，因为反向代理或者负载均衡器和web服务器可能使用http,但是请求到反向代理使用的是https Front-End-Https 微软应用程序和负载均衡器使用的非标准header字段 Front-End-Https: on X-Http-Method-Override 请求web应用时，使用header字段中给定的方法（通常是put或者delete）覆盖请求中指定的方法（通常是post）,如果用户代理或者防火 墙不支持直接使用put或者delete方法发送请求时，可以使用这个字段 X-ATT-DeviceId 允许更简单的解析用户代理在AT&amp;T设备上的MakeModel/Firmware X-Wap-Profile 设置描述当前连接设备的详细信息的xml文件在网络中的位置 Proxy-Connection 早起HTTP版本中的一个误称，现在使用标准的connection字段 X-UIDH 服务端深度包检测插入的一个唯一ID标识Verizon Wireless的客户 X-Csrf-Token,X-CSRFToken,X-XSRF-TOKEN 防止跨站请求伪造 X-Request-ID,X-Correlation-ID 标识客户端和服务端的HTTP请求 三、常用标准响应头 Access-Control-Allow-Origin 指定哪些站点可以参与跨站资源共享 Accept-Patch 指定服务器支持的补丁文档格式，适用于http的patch方法 Accept-Ranges 服务器通过byte serving支持的部分内容范围类型 Age 对象在代理缓存中暂存的秒数 Allow 设置特定资源的有效行为，适用方法不被允许的http 405错误 Alt-Svc 服务器使用”Alt-Svc”（Alternative Servicesde的缩写）头标识资源可以通过不同的网络位置或者不同的网络协议获取 Cache-Control 告诉服务端到客户端所有的缓存机制是否可以缓存这个对象，单位是秒 Connection 设置当前连接和hop-by-hop协议请求字段列表的控制选项 Content-Disposition 告诉客户端弹出一个文件下载框，并且可以指定下载文件名 Content-Encoding 设置数据使用的编码类型 Content-Language 为封闭内容设置自然语言或者目标用户语言 Content-Length 响应体的字节长度 Content-Location 设置返回数据的另一个位置 Content-MD5 设置基于MD5算法对响应体内容进行Base64二进制编码 Content-Range 标识响应体内容属于完整消息体中的那一部分 Content-Type 设置响应体的MIME类型 Date 设置消息发送的日期和时间 ETag 特定版本资源的标识符，通常是消息摘要 Expires 设置响应体的过期时间 Last-Modified 设置请求对象最后一次的修改日期 Link 设置与其他资源的类型关系 Location 在重定向中或者创建新资源时使用 P3P 以P3P:CP=”your_compact_policy”的格式设置支持P3P(Platform for Privacy Preferences Project)策略， 大部分浏览器没有完全支持P3P策略，许多站点设置假的策略内容欺骗支持P3P策略的浏览器以获取第三方cookie的授权 Pragma 设置特殊实现字段，可能会对请求响应链有多种影响 Proxy-Authenticate 设置访问代理的请求权限 Public-Key-Pins 设置站点的授权TLS证书 Refresh “重定向或者新资源创建时使用，在页面的头部有个扩展可以实现相似的功能，并且大部分浏览器都支持 Retry-After 如果实体暂时不可用，可以设置这个值让客户端重试，可以使用时间段（单位是秒）或者HTTP时间 Server 服务器名称 Set-Cookie 设置HTTP Cookie Status 设置HTTP响应状态 Strict-Transport-Security 一种HSTS策略通知HTTP客户端缓存HTTPS策略多长时间以及是否应用到子域 Trailer 标识给定的header字段将展示在后续的chunked编码的消息中 Transfer-Encoding 设置传输实体的编码格式，目前支持的格式： chunked, compress, deflate, gzip, identity TSV Tracking Status Value， 在响应中设置给DNT(do-not-track),可能的取值 “!” — under construction “?” — dynamic “G” — gateway to multiple parties “N” — not tracking “T” — tracking “C” — tracking with consent “P” — tracking only if consented “D” — disregarding DNT “U” — updated Upgrade 请求客户端升级协议 Vary 通知下级代理如何匹配未来的请求头已让其决定缓存的响应是否可用而不是重新从源主机请求新的 Via 通知客户端代理，通过其要发送什么响应 Warning 实体可能会发生的问题的通用警告 WWW-Authenticate 标识访问请求实体的身份验证方案 X-Frame-Options 点击劫持保护： deny frame 中不渲染 sameorigin 如果源不匹配不渲染 allow-from 允许指定位置访问 allowall 不标准，允许任意位置访问 四、常用的非标准响应头 X-XSS-Protection 过滤跨站脚本 Content-Security-Policy, X-Content-Security-Policy,X-WebKit-CSP 定义内容安全策略 X-Content-Type-Options 唯一的取值是””,阻止IE在响应中嗅探定义的内容格式以外的其他MIME格式 X-Powered-By 指定支持web应用的技术 X-UA-Compatible 推荐首选的渲染引擎来展示内容，通常向后兼容，也用于激活IE中内嵌chrome框架插件 X-Content-Duration 提供音视频的持续时间，单位是秒，只有Gecko内核浏览器支持 Upgrade-Insecure-Requests 标识服务器是否可以处理HTTPS协议 X-Request-ID,X-Correlation-ID 标识一个客户端和服务端的请求 7-确保WEB安全的HTTPSHTTP 协议中可能存在信息窃听和身份伪装 通信使用明文，内容可能被窃听 不验证通信方的身份，遭遇伪装 无法证明报文的完整性，可能已遭篡改 通信的加密HTTP协议中没有加密机制，可以通过SSL安全套接层（组合后成为HTTPS）、TLS安全传输层协议组合使用。内容的加密对HTTPS传输内容本身加密 【HTTPS】= HTTP+加密+认证+完整性保护 加密方法 共享密钥加密的困境：加密和解密用同一个密钥的方式称为共享密钥。会被攻击者监听到。 使用两把密钥的公开密钥加密：私有和公有 HTTPS采用混合加密机制共享和公开密钥加密两者混合加密 公开密钥：需要通过数字证书认证机构CA颁发证书 可证明组织真实性的EVSSL证书 用以确认客户端的客户端证书 认证机构信誉第一 由认证机构颁发的证书称为自签名证书（比如中级认证机构的证书可能会变成自签名证书） SSL速度慢吗 通信慢 大量消耗CPU和内存资源 导致处理速度慢 为什么不是所有站点使用HTTPS 1 慢 2 证书花钱 8-确认访问用户身份的认证如何方式 密码 动态令牌 数字证书 生物认证 IC卡 认证方式 BASIC认证（基本认证）ID和密码 DIGEST认证（摘要认证）认证同样使用质询/响应的方式：一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。 SSL客户端认证借由HTTPS客户端证书完成认证的方式 formbase基于表单验证认证多半是基于表单验证，Session管理、Cookie应用 9-基于HTTP的功能追回协议SPDY谷歌在2010年发布SPDY其开发目标指在解决HTTP的性能瓶颈，缩短WEB页面的加载时间50% 瓶颈 一条连接上只可发送一个请求 主脙只能从客户端开始 请求 禹应首部未经过压缩就发送，信息越多延迟越大 发送冗长的首部。每次互相发送相同的首部造成的浪费较多 可任意选择数据压缩格式，非强制压缩发送 解决方法 Ajax 有效利用JS和DOM操作达到WEB页面局部替换加载，但未解决核心 Conmet 一种通过延迟应答，模拟实现服务器端向客户端推送的功能。也未解决核心。 SPDY 没有改写HTTP，而是在TCP IP的应用层和传输层之间通过新加会话层的形式动作。的确是一种可有效消除HTTP瓶颈的技术。 多路复用流 赋予请求优先级 压缩HTTP首部 推送功能 服务器提示功能 Websocket 使浏览器进行全双工通信Websocket协议由IETF定为标准，由W3C定为标准。WEB服务器与客户端之间建立起Websocket协议的通信连接，之后通过这个协议，互相发送JSON XML HTML 图片等任格式的数据。 推送功能：服务器可直接发送数据，不需要等客户端请求 减少通信量：一直保持连接状态，只用一次握手 握手/请求：需要用到HTTP首部Upgrade字段 握手/响应：对于之前的请求，返回都是101 HTTP / 2.0 多路复用(SPDY) TLS义务化(http spend + mobility) 协商 (network friendly HTTP upgrade) 客户端拉Client pull 服务器推送server push (Speed+mobility) 流量控制(SPDY) Websocket (Speed+mobility) 新增Web服务器管理文件的web DAV是一个可对WEB服务器上的内容直接进行文件复制、编辑等操作的分布式文件系统。 11-WEB攻击技术主动攻击以服务器为目标的主动攻击：攻击者通过直接访问WEB应用，把攻击代码传入的攻击模式。1 SQL注入攻击 2 OS命令注入攻击 被动攻击以服务器为目标的被动攻击。是指利用圈套策略执行攻击代码的攻击模式。【利用用户的身份攻击企业内部网络】 因输出值转义不完全引发的安全漏洞 实施WEB应用的安全对策可分为： 客户端的验证 web应用端（服务端）的验证 输入值验证 输出值转义 跨站脚本攻击XSS 被动攻击通过存在安全漏洞的网站注册用户的浏览器内运行非法的HTML或JS进行的一种攻击。动态创建的HTML有安全漏洞。1、利用虚假输入表单用户个人信息。2、利用脚本 获取用户的COOKIE值，在用户不知道的情况下，帮助攻击者发送恶意请求。3、显示伪造的文章和图片。 SQL注入攻击对WEB应用使用的数据库，通过非法的SQL而产生的攻击。 OS命令注入攻击通过WEB应用执行非法的操作系统命令达到攻击目的。只要能在调用 SHELL函数的地方就有存在被攻击的风险。 HTTP首部注入攻击攻击者通过在响应首部字段内插入换行，添加任意响应首部或主体的一种攻击。被动攻击 邮件首部注入攻击目录||路径遍历攻击远程文件包含漏洞因设置或设计上的缺陷引发的安全漏洞（强制浏览、不正确的错误消息处理、开放重定向）因会话管理疏忽引发的安全漏洞（会话劫持、会话固定攻击、跨站点请求伪造）其它（密码破解、点击劫持、DoS攻击||服务停止攻击、后门程序）","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"前端周刊【202007-3】","slug":"weeks/2020/202007-3","date":"2020-07-18T12:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/07/18/weeks/2020/202007-3/","link":"","permalink":"http://yoursite.com/2020/07/18/weeks/2020/202007-3/","excerpt":"","text":"「算法与数据结构」链表的9个基本操作","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"学习JavaScript数据结构与算法 第2版","slug":"book/2020/JS数据结构算法","date":"2020-07-12T12:42:04.000Z","updated":"2022-06-05T14:08:41.956Z","comments":true,"path":"2020/07/12/book/2020/JS数据结构算法/","link":"","permalink":"http://yoursite.com/2020/07/12/book/2020/JS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95/","excerpt":"","text":"1. 数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 向末尾添加arr.push(1);// 向首位添加arr.unshift(1);// 首位删除arr.shift();// 指定位置/索引删除arr.splice(5,1);// 删除最后一项arr.pop()//连接两个或更多数组 并返回结果concat// 对数组中每一项运行给定函数，如果每一项都返回true则返回trueevery// 对数组中每一项运行给定函数，返回该函数会返回true的项组成的数组filter// 对数组中每一项运行给定函数，这个方法没有返回值forEach// 将所有的数组元素连接成一个字符串join// 返回第一个与给定参数相等的数组元素的索引，没有找到则返回-1indexOf// 返回在数组中搜索到的与给定参数u相等的元素的索引里最大的值lastIndexOf// 对数组中每一项运行给定函数，返回每次函数调用的结果组成的数组map// 点到数组中的顺序，原先第一个元素变成最后一个，同样原先的最后一个元素变成现在的第一个reverse// 传入索引值，将数组里对应索引范围的元素作为新数组返回slice// 将数组中每一项运行个定函数，如果任一项返回true，则返回truesome// 按照字母顺序对数组排序，支持传入指定排序方法对函数作为参数sort// 将数组做为字符串返回toString// 和toSrting相似，将数组做为字符串返回valueOf// includes 数组中存在某个元素则返回true 否则false// find 根据回调函数给定的条件从数组中查找元素，如果找到则返回该元素// findIndex 根据回调函数给定的条件数组查找元素，如果找到则返回元素在数组中的索引// fill 用静态值填充数组// from 根据已有数组创建一个新数组// keys 返回包含数组所有索引// of 根据传入的参数创建一个新数组// values 返回包含数组中素有值的@@iterator2 2.栈栈是后进先出【LIFO】原则的有序集合。新添加的元素和待删除的元素都保存在栈的同一端，称作栈顶，另一端叫做栈底。 12345678910111213141516171819202122232425262728// js实现 也可以使用ES6 item = new WeakMap() 存储私有变量function Stack()&#123; let item = [];] // 添加栈元素 this.push = function(ele)&#123; item.push(ele); &#125; // 删除栈顶元素 this.pop = function()&#123; item.pop(); &#125; // 返回栈顶元素 this.peek = function()&#123; return item[item.length-1]; &#125; // 是否为空 this.isEmpty = function()&#123; return item.length === 0; &#125; // 返回栈的个数 this.size = function()&#123; return item.length; &#125; // 清空栈 this.clear = function()&#123; item = []; &#125;&#125; 解决问题 十进制转二进制 以及任一进制的转换算法 平衡圆括号问题 如何用栈解决汉诺塔问题 3. 队列队列是先进先出FIFO，先来先服务的一组有序的项。排队场景。在尾部添加新元素，从顶部移除元素。 1234567891011121314151617181920212223function Queue()&#123; let item = []; //添加元素 this.add = function(ele)&#123; item.push(ele); &#125; //删除元素 this.del = function()&#123; item.shift(); &#125; //返回第一个元素 this.front = function()&#123; return item[0]; &#125; //是否为空 this.isEmpty = function()&#123; return item.length === 0; &#125; //队列个数 this.size = function()&#123; return item.length; &#125;&#125; 扩展修改版的队列形式： 优先队列：添加和移除的元素都是优先级的。类似头等舱和经济舱，急症室和普通。（设置优先级 || 入列操作元素，通过优先级移除添加） 循环队列（击鼓传花）：依次交付给附近的人，到谁谁退出，最终剩下一个。 任务队列（事件循环）：创建一个任务队列，单线程处理所有的任务。 4. 链表链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针或链接）组成。例如火车。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103function LinkedList()&#123; let Node = function (ele)&#123; this.ele = ele; this.next = null; &#125; let length = 0; let head = null; // 向列表尾部添加一个新的项 // 列表的最后一个阶段的下一个元素始终未null this.append = fucntion(ele)&#123; let node = new Node(ele),current; if(head === null)&#123; head = node; &#125;else&#123; current = node; while(current.next)&#123; // 循环 知道找到最后一项 直到为Null 即最后一顶 然后终止执行 current = current.next; &#125; // 终止后 让最后一个的下一个指向插入进来的node // node被创建的时候，它的Next总是指向null current.next = node; &#125; length++; // 更新列表的长度 &#125; // 向列表的特定位置插入一个新的项 this.insert = fucntion(position,ele)&#123; if(position &gt;=0 &amp;&amp; position &lt;= length)&#123; let node = new Node(ele), cur = head, pre, index=0; if(position===0)&#123; node.next = cur; head = node; &#125;else&#123; while(index++ &lt; position)&#123; pre = cur; cur = cur.next; &#125; node.next = cur; pre.next = node; &#125; length++; return true; &#125;else&#123; return false; &#125; &#125; // 从列表中特定位置移除一项 1移除第一项 2移除第一个以外的任一元素 this.removeAt = fucntion(position)&#123; if(position&gt;-1 &amp;&amp; position&lt;length)&#123; let cur = head,pre,index; if(position===0)&#123; head = cur.next; &#125;else&#123; while(index++ &lt; position)&#123; pre = cur; cur = cur.next; &#125; pre.next = cur.next; // 将pre cur的下一项链接起来，跳过cur，从而移除他 &#125; length--; return cur.element; &#125;else&#123; return null; &#125; &#125; // 从列表中移除一项 this.remove = fucntion(ele)&#123; &#125; // 返回元素在列表中的索引 this.indexOf = fucntion(ele)&#123; let cur = head; index = -1; while(cur)&#123; if(ele === cur.element)&#123; return index; &#125; index ++; cur = cur.next; &#125; return -1; &#125; // 判断是否为空 this.isEmpty = fucntion()&#123;&#125; // 返回链表包含的元素个数 this.size = fucntion()&#123;&#125; // 输入元素的值 this.toString = fucntion()&#123; let cur = head, string = ''; while(cur)&#123; string += cur.element + (cur.next?'n':'') cur = cur.next; &#125; reutrn string; &#125;&#125; 双向链表在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的，一个链向下一个元素，一个链向前一个元素。 1234567891011function doubleLinkedList()&#123; let Node = fucntion(ele)&#123; this.ele = ele; this.next = null; this.pre = null; &#125; let length = 0; let head = null; let tail = null;&#125;// 在操作元素的时候，与单链类似，但要同时控制2个指针，next prev 循环列表 可以向链表一样单向引用 双向链表一样双向引用 最后一个元素next指向【第一个元素 head】 5. 集合集合是由一组无序且唯一（不能重复）的项组成。 空集就是不包含任何元素的集合。{} 并集、交集、差集。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function set()&#123; let items = &#123;&#125;; this.add = function(val)&#123; if(!this.has(val))&#123; items[val] = val; return true; &#125; return false; &#125; this.delete = function(val)&#123; if(!this.has(val))&#123; delete items[val]; return true; &#125; return false; &#125; this.has = function(val)&#123; return val in items; // || return items.hasOwnProperty(val); &#125; this.clear = function()&#123; items = &#123;&#125;; &#125; this.size = function()&#123; return Object.keys(items).length; &#125; this.values = function()&#123; let result = []; for(let i=0,keys=Object.keys[items];i&lt;keys.length;i++)&#123; result.push(itemp[keys[i]]); &#125; return result; &#125;&#125;// 并集this.union = fucntion(otherSet)&#123; let unionSet = new Set(); let values = this.values(); for(let i=0;i&lt; values.length;i++)&#123; unionSet.add(values[i]); &#125; values = otherSet.values(); for(let i=0;i&lt;valuse.length;i++)&#123; unionSet.add(values[i]); &#125; return unionSet;&#125;// 交集this.intersection = function(otherSet)&#123; let intersectionSet = new Set(); let values = this.values(); for(let i=0;i&lt;values.length;i++)&#123; if(otherSet.has(values[i]))&#123; intersection.add(values[i]); &#125; &#125; return intersectionSet;&#125;// 差集this.difference = function(otherSet)&#123; let differenceSet = new Set(); let values=this.values(); for(let i=0;i&lt;valuse.length;i++)&#123; if(!otherSet.has(values[i]))&#123; differenceSet.add(values[i]); &#125; &#125;&#125;// 子集this.subset=function(otherSet)&#123; if(this.size()&gt;otherSet.size())&#123; return false; &#125;else&#123; for(let i=0;i&lt;valuse.length;i++)&#123; if(!otherSet.has(values[i]))&#123; return false; &#125; &#125; return true; &#125;&#125; 6.字典和散列表字典字典和散列表是用来存储唯一值（不重复值）的数据结构。 在字典中，用【键，值】的形式来存储数据。字典也称为映射。 在散列表中，也用【键，值】的形式来存储数据。 只是实现方式不同而已！ 1234567891011121314151617181920212223function Dict()&#123; let items =&#123;&#125;; this.set = function(key,val)&#123; item[key]=val; &#125; this.delete = function(val)&#123; if(this.has(key))&#123; delete items[key]; return true; &#125; return false; &#125; this.has = function(key)&#123; return key in items; &#125; this.get = function(key)&#123; return this.has(key) ? items[key]:undefined; &#125; this.clear = function()&#123;&#125; this.size = function()&#123;&#125; this.keys = function()&#123;&#125; this.values = function()&#123;&#125;&#125; 散列表 例如地址簿非顺序数据结构。 123456789101112131415161718192021function HashTable&#123; // 首选要实现散列函数 var loseloseHashCode = function(key)&#123; var hash = 0; for(var i=0;i&lt;key.length;i++)&#123; hash +=key.charCodeAt[i]; &#125; return hash % 37; &#125; let table = []; this.put=function(key)&#123; var postion = loseloseHashCode(key); table[postion] = value; &#125; this.remove=function(key)&#123; table[loseloseHashCode(key)] = undefined; &#125; this.get=function(key)&#123; return table[loseloseHashCode(key)]; &#125;&#125; 7. 树树是非顺序数据结构。一个树结构包含一系列存在父子关系的节点。每个节点都有一个父节点（除了顶部以外）以及零个或多个子节点。 树顶部的节点叫做根节点。 二叉树是一种特殊的树结构，只能有2个子节占，一个左侧的子节点，另一个右侧的子节点。 堆是一种特殊的二叉树。 树的遍历包括前序遍历和后序遍历。 8. 图图是非顺序数据结构。分为有向图和无向图。 图的遍历： 深度优先搜索指DFS从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。先深度后广度地访问顶点。 广度优先搜索BFS指从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层，先宽后深地访问顶点。 9. 排序与搜索算法排序12345678910//反序列输出数组var arr = [1,2,3,4,5]arr.reverse(); //[5,4,3,2,1]// 排序function compare(a,b)&#123; if(a&lt;b) return -1; if(a&gt;b) return 1; return 0;&#125;arr.sort(compare); 冒泡排序比较任何两个相邻的项，如果第一个比第二个大，则交换他们。元素项向上移动至正确的顺序，就像气泡升至表面。 选择排序找到数据结构中的最小值并将其放到第一位，接着找第二小的值将其放到第二位，一次类推。 插入排序每次排一个数组项，一次方式构建最后的排序数组。 归并排序第一个可以背实际使用的排序算法，此排序性能不错。分治算法，将原始数组切分为较小的数组，知道每个小数组只有一个位置，接着将小数组归并成较大的数组，知道最后只有一个排序完毕的大数组。 快速排序1 从数组中选择中间一项做为主元。2 创建两个指针，左边一个指向数组的第一个项，又被一个指向数组最后一个项。3 算啊发对划分后对小数组重复之前对两个步骤，直至数组已完全排序。 搜索算法 顺序搜索顺序和线性搜索是最基本的搜索算法。将每一个数据结构中的元素和我门要找的元素做比较。效率最低。 二分搜索首先要先排序1-选择数组的中间2-如果选中值是目标值，则结束3-如果目标值比选中值要小，则返回步骤1在选中值的左边子数组中寻找4-如果目标值比选中值要大，则返回步骤1在选中值的右边子数组中寻找","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"LoianeGroner","slug":"LoianeGroner","permalink":"http://yoursite.com/tags/LoianeGroner/"}]},{"title":"前端周刊【202007-2】","slug":"weeks/2020/202007-2","date":"2020-07-12T12:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/07/12/weeks/2020/202007-2/","link":"","permalink":"http://yoursite.com/2020/07/12/weeks/2020/202007-2/","excerpt":"","text":"写给前端的算法进阶指南","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"EGG笔记","slug":"basic/nodejs/EGG笔记","date":"2020-07-11T01:42:04.000Z","updated":"2022-06-05T14:08:41.951Z","comments":true,"path":"2020/07/11/basic/nodejs/EGG笔记/","link":"","permalink":"http://yoursite.com/2020/07/11/basic/nodejs/EGG%E7%AC%94%E8%AE%B0/","excerpt":"","text":"目录结构 app/router.js 用于配置 URL 路由规则，具体参见 Router。 app/controller/** 用于解析用户的输入，处理后返回相应的结果，具体参见 Controller。 app/service/** 用于编写业务逻辑层，可选，建议使用，具体参见 Service。 app/middleware/** 用于编写中间件，可选，具体参见 Middleware。 app/public/** 用于放置静态资源，可选，具体参见内置插件 egg-static。 app/extend/** 用于框架的扩展，可选，具体参见框架扩展。 config/config.{env}.js 用于编写配置文件，具体参见配置。 config/plugin.js 用于配置需要加载的插件，具体参见插件。 test/** 用于单元测试，具体参见单元测试。 app.js 和 agent.js 用于自定义启动时的初始化工作，可选，具体参见启动自定义。关于agent.js的作用参见Agent机制。 app/schedule/** 用于定时任务，可选，具体参见定时任务。 内置对象 Application 全局应用对象，在一个应用中，只会实例化一个，它继承自 Koa.Application，在它上面我们可以挂载一些全局的方法和对象。 123456789101112131415161718// app.jsmodule.exports = app =&gt; &#123; app.once('server', server =&gt; &#123; // websocket &#125;); app.on('error', (err, ctx) =&gt; &#123; // report error &#125;); app.on('request', ctx =&gt; &#123; // log receive request &#125;); app.on('response', ctx =&gt; &#123; // ctx.starttime is set by framework const used = Date.now() - ctx.starttime; // log total cost &#125;);&#125;; Context Context 是一个请求级别的对象，继承自 Koa.Context。在每一次收到用户请求时，框架会实例化一个 Context 对象，这个对象封装了这次用户请求的信息，并提供了许多便捷的方法来获取请求参数或者设置响应信息。框架会将所有的 Service 挂载到 Context 实例上，一些插件也会将一些其他的方法和对象挂载到它上面 Request &amp; Response 可以在 Context 的实例上获取到当前请求的 Request(ctx.request) 和 Response(ctx.response) 实例。 12ctx.request.query.id;ctx.response.body; Controller 框架提供了一个 Controller 基类，并推荐所有的 Controller 都继承于该基类实现。 ctx - 当前请求的 Context 实例。 app - 应用的 Application 实例。 config - 应用的配置。 service - 应用所有的 service。 logger - 为当前 controller 封装的 logger 对象。 Service 框架提供了一个 Service 基类，并推荐所有的 Service 都继承于该基类实现。 Service 基类的属性和 Controller 基类属性一致，访问方式也类似： 123456789101112131415// app/service/user.js// 从 egg 上获取（推荐）const Service = require('egg').Service;class UserService extends Service &#123; // implement&#125;module.exports = UserService;// 从 app 实例上获取module.exports = app =&gt; &#123; return class UserService extends app.Service &#123; // implement &#125;;&#125;; Helper Helper 用来提供一些实用的 utility 函数。它的作用在于我们可以将一些常用的动作抽离在 helper.js 里面成为一个独立的函数，这样可以用 JavaScript 来写复杂的逻辑，避免逻辑分散各处，同时可以更好的编写测试用例。 可以在 Context 的实例上获取到当前请求的 Helper(ctx.helper) 实例。 Config app.config 从 Application 实例上获取到 config 对象，也可以在 Controller, Service, Helper 的实例上通过 this.config 获取到 config 对象。 Logger 框架内置了功能强大的日志功能，可以非常方便的打印各种级别的日志到对应的日志文件中，每一个 logger 对象都提供了 4 个级别的方法： logger.debug() logger.info() logger.warn() logger.error() Subscription 订阅模型是一种比较常见的开发模式，譬如消息中间件的消费者或调度任务。因此我们提供了 Subscription 基类来规范化这个模式。 1234567const Subscription = require('egg').Subscription;class Schedule extends Subscription &#123; // 需要实现此方法 // subscribe 可以为 async function 或 generator function async subscribe() &#123;&#125;&#125; middleware中间件 options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。 app: 当前应用 Application 的实例。 12345678// 中间件配置config.middleware = ['printdate'];// 中间件传值config.printdate = &#123; test:'test'&#125;// 中间件使用const printdate = app.middleware.printdate(); Router 路由app/router.js 里面定义 URL 路由规则 12345// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.get('/user/:id', controller.user.info);&#125;; app/controller 目录下面实现 Controller 123456789// app/controller/user.jsclass UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; ctx.body = &#123; name: `hello $&#123;ctx.params.id&#125;`, &#125;; &#125;&#125; RESTful 风格的 URL 定义 12345678910111213// app/router.jsmodule.exports = app =&gt; &#123; const &#123; router, controller &#125; = app; router.resources('posts', '/api/posts', controller.posts);&#125;;// app/controller/posts.jsexports.index = async () =&gt; &#123;&#125;;exports.new = async () =&gt; &#123;&#125;;exports.create = async () =&gt; &#123;&#125;;exports.show = async () =&gt; &#123;&#125;;exports.edit = async () =&gt; &#123;&#125;;exports.update = async () =&gt; &#123;&#125;;exports.destroy = async () =&gt; &#123;&#125;; Controller 控制器负责解析用户的输入，处理后返回相应的结果 在 RESTful 接口中，Controller 接受用户的参数，从数据库中查找内容返回给用户或者将用户的请求更新到数据库中。 在 HTML 页面请求中，Controller 根据用户访问不同的 URL，渲染不同的模板得到 HTML 返回给用户。 在代理服务器中，Controller 将用户的请求转发到其他服务器上，并将其他服务器的处理结果返回给用户。 获取 HTTP 请求参数 query this.ctx.query 字符串 queries this.ctx.queries 对象 Router params body header cookies session Service服务我们并不想在 Controller 中实现太多业务逻辑，所以提供了一个 Service 层进行业务逻辑的封装，这不仅能提高代码的复用性，同时可以让我们的业务逻辑更好测试。 保持 Controller 中的逻辑更加简洁。 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。 将逻辑和展现分离，更容易编写测试用例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// app/router.jsmodule.exports = app =&gt; &#123; app.router.get('/user/:id', app.controller.user.info);&#125;;// app/controller/user.jsconst Controller = require('egg').Controller;class UserController extends Controller &#123; async info() &#123; const &#123; ctx &#125; = this; const userId = ctx.params.id; const userInfo = await ctx.service.user.find(userId); ctx.body = userInfo; &#125;&#125;module.exports = UserController;// app/service/user.jsconst Service = require('egg').Service;class UserService extends Service &#123; // 默认不需要提供构造函数。 // constructor(ctx) &#123; // super(ctx); 如果需要在构造函数做一些处理，一定要有这句话，才能保证后面 `this.ctx`的使用。 // // 就可以直接通过 this.ctx 获取 ctx 了 // // 还可以直接通过 this.app 获取 app 了 // &#125; async find(uid) &#123; // 假如 我们拿到用户 id 从数据库获取用户详细信息 const user = await this.ctx.db.query('select * from user where uid = ?', uid); // 假定这里还有一些复杂的计算，然后返回需要的信息。 const picture = await this.getPicture(uid); return &#123; name: user.user_name, age: user.age, picture, &#125;; &#125; async getPicture(uid) &#123; const result = await this.ctx.curl(`http://photoserver/uid=$&#123;uid&#125;`, &#123; dataType: 'json' &#125;); return result.data; &#125;&#125;module.exports = UserService;// curl http://127.0.0.1:7001/user/1234 安全机制csrf 每个路由上配置 通过中间件统一配置 Cookie默认不能设置中文 如果加密以后就可以设置 123456this.ctx.cookies.set('userinfo','张三',&#123; maxAge:1000*3600*24, httpOnly:true, signed:true, encrypt:true //加密&#125;) 或用encode加密解密来传 清除cookies 1this.ctx.cookies.set('userinfo',null); SessionSession保存在服务器上。基于cookies。 12345678910111213this.ctx.session.username = 'zhangsan';// 单独设置过期时间this.ctx.session.maxAge = 60*1000*10;// 全局配置 基本和COOKIES一致// config.default.jsconfig.session=&#123; maxAge:1000*24*60, httpOnly:true, key:'SESSION_ID', encrypt:true, renew:true // 每次刷新页面的时候 session 都会被重新设置 延期&#125; Plugin why use plugin 中间件加载其实是有先后顺序的，但是中间件自身却无法管理这种顺序，只能交给使用者。这样其实非常不友好，一旦顺序不对，结果可能有天壤之别。 中间件的定位是拦截用户请求，并在它前后做一些事情，例如：鉴权、安全检查、访问日志等等。但实际情况是，有些功能是和请求无关的，例如：定时任务、消息订阅、后台逻辑等等。 有些功能包含非常复杂的初始化逻辑，需要在应用启动的时候完成。这显然也不适合放到中间件中去实现。 plugin.js 中的每个配置项支持： {Boolean} enable - 是否开启此插件，默认为 true {String} package - npm 模块名称，通过 npm 模块形式引入插件 {String} path - 插件绝对路径，跟 package 配置互斥 {Array} env - 只有在指定运行环境才能开启，会覆盖插件自身 package.json 中的配置 123456// config/plugin.js// 使用 mysql 插件exports.mysql = &#123; enable: true, package: 'egg-mysql',&#125;; Extend 框架扩展 Application Context Request Response Helper Application1234// usethis.app// extendapp/extend/application.js Context1234// usethis.ctx// extendapp/extend/context.js Request1234// usethis.ctx.request// extendapp/extend/request.js Response1234// usethis.ctx.response// extendapp/extend/response.js Helper1234// usethis.ctx.helper// extendapp/extend/helper.js 日志 appLogger ${appInfo.name}-web.log，例如 example-app-web.log，应用相关日志，供应用开发者使用的日志。我们在绝大数情况下都在使用它。 coreLogger egg-web.log 框架内核、插件日志。 errorLogger common-error.log 实际一般不会直接使用它，任何 logger 的 .error() 调用输出的日志都会重定向到这里，重点通过查看此日志定位异常。 agentLogger egg-agent.log agent 进程日志，框架和使用到 agent 进程执行任务的插件会打印一些日志到这里。","categories":[],"tags":[{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"}]},{"title":"深入理解虚拟DOM","slug":"basic/js/深入理解-虚拟DOM","date":"2020-07-07T01:42:04.000Z","updated":"2022-06-05T14:08:41.949Z","comments":true,"path":"2020/07/07/basic/js/深入理解-虚拟DOM/","link":"","permalink":"http://yoursite.com/2020/07/07/basic/js/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-%E8%99%9A%E6%8B%9FDOM/","excerpt":"","text":"Virtual DOMJS对象来描述DOM对象。不是真实的DOM对象。 为什么使用Virtual DOM 手动操作DOM比较麻烦 还要考虑浏览器兼容性 随着项目的复杂DOM会越来越复杂 为了简化视图操作 使用模板引擎 但不能更好的解决跟踪状态的改变 当状态改变时不需要立即更新DOM 只会创建一个虚拟树来描述DOM 虚拟DOM内部将弄清楚如何有效DIFF更新DOM 虚拟DOM可以维护程序的状态，跟踪上一次的状态 通过比较前后两次的状态差异更新真实的DOM 作用 维护视图和状态的关系 复杂视图情况下提升渲染性能 除了渲染DOM以外 还可以实现SSR 原生 小程序等 Virtual DOM 库 Snabbdom (VUE2.0内部使用) virtual-dom Snabbdom 库核心 使用h()函数创建JS对象来描述真实DOM init()设置模块 创建patch() patch() 比较新旧两个vnode 把变化的内容更新到真实的DOM树上 h() 函数创建vnode，调用vnode函数返回虚拟节点new Vue render也使用了h函数 Vnode patchpatch(oldVnode,newVnode)diff过程 更新同级别的比较 init createElm addVnodes removeVnodes patchVnode 1.创建项目12- src/index.js- index.html 1234567891011121314&#123; \"name\": \"snabbdom-demo\", \"version\": \"1.0.0\", \"main\": \"index.js\", \"license\": \"MIT\", \"scripts\": &#123; \"dev\": \"parcel index.html --open\", \"build\": \"parcel build index.html\" &#125;, \"dependencies\": &#123; \"parcel-bundler\": \"^1.12.4\", \"snabbdom\": \"^1.0.1\" &#125;&#125; 2.导入及使用12345678910111213141516171819202122232425262728293031import &#123; h, thumk, init &#125; from 'snabbdom'// # Hello World// path 对比两个vnode的差异更新到真实DOMlet patch = init([])// 第一个参数 标签+选择器// 第二个参数 如果是字符串就是标签的内容let vnode = h('div#container.cls','HelloWorld')// 第一个参数 可以是DOM元素 内部会把DOM元素转换成VNODE// 第二个参数 Vnode// 返回：Vnodelet app = document.querySelector('#app')let oldVnode = patch(app, vnode)// 假设的时刻vnode = h('div','Hello Snabbdom')patch(oldVnode, vnode)import &#123; h, thumk, init &#125; from 'snabbdom'// # Hello World// path 对比两个vnode的差异更新到真实DOMlet patch = init([])// 第一个参数 标签+选择器// 第二个参数 如果是字符串就是标签的内容let vnode = h('div#container.cls','HelloWorld')// 第一个参数 可以是DOM元素 内部会把DOM元素转换成VNODE// 第二个参数 Vnode// 返回：Vnodelet app = document.querySelector('#app')let oldVnode = patch(app, vnode)// 假设的时刻vnode = h('div','Hello Snabbdom')patch(oldVnode, vnode) 1234567891011121314151617181920212223import &#123; h, init &#125; from 'snabbdom'// div中放置子元素h1 plet patch = init([])let vnode = h('div#container',[ h('h1','Hello Snabbdom'), h('p','这是一个P标签'),])let app = document.querySelector('#app')let oldVnode = patch(app, vnode)setTimeout(()=&gt;&#123; vnode = h('div#container',[ h('h1','Hello World'), h('p','这是一个P标签 Hello P'), ]) patch(oldVnode, vnode) // 清空页面 官方方法是错的 patch(oldVnode, null) patch(oldVnode, h('!'))&#125;,2000) 3.使用模块核心库不能处理元素的属性样式事件，提供了常用模块 attributes 设置DOM属性 setAttribute() props 设置DOM属性 element[attr] = value class 样式 dataset 设置data-*自定义属性 eventlisteners 注册和移除事件 style 设置行内样式 12345678910111213141516171819202122// 导入模块import &#123;h,init&#125; from 'snabbdom'import style from 'snabbdom/modules/style'import eventlistenners from 'snabbdom/modules/eventlistenners'// 注册模块let patch = init([style,eventlistenners])// 使用H函数的第二个参数传所模块需要的数据（对象）let vnode = h('div',&#123; style:&#123; backgroundColor:'red' &#125;, on:&#123; click:eventHandler &#125;&#125;,[ h('h1','Hello Snabbdom'), h('p','这个是P标签') ])function eventHandler()&#123; console.log('click')&#125;let app = document.querySelector('#app')","categories":[],"tags":[{"name":"virtualDom","slug":"virtualDom","permalink":"http://yoursite.com/tags/virtualDom/"},{"name":"snabbdom","slug":"snabbdom","permalink":"http://yoursite.com/tags/snabbdom/"}]},{"title":"啊哈算法","slug":"book/2020/啊哈算法","date":"2020-07-05T12:42:04.000Z","updated":"2022-06-05T14:08:41.956Z","comments":true,"path":"2020/07/05/book/2020/啊哈算法/","link":"","permalink":"http://yoursite.com/2020/07/05/book/2020/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95/","excerpt":"","text":"一、排序桶排序这是非常快的排序方法，从1956年就开始使用，EJ Issac和RC Singleton提出来的。但是非常浪费空间，原理是有多少个数字就有多少个桶，编号从0-10，没出现一个数，就在对应编号的桶里放一个小旗子，最后只要数数每个桶里有几个小旗子。时间复杂度O(N+M)。 冒泡排序每次比较两个相邻的元素，如果他们的顺序错误就把它们交换过来，越小的越靠后。每一趟只能确定将一个数归位。如果有n个数进行排序，只需将n-1个数归位。 双重嵌套循环，时间复杂度是 O(N²)。执行效率有点低。 1956年就有人使用，Donald E.Knuth高德纳 1974图灵奖获得者。 1234567for(i=1;i&lt;=n-1;i++)&#123;//n个数排序，只用进行n-1趟 for(j=1;j&lt;=n-i;j++)&#123;//从第1位开始比较直到最后一个尚未归位的数，想一想为什么到n-i就可以了 if(a[j]&lt;a[j+1])&#123;//比较大小交换 t=a[j];a[j]=a[j+1];a[j+1]=t; &#125; &#125;&#125; 快速排序 - 最常用的排序每次排序设置一个基准点，将小于等于基准点的数全部放到基准点的左边，将大于等于基准点的数全部放到基准点的右边。最慢的时间复杂度是 O(N²)，平均时间复杂度为O(NlogN)。 由东尼霍尔(C.A.R.Hoare)在1960题出。论文Quicksort和算法导论第七章。 二、栈、队列、链表队列队列是一种特殊的“先进先出”线性结构，它只允许在队列首部进行删除操作，称为“出队”，而在队列的尾部进行插入操作，称为“入队”。三个基本元素（一个数组、两个变量）封装为一个整体结构。 栈栈是“后进先出”的数据结构。栈限定为只能再一端进行插入和删除操作。 最早由艾伦图灵Alan M. Turing 于1946年提出。 链表（指针概念）模拟链表三、枚举 （穷举）数的全排列123的全排列 123 132 213 231 312 321 三重循环嵌套即可，但是12345678全排列呢 ？ 只能靠下节万能的搜索 四、搜索深度优先搜索DFS关键在于解决“当下应该如何做”。 由约翰 霍普克洛夫特John E.Hopcroft 罗伯特陶尔扬Robert E Tarjan发明。全排列。 广度（宽度）优先搜索 层层递进BFS1959年，Edward F. Moore率先 如何从迷宫中寻找出路 提出广度优先搜索。 1961年， C.Y. Lee在电路板布线中也提出了相同算法。 五、图的遍历图：由一些小圆点称为顶点和连接这些小圆点的直线称为边组成的。 首先以一个未被访问的顶点作为起始顶点，沿当前顶点的边走到未访问过顶点。当没有未访问过的顶点时，回到上一个顶点，继续试探访问别的顶点，直到所有的顶点都被访问过。 深度优先遍历是沿着图的某一条分支遍历直到未端，然后回溯，再沿着另一条进行同样的遍历，直到所有的顶点都被访问为止。 六、捷径Floyd-Warshall 只有五行的算法Robert W.Floyd 罗伯特 佛洛依德 1962发表。 Dijkstra 单源最短路一个点到其余各顶点的最短路径。 Edsger Wybe Dijkstra荷兰科学家 1959提出。 Bellman-Ford 解决负权边每次仅对最短路估计值发生变化了的顶点的所有出边执行松弛操作。 Richard Bellman美国应用数学家 理查德 贝尔曼 1958发表。 队列优化的 Bellman-Ford关键：只有那些在前一遍松弛中改变了最短路估计值 的顶点，才可能引起它们邻接点最短路程估计值发生改变。 七、树二叉树特殊的树，每个结点最多有两个儿子，左边的叫做左儿子，右边的叫做右儿子。更加严格的递归定义是，要么为空，要么由根结点、左子树、右子树组成。 堆堆是一种 特殊的二叉树。一棵完全二叉树的数组对象。堆中每个节点总是不大于或不小于其父节点的值。 将根节点最大的堆叫做最大堆或大根堆（或最小堆、小根堆）。常见的堆有二叉堆、斐波那契堆。非线性数据结构，相当于一堆数组。 并查集-擒贼先擒王不相交集的数据结构。","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"前端周刊【202007-1】","slug":"weeks/2020/202007-1","date":"2020-07-05T12:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/07/05/weeks/2020/202007-1/","link":"","permalink":"http://yoursite.com/2020/07/05/weeks/2020/202007-1/","excerpt":"","text":"web 图像技术：前端引入图片的各种方式及其优缺点 前方高能，这是最新的一波Vue实战技巧，不用则已，一用惊人 一篇文章读懂 React and redux 前端开发 干货吸收 《了不起的 Webpack HMR 学习指南（含源码分析）》 《了不起的 Webpack 构建流程学习指南》 《你不知道的 WeakMap》番外篇 《你不知道的 Blob》番外篇 《了不起的 tsconfig.json 指南》","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202006-4】","slug":"weeks/2020/202006-4","date":"2020-06-28T12:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/06/28/weeks/2020/202006-4/","link":"","permalink":"http://yoursite.com/2020/06/28/weeks/2020/202006-4/","excerpt":"","text":"你不知道的前端异常处理你不知道的 TypeScript 泛型","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"node 前端加密后端解密","slug":"basic/nodejs/node 前端加密后端解密","date":"2020-06-25T01:42:04.000Z","updated":"2022-06-05T14:08:41.951Z","comments":true,"path":"2020/06/25/basic/nodejs/node 前端加密后端解密/","link":"","permalink":"http://yoursite.com/2020/06/25/basic/nodejs/node%20%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%AF%86%E5%90%8E%E7%AB%AF%E8%A7%A3%E5%AF%86/","excerpt":"","text":"前端jsencrypt加密12345import JsEncrypt from 'jsencrypt'const jsEncrypt = new JsEncrypt()jsEncrypt.setPublicKey(public_key)jsEncrypt.encrypt(username) 后端RSA解密1234567891011121314151617181920const NodeRSA = require('node-rsa'); const newkey = new NodeRSA(&#123;b: 1024&#125;); //因为jsencrypt自身使用的是pkcs1加密方案,只有从后台改咯const newkey.setOptions(&#123;encryptionScheme: 'pkcs1'&#125;); const public_key = newkey.exportKey('pkcs8-public');//公钥,const private_key = newkey.exportKey('pkcs8-private'); //私钥const pubkey = new NodeRSA(public_key);const prikey = new NodeRSA(private_key);//因为jsencrypt自身使用的是pkcs1加密方案,只有从后台改咯pubkey.setOptions(&#123;encryptionScheme: 'pkcs1'&#125;);//因为jsencrypt自身使用的是pkcs1加密方案,只有从后台改咯prikey.setOptions(&#123;encryptionScheme: 'pkcs1'&#125;);//加密&amp;&amp;解密方法 const encrypted = pubkey.encrypt(yourstring,'base64'); const decrypted = prikey.decrypt(encrypted, 'utf8');","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"},{"name":"jsencrypt","slug":"jsencrypt","permalink":"http://yoursite.com/tags/jsencrypt/"}]},{"title":"前端周刊【202006-3】","slug":"weeks/2020/202006-3","date":"2020-06-21T12:42:04.000Z","updated":"2022-06-05T14:08:41.966Z","comments":true,"path":"2020/06/21/weeks/2020/202006-3/","link":"","permalink":"http://yoursite.com/2020/06/21/weeks/2020/202006-3/","excerpt":"","text":"vue vue-element-admin 是一个后台前端解决方案，它基于和 element-ui 实现 基于 iView 的 Vue 2.0 管理系统模板 基于 vue2 + vuex 构建一个具有 45 个页面的大型单页面应用 基于 vue + element-ui 的后台管理系统 基于Vue.js + Element UI 的后台管理系统解决方案 基于 Vue(2.5) + vuex + vue-router + vue-axios +better-scroll + Scss + ES6 等开发一款移动端音乐 WebApp Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端 高仿网易云音乐的 webapp，只实现了 APP 的核心功能 Vue + TypeScript + Element-Ui 支持 markdown 渲染的博客前台展示 更多… react 一套优秀的中后台前端解决方案 网易云音乐第三方 一个 react + redux 的完整项目 和 个人总结 react 后台管理系统解决方案 这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台 RN写的饿了么，还原度相当高，实现了各类动效 仿知乎日报 一个商城类的RN项目 react + Ant Design + 支持 markdown 的博客前台展示 基于 pro.ant.design 的 react + Ant Design 的博客管理后台项目 使用 react hooks + koa2 + sequelize + mysql 搭建的前后台的博客 基于typescript koa2 react的个人博客 更多… nodejs 基于 node.js + Mongodb 构建的后台系统 Nodeclub 是使用 Node.js 和 MongoDB 开发的社区系统 基于Node.js+MySQL开发的开源微信小程序商城（微信小程序） NideShop 开源微信小程序商城服务端 API（Node.js + ThinkJS） 基于react, node.js, go开发的微商城（含微信小程序） React+Express+Mongo -&gt;前后端博客网站 基于 node + express + mongodb 的博客网站后台","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"前端周刊【202006-2】","slug":"weeks/2020/202006-2","date":"2020-06-14T12:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/06/14/weeks/2020/202006-2/","link":"","permalink":"http://yoursite.com/2020/06/14/weeks/2020/202006-2/","excerpt":"","text":"让你眼前一亮的 10 大 TS 项目 一篇文章构建你的 NodeJS 知识体系","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"TS笔记 - 07泛型装饰器 @log","slug":"basic/typescript/07-装饰器@log","date":"2020-06-13T13:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/07-装饰器@log/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/07-%E8%A3%85%E9%A5%B0%E5%99%A8@log/","excerpt":"","text":"装饰器是一种特殊的类型声明，它能够被附加到类声明、方法、属性和参数上，可以修改类的行为。通俗来说就是一个方法，可以注入到类、方法、属性参数上来扩展类、属性、方法、参数的功能。 常见装饰器方法：类装饰器、属性装饰器、方法装饰器、参数装饰器 写法：普通装饰器（无法传参） 装饰器工厂（可传参） 装饰器是过去几年中JS最大的成京之一，已是ES7的标准特性之一 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 装饰器 就是一个方法// 类装饰器 不要加分号 无参普通装饰器function logClass(params:any)&#123; console.log(params); //params 就是当前类 params.prototype.apiUrl='http://'; params.prototype.run=function()&#123; console.log('我是一个run方法'); &#125;;&#125;@logClassclass HttpClient()&#123; constructor()&#123; &#125; getData()&#123; &#125;&#125;var http:any = new HttpClient();http.apiUrl; // http://http.run();// 带参 装饰器工厂function logClass(params:string)&#123; return function(target:any)&#123; console.log(target); // 类 HttpClient console.log(params); // hello target.prototype.text=params; &#125;&#125;@logClass('hello')class HttpClient()&#123; constructor()&#123; // &#125; getData()&#123; // &#125;&#125;var http:any = new HttpClient();http.text; // hello 1、类装饰器：重截构造函数的例子如果类装饰器返回一个值，它会使用提供的构造函数替换类的声明。 1234567891011121314151617181920212223function logClass(target:any)&#123; console.log(target); return class extends target&#123; // 重点！ apiUrl:any=\"我是修改后的数据\"; getData()&#123; this.apiUrl = this.apiUrl + '====='; console.log(this.apiUrl); &#125; &#125;&#125;@logClassclass HttpClient()&#123; apiUrl : string | undefined; constructor()&#123; this.apiUrl = '我是构造函数里面的apiUrl'; &#125; getData()&#123; console.log(this.apiUrl); &#125;&#125;var http:any = new HttpClient();http.getData(); 2、属性装饰器 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象 成员名字 1234567891011121314151617181920212223242526272829// 类装饰器function logClass(params:any)&#123; return function(target:any)&#123; &#125;&#125;// 属性装饰器 target 类的原型对象 function logProerty(params:any)&#123; return function(target:any,attr:any)&#123; console.log(target); // HttpClient console.log(attr); // http:// target[attr] = params; //!!重点 难点 对实例成员来说是类的原型对象 &#125; &#125;@logClass('xxx')class HttpClient()&#123; @logProerty('http://') public url:any|undefined; constructor()&#123; &#125; getData()&#123; console.log(this.url); &#125;&#125;var http:any = new HttpClient();http.url; // http:// 3、方法装饰器修改当前实例的属性和方法 修改当前里的参数修改 123456789101112131415161718192021222324252627function get(params:any)&#123; return function(target:any,methodName:any,desc:any)&#123; console.log(target); //HttpClient console.log(methodName); // getData console.log(desc.value); // 当前方法 target.url = 'xxx'; var oMethod = desc.value; desc.value = function(...args:any[])&#123; args = args.map((value)=&gt;&#123; return String(value); &#125;) oMethod.apply(this,args); &#125; &#125;&#125;class HttpClient()&#123; public url:string | undefined; constructor()&#123; &#125; @get('http://www.baidu.com') // !!重点 getData(...args:any[])&#123; console.log('我是getdata里的方法'); &#125;&#125;var n = new HttpClient();http.getData(123,'123123'); 4、方法参数装饰器参数装饰器表达式会在运行时当作函数被调用，可以使用参数装饰器为类的原型增加一些元素数据,传入以下三个参数 1、对表态成员来说是类的构造函数，对实例成员是类的原型对象 2、方法的名字 3、参数在函数参数列表中的索引 12345678910111213141516171819function logParams(params:any)&#123; return function(target:any,methodName:any,paramsIndex:any)&#123; console.log(params); // uuid console.log(target); //HttpClient 当前类原型对象 console.log(methodName); // getData 当前方法名称 console.log(paramsIndex); // 0 当前索引 &#125;&#125;class HttpClient()&#123; public url:string | undefined; constructor()&#123; &#125; getData(@logParams('uuid') uuid:any)&#123; // !!重点 console.log(uuid); // 123 &#125;&#125;var http = new HttpClient();http.getData(123); 执行顺序属性 》 方法 》 方法参数 》 类 如果有多个同样的装饰器，它会先执行后面的！！！","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS笔记 - 06命名空间 namespace","slug":"basic/typescript/06-命名空间namespace","date":"2020-06-13T12:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/06-命名空间namespace/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/06-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4namespace/","excerpt":"","text":"命名空间 namespace A{}在代码量较大情况下，为了避免各种变量命名相冲突，可将相似功能的函数 类接口等放置到命名空间内。同JAVA NET的命名空间一样，如果需要向外调用 需要export 命名空间和模块的区别 命名空间：内部模块 主要用于组织代码 避免命名冲突 模块：TS的外部模块的简称 侧重代码的复用 一个模块 里可能会有多个命名空间 12345678910111213141516// person.tsexport namespace A&#123; // 命名空间下的私有类 如果需要向外调用 需要export export class Person&#123; name:string; constructor(n:string)&#123; this.name = n; &#125; run():void&#123; console.log(this.name); &#125; &#125;&#125;// index.tsimport &#123;A&#125; from './person.ts'var D = new A.Person();","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS笔记 - 05泛型 <T>","slug":"basic/typescript/05-泛型<T>","date":"2020-06-13T11:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/05-泛型<T>/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/05-%E6%B3%9B%E5%9E%8B%3CT%3E/","excerpt":"","text":"泛型 不仅规范API，也要考虑可重用性。同时也能支持未来的数据类型。 一种组件可以支持多种 数据类型。 解决 类 接口方法的复用性，以及对不特定的数据类型的支持 12345// 以往代码 复杂 不可复用 代码冗余function getData1(value:string)&#123;return value&#125;function getData2(value:number)&#123;return value&#125;// 以往代码 比较粗暴 放弃了类型检查function getData(value:any)&#123;return value&#125; 泛型定义12345678// T表示泛型function getData&lt;T&gt;(value:T):T&#123; // 最后这个T表示返回类型 return value;&#125;getData&lt;number&gt;(123); //successgetData&lt;string&gt;('zhangsan'); //successgetData&lt;number&gt;('123'); //error 泛型类 比如有个最小堆算法，需要同时支持返回数字和字符串两钟类型 通过类泛型来实现 12345678910111213141516171819class MinClass&lt;T&gt;&#123; list:T[]=[]; add(num:T)&#123; this.list.push(num); &#125; min():T&#123; // return minNum; &#125;&#125;// 实例化类 并且制定了类T代表的类型var m = new MinClass&lt;number&gt;(); m.add(3);m.add(32);// orvar m = new MinClass&lt;string&gt;();m.add('222');m.add('333');m.min(); 泛型接口123456789101112131415161718192021// 第一种 写法interface Config&#123; &lt;T&gt;(value:T):T;&#125;var setData:Config = function&lt;T&gt;(value:T):T&#123; return value;&#125;setData&lt;string&gt;('zhangsan')// 第二种 写法interface Config&lt;T&gt;&#123; (value:T):T;&#125;function getData&lt;T&gt;(value:T):T&#123; return value;&#125;var myGetData:Config&lt;string&gt; = getData;myGetData('zhangsan')// orvar myGetData:Config&lt;number&gt; = getData;myGetData(123) 把类作为参数类型的泛型类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class User&#123; username:string | undefined; password:string | undefined;&#125;class MysqlDB&#123; add(user:User):boolean&#123; console.log(user); &#125;&#125;var U = new User();U.username = 'zhangsan';U.password = '123456';var D = new MysqlDB()D.add(U);// 泛型类// 1 去除重复代码 2 对于不特定类进行数据校检class MysqlDB&lt;T&gt;&#123; add(info:&lt;T&gt;):boolean&#123; console.log(info); &#125;&#125;class User&#123; username:string | undefined; password:string | undefined;&#125;var U = new User();U.username = 'zhangsan';U.password = '123456';var D = new MysqlDB&lt;User&gt;();D.add(U);class Article&#123; title:string | undefined; desc:string | undefined; status:number | undefined; constructor(params:&#123; title:string | undefined, desc:string | undefined, status?:number | undefined &#125;)&#123; this.title = params.title this.desc = params.desc this.status = params.status &#125;&#125;var A = new Article(&#123; titile:'123', desc:'123'&#125;);var S = new MysqlDB&lt;Article&gt;();S.add(A); 定义一个操作数据库的库12345678910111213141516171819202122232425262728293031323334indterface DBI&lt;T&gt;&#123; add(info:T):boolean; update(info:T,id:number):boolean; delete(id:number):boolean; get(id:number):any[];&#125;//定义一个操作mysql的类class MysqlDB&lt;T&gt; implements DBI&lt;T&gt;&#123; constructor()&#123; // 可以在此写与数据库建立连接 &#125; add(info:T):boolean&#123; &#125; update(info:T,id:number):boolean&#123; &#125; delete(id:number):boolean&#123; &#125; get(id:number):boolean&#123; &#125;&#125;// 操作用户表 定义一个User类和数据库映射class User&#123; username:string | undefined; password:string | undefined;&#125;var U = new User();U.username = 'zhangsan';U.password = '123456';var oMysql = new MysqlDB&lt;User&gt;();oMysql.add(U);","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS笔记 - 04接口 interface","slug":"basic/typescript/04-接口interface","date":"2020-06-13T10:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/04-接口interface/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/04-%E6%8E%A5%E5%8F%A3interface/","excerpt":"","text":"接口 接口是一种规范的定义，它定义了行为和动作的规范。包括属性、函数、可索引和类等。 模拟 ajax123456789101112131415161718192021interface Config&#123; type:string, url:string, data?:string, //可选参数 dataType:string&#125;function Ajax(config:Config)&#123; var xhr = new XMLHttpRequest(); xhr.open(config.type,config.url,true); xhr.send(config.data); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log('success'); &#125; &#125;&#125;Ajax(&#123; type:'get', url:'/test', dataType:'json'&#125;) 1、属性接口 对json约束 对批量方法进行约束1234567891011121314interface FullName&#123; first:string; second:string; age?:number // 可选参数&#125;function printName(name:FullName)&#123; console.log(name.fitst);&#125;let obj = &#123; first:'zhangsan', second:'lisi'&#125;printName(obj); 2、函数类型接口12345678interface encrypt&#123; (key:string,value:string):string;&#125;var md5:encrypt=function(key:string,value:string):string&#123; return key+value;&#125;md5('name','zhangsan'); 3、可索引接口 数组对象的约束 （不常用）12345678910111213141516var arr:number[]=[123,123]var arr:array&lt;number&gt;=[123,123]// index 索引值// 对数组约束interface UserArr&#123; [index:number]:string&#125;var arr:UserArr=['aaa',123] //errorvar arr:UserArr=['aaa','123123'] //success// 对对象约束interface UserArr&#123; [index:string]:string&#125;var arr:UserArr=&#123;name:'zhangsan'&#125; 4、类类型接口：对类的约束 和 抽象类有点相似12345678910111213141516interface Animal&#123; name:string; eat(str:string):void;&#125;class Dog implements Animal&#123; name:string; constructor(name:string)&#123; this.name = name; &#125; eat()&#123; console.log(this.name+'eat meal'); &#125;&#125;var d = new Dog('小黑');d.eat(); 5、接口扩展 接口可以继承接口1234567891011121314151617181920212223242526272829303132interface Animal&#123; eat():void;&#125;interface Penson extends Animal&#123; work():void;&#125;interface Programmer&#123; name:string, constructor(name:string)&#123; this.name = name; &#125; codding(code:string)&#123; console.log(this.name+code); &#125;&#125;//即可以继承接口也可以实现接口class Web extends Programmer implements Person&#123; name:string, constructor(name:string)&#123; super(name); &#125; eat()&#123; console.log(this.name+'吃米饭'); &#125; work()&#123; console.log(this.name+'写代码'); &#125;&#125;var d = new Web('小李');d.eat(); //小李吃米饭 //实现d.work(); //小李写代码 //实现d.codding('TS'); //小李TS //继承","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS笔记 - 03类的知识 class","slug":"basic/typescript/03-类class","date":"2020-06-13T09:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/03-类class/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/03-%E7%B1%BBclass/","excerpt":"","text":"TS类的知识1.定义类12345678910111213141516171819202122232425262728293031323334353637383940/*ES5 类*/function Person(name)&#123; this.name = name; this.run(name)&#123; console.log(name); &#125;&#125;var p = new Person('张三');p.run();/*TS*/class Person&#123; name:string; constructor(n:string)&#123; this.name = n; &#125; run():void&#123; console.log(this.name); &#125;&#125;var p = new Person('张三');p.run();/*TS*/class Person&#123; name:string; constructor(name:string)&#123; this.name = name; &#125; getName:string&#123; return this.name; &#125; setName(name:string):void&#123; this.name = name; &#125;&#125;var p = new Person('张三');p.getName();p.setName('李四'); 2.实现继承 extends \\ super1234567891011121314151617181920212223class Person&#123; name:string; constructor(name:string)&#123; this.name = name; &#125; run:string&#123; return `$&#123;this.name&#125;在运动`; &#125;&#125;class Web extends Person&#123; constructor(name:string)&#123; super(name); // 初始化父类构造函数 &#125; run():string&#123; return `$&#123;this.name&#125;在运动 - 子类run`; &#125; work():string&#123; return `$&#123;this.name&#125;在运动 - 子类work`; &#125;&#125;var w = new Web('李四');w.run();//李四在运动 - 子类runw.work();//李四在运动 - 子类work 3. 类修饰符 public 公有 在类里面 子类 外面 都可以访问 protected 保护类型 在类里面 子类 可以访问 类外不能访问 private 私有类型 在类里面可以访问 子类 类外 不能访问 如果不加修饰符 默认为公有 123456789class Person&#123; public name:string; constructor(name:string)&#123; this.name = name; &#125; run:string&#123; return `$&#123;this.name&#125;在运动`; &#125;&#125; 4.静态方法 静态属性 类外部可以调用 静态属性 静态方法 没发直接调用类里面的属性 this.name12345678910111213141516171819class Person&#123; public name:string; static sex:string = 'man'; constructor(name:string)&#123; this.name = name; &#125; run:string&#123; // 实例方法 return `$&#123;this.name&#125;在运动`; &#125; work:string&#123; return `$&#123;this.name&#125;在工作`; &#125; static print()&#123;// 静态方法 没发直接调用类里面的属性 this.name return 'print 方法'; &#125;&#125;var p = new Person('张三');p.run();Person.sex; //类外部可以调用 静态属性 5.多态 父类定义一个方法不去实现，让继承它的子类去实现 每一个子类有不同的表现也是继承的一种 12345678910111213141516171819202122232425class Animal&#123; name:string; constructor(name:string)&#123; this.name = name; &#125; eat()&#123; // 具体吃什么不知道 继承它的子类去实现 console.log('吃方法'); &#125;&#125;class dog extends Animal&#123; constructor(name:string)&#123; super(name); // 继承 &#125; eat()&#123; return this.name + '吃狗粮'； &#125; &#125;class Cat extends Animal&#123; constructor(name:string)&#123; super(name); // 继承 &#125; eat()&#123; return this.name + '吃老鼠'； &#125; &#125; 6.abstract 抽象方法只能放在抽象类里面 它是提供其它类继承的基类 不能直接被实例化 抽象类和方法用来定义标准 Animal这个类要求它的子类必须包含eat方法 用abstract关键字定义抽象类和抽象方法 抽象类中的抽象方法 不包含具体实现并且必须派生类中实现 抽象类方法只能存在抽象类中 12345678910111213141516171819abstract class Animal&#123; name:string; constructor(name:string)&#123; this.name = name; &#125; abstract eat():any;&#125;// var a = new Animal(); 错误写法 class Dog extends Animal&#123; constructor(name:string)&#123; super(name); // 继承 &#125; //抽象类的子类必须实现抽象类里面的抽象方法 eat()&#123; return this.name + '吃鸡肉'； &#125;&#125;var n = new Dog('小黑');n.eat();","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS笔记 - 02函数 function","slug":"basic/typescript/02-函数","date":"2020-06-13T08:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/02-函数/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/02-%E5%87%BD%E6%95%B0/","excerpt":"","text":"函数1.函数的定义12345678910111213141516171819// 函数声明法function run():string&#123; return '123';&#125;// 定义声明法var run = function():string&#123; return '123';&#125;// 定义参数function getInfo(name:string,age:number):string&#123; return `$&#123;name&#125; + $&#123;age&#125;`;&#125;//没有返回值的方法function run():void&#123; console.log('run');&#125; 2.方法可选参数 ?12345function getInfo(name:string,age?:number)&#123;&#125;getInfo('zhangsan');//可选参数必须放在最后面function getInfo(name?:string,age:number)&#123;&#125; //错！ 3.默认参数1234function getInfo(name:string,age?:number=20)&#123; console.log(name+age);&#125;getInfo('zhangsan'); 4.剩余参数12345678910111213function sum(a:number,b:number,c:number:d:number):number&#123; console.log(a+b+c+d);&#125;sum(1,2,3,4);// 三点运算符 接收新参传过来的值function sum(...result:number[]):number&#123; //&#125;function sum(a:numerb,...result:number[]):number&#123; //&#125;sum(1,2,3,4); 5.函数重载两个或两个以上同名函数，但他们的参数不一样，这时会出现函数重载的情况。通过为同一个函数提供多个函数类型定义来试下多种功能的目的。 12345678910111213141516171819202122232425262728293031//ES5中出现同名方法，下面的会替换上面的方法function css()&#123;&#125;function css()&#123;&#125;//ts中重载 - 1function getInfo(name:string):string&#123;&#125;function getInfo(age:number):number&#123;&#125;function getInfo(str:any):any&#123; if(typeof str === 'string')&#123; return name; &#125;else&#123; return str; &#125;&#125;getInfo('test'); //正确getInfo(20);getInfo(true);//错误//ts中重载 - 2function getInfo(name:string):string&#123;&#125;function getInfo(name:string,age:number):string&#123;&#125;function getInfo(name:any,age?:any):any&#123; if(age)&#123; return '我叫'+name+'年龄'+age; &#125;else&#123; return '我叫'+name; &#125;&#125;getInfo('test'); //正确getInfo(123); //错误getInfo('test',20); //正确 6. 箭头函数123//ES5setTimeout(()=&gt;&#123; &#125;,500)","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"TS笔记 - 01数据类型","slug":"basic/typescript/01-数据类型","date":"2020-06-13T07:42:04.000Z","updated":"2022-03-17T15:15:23.550Z","comments":true,"path":"2020/06/13/basic/typescript/01-数据类型/","link":"","permalink":"http://yoursite.com/2020/06/13/basic/typescript/01-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"数据类型开始使用123tsc --init //创建tsconfig.json 改\"outDir\":'./js'tsc index.ts //编译文件为index.js js目录下生成创建html 引入index.js 数据类型boolean1let flag: boolean = true; number1let flag: number = 123; string1let flag: srting = '123'; array1234// 第一种定义数组let arr1: number[] = [1,2,3]// 第二种定义数组let arr2: Array&lt;number&gt; = [1,2,3] tuple 元祖 * 属于数组的一种1234567let arr: Array&lt;number | string&gt; = [1,2,3,'123']let arr: Array[number,string] = [1,'123']// 元组 限制类型和个数let tuple: [number,string] = [1,'1']tuple.push(2) //允许插入 // console.log(tuple[2]) // 但是不可以访问 enum 枚举 *12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// success 1 error 0// status 1 pay 2 unpay 3 cancelenum Flag&#123;success=1,error=2&#125;;let s:Flag = Flag.success; // 1enum Color &#123;blue,red,'orange'&#125;;var c:Color=Color.red; //1 如果枚举没有赋值 他的值就是下标index// // 相关知识// 数字枚举 0,1,2,3,4,5 反向映射 enum Role&#123; Reporter = 1, Developer, Maintainer, Owner, Guest &#125; // 字符串枚举 enum Message &#123; Success = '恭喜你，成功了', Fail = '抱歉，失败了' &#125; // 异构枚举 混用 不建议使用 enum Answer &#123; N, Y = 'YES' &#125; // 枚举成员 enum Char&#123; // const a, b=Char.a, c=1+3, // computed 编译阶段不计算 运行阶段才计算 在此后声明的常量必须初始化值 d=Math.random(), e='123'.length &#125; // 常量枚举 const enum Month &#123; Jan, Feb, Mar &#125; // 枚举类型 enum E &#123; a,b &#125; enum F &#123; a = 0, b=1&#125; enum G &#123; a='apple', b='banana'&#125; let e:E = 3 let f:F = 3 let e1:E.a let e2:E.b let e3:E.a let g1:G let g2:G.a any 任意 *123let str:any=&#123;&#125;str='123';str=123; null undefined 其它never类型的子类型12345678910111213141516// 定义没有赋值var num:number;console.log(num); // 输出undefined 错误var num:undefined;console.log(num); // 输出undefined 正确// 空类型var num:null;num = null; //正确num = 123; //错误// 一个元素可以设置多个类型var num:number | null | undefined; void * 表示没有任何类型 用于定义方法的时候方法没有返回值123function run():void&#123; //&#125; never * 其他类型 包括null undefined 代表不会出现的值 几乎不会使用1234var a:never;a=(()=&gt;&#123; throw new Error('error');&#125;)","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"前端周刊【202006-1】 性能方向","slug":"weeks/2020/202006-1","date":"2020-06-06T02:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/06/06/weeks/2020/202006-1/","link":"","permalink":"http://yoursite.com/2020/06/06/weeks/2020/202006-1/","excerpt":"","text":"Vue项目性能优化 — 实栈指南 2020你应该知道的前端知识 koa2实现微信授权登录 一次性丢给你10万条数据, 作为前端工程师的你,要怎么处理?","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"移动端字体适配方案","slug":"basic/js/移动端字体适配方案","date":"2020-06-02T01:42:04.000Z","updated":"2022-03-17T15:15:23.540Z","comments":true,"path":"2020/06/02/basic/js/移动端字体适配方案/","link":"","permalink":"http://yoursite.com/2020/06/02/basic/js/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%AD%97%E4%BD%93%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88/","excerpt":"","text":"本文主要从两方面适配 1.remjs 字体适配 2.postcss pxtorem 字体适配 1.字体适配 REM.JS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * rem.js * 随分辨率变化设置根font-size大小 * 使字体自适应变化 * @author Marong */(function(win) &#123; let time const doc = document const baseSize = 100 // 1rem = 100px const designWidth = 375 const maxWidth = 750 let width = doc.documentElement.getBoundingClientRect().width const height = doc.documentElement.clientHeight // 判断横竖屏状态 let screenVertical = true if (width &lt;= height) &#123; screenVertical = true &#125; else &#123; screenVertical = false &#125; // 设置根字体大小 function setRem() &#123; if (width &gt; maxWidth) &#123; // 最大宽度 width = maxWidth &#125; const rem = screenVertical ? width * baseSize / designWidth // 横屏 : height * baseSize / designWidth // 竖屏 doc.documentElement.style.fontSize = rem + 'px' &#125; // 浏览器缩放时 win.addEventListener('resize', function() &#123; clearTimeout(time) // 防止执行两次 time = setTimeout(setRem, 300) &#125;, false) // 浏览器后退的时候重新计算 win.addEventListener('pageshow', function(e) &#123; if (e.persisted) &#123; clearTimeout(time)// 防止执行两次 time = setTimeout(setRem, 300) &#125; &#125;, false) setRem()&#125;)(window) 2.PostCss pxtorem12// main.jsimport 'lib-flexible/flexible.js' 123456789101112// .postcssrc.jsmodule.exports = &#123; plugins: &#123; autoprefixer: &#123; overrideBrowserslist: ['Android 4.1', 'iOS 7.1', 'Chrome &gt; 31', 'ff &gt; 31', 'ie &gt;= 8'] &#125;, 'postcss-pxtorem': &#123; rootValue: 100, propList: ['*'] &#125; &#125;&#125;","categories":[],"tags":[{"name":"rem","slug":"rem","permalink":"http://yoursite.com/tags/rem/"},{"name":"postcss","slug":"postcss","permalink":"http://yoursite.com/tags/postcss/"}]},{"title":"前端周刊【202005-4】","slug":"weeks/2020/202005-4","date":"2020-05-31T10:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/05/31/weeks/2020/202005-4/","link":"","permalink":"http://yoursite.com/2020/05/31/weeks/2020/202005-4/","excerpt":"","text":"前端之未来 前端内参 我从来都不理解闭包 超详细！4小时开发一个SpringBoot+vue前后端分离博客项目！！","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"KOA笔记","slug":"basic/nodejs/KOA笔记","date":"2020-05-26T01:42:04.000Z","updated":"2022-06-05T14:08:41.951Z","comments":true,"path":"2020/05/26/basic/nodejs/KOA笔记/","link":"","permalink":"http://yoursite.com/2020/05/26/basic/nodejs/KOA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"KOA相关笔记全局安装npm i koa-generator -g 创建项目 koa koa_demo 重要包koa-router koa-bodyparser koa-jwt 123456789// hello worldconst Koa = require('koa');const app = new Koa();app.use(async ctx =&gt; &#123; ctx.body = 'Hello World';&#125;);app.listen(3000); 应用级中间件app. next1234//next匹配到路由以后继续向下router.get('/news',async(ctx,net)=&gt;&#123; await next();&#125;) 路由级中间件12//引入和实例化路由const router = require('koa-router')(); 123456789//路由配置表const user = require('./user');const letter = require('./letter');module.exports = function(app)&#123; //启动路由 app.use(user.routes()).use(user.allowedMethods()); app.use(letter.routes()).use(letter.allowedMethods());&#125; KOA中间件执行流程洋葱 错误处理中间件1234567app.use(async(ctx,next)=&gt;&#123; next(); if(ctx.status===404)&#123; ctx.status=404 ctx.body=\"404\"; //重定向404 &#125;&#125;) 第三方中间件123456789101112131415//koa-staticconst static = require('koa-static');const staticPath = './static';app.use(static( path.join(__dirname,staticPath)))// koa-bodyparserconst bodyParser=require('koa-bodyparser');app.use(bodyParser());app.use(async ctx =&gt; &#123; // the parsed body will store in ctx.request.body // if nothing was parsed, body will be an empty object &#123;&#125; ctx.body = ctx.request.body;&#125;); 模板ejsart-template cookie session123456ctx.cookies.set('token','123',&#123; maxAge:3600, path:'/news',//配置可以访问的路径 httpOnly:true, //true只有服务器可以访问 false表示客户端都可以访问 domain:'' //域名默认当前域 .baidu.com 子域可以共享cookies数据&#125;)","categories":[],"tags":[{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"前端工具方法集合","slug":"basic/js/前端工具方法集合","date":"2020-05-26T01:42:04.000Z","updated":"2022-03-17T15:15:23.540Z","comments":true,"path":"2020/05/26/basic/js/前端工具方法集合/","link":"","permalink":"http://yoursite.com/2020/05/26/basic/js/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/","excerpt":"","text":"1.邮箱 123export const isEmail &#x3D; (s) &#x3D;&gt; &#123; return &#x2F;^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$&#x2F;.test(s)&#125; 2.手机号码 123export const isMobile &#x3D; (s) &#x3D;&gt; &#123; return &#x2F;^1[0-9]&#123;10&#125;$&#x2F;.test(s)&#125; 3.电话号码 123export const isPhone &#x3D; (s) &#x3D;&gt; &#123; return &#x2F;^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$&#x2F;.test(s)&#125; 4.是否url地址 123export const isURL &#x3D; (s) &#x3D;&gt; &#123; return &#x2F;^http[s]?:\\&#x2F;\\&#x2F;.*&#x2F;.test(s)&#125; 5.是否字符串 123export const isString &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;String&#39;&#125; 6.是否数字 123export const isNumber &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Number&#39;&#125; 7.是否boolean 123export const isBoolean &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Boolean&#39;&#125; 8.是否函数 123export const isFunction &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Function&#39;&#125; 9.是否为null 123export const isNull &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Null&#39;&#125; 10.是否undefined 123export const isUndefined &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Undefined&#39;&#125; 11.是否对象 123export const isObj &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Object&#39;&#125; 12.是否数组 123export const isArray &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Array&#39;&#125; 13.是否时间 123export const isDate &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Date&#39;&#125; 14.是否正则 123export const isRegExp &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;RegExp&#39;&#125; 15.是否错误对象 123export const isError &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Error&#39;&#125; 16.是否Symbol函数 123export const isSymbol &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Symbol&#39;&#125; 17.是否Promise对象 123export const isPromise &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Promise&#39;&#125; 18.是否Set对象 1234export const isSet &#x3D; (o) &#x3D;&gt; &#123; return Object.prototype.toString.call(o).slice(8, -1) &#x3D;&#x3D;&#x3D; &#39;Set&#39;&#125;export const ua &#x3D; navigator.userAgent.toLowerCase(); 19.是否是微信浏览器 123export const isWeiXin &#x3D; () &#x3D;&gt; &#123; return ua.match(&#x2F;microMessenger&#x2F;i) &#x3D;&#x3D; &#39;micromessenger&#39;&#125; 20.是否是移动端 123export const isDeviceMobile &#x3D; () &#x3D;&gt; &#123; return &#x2F;android|webos|iphone|ipod|balckberry&#x2F;i.test(ua)&#125; 21.是否是QQ浏览器 123export const isQQBrowser &#x3D; () &#x3D;&gt; &#123; return !!ua.match(&#x2F;mqqbrowser|qzone|qqbrowser|qbwebviewtype&#x2F;i)&#125; 22.是否是爬虫 123export const isSpider &#x3D; () &#x3D;&gt; &#123; return &#x2F;adsbot|googlebot|bingbot|msnbot|yandexbot|baidubot|robot|careerbot|seznambot|bot|baiduspider|jikespider|symantecspider|scannerlwebcrawler|crawler|360spider|sosospider|sogou web sprider|sogou orion spider&#x2F;.test(ua)&#125; 23.是否ios 12345export const whichDevice &#x3D; (device) &#x3D;&gt; &#123; var u &#x3D; navigator.userAgent; return u.indexOf(device) &gt; -1&#125;&#x2F;&#x2F; iPhone Android Linux iPad Windows Phone 24.是否为PC端 1234567891011121314export const isPC &#x3D; () &#x3D;&gt; &#123; var userAgentInfo &#x3D; navigator.userAgent; var Agents &#x3D; [&quot;Android&quot;, &quot;iPhone&quot;, &quot;SymbianOS&quot;, &quot;Windows Phone&quot;, &quot;iPad&quot;, &quot;iPod&quot;]; var flag &#x3D; true; for (var v &#x3D; 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag &#x3D; false; break; &#125; &#125; return flag;&#125; 25.去除html标签 123export const removeHtmltag &#x3D; (str) &#x3D;&gt; &#123; return str.replace(&#x2F;&lt;[^&gt;]+&gt;&#x2F;g, &#39;&#39;)&#125; 26.获取url参数 123456export const getQueryString &#x3D; (name) &#x3D;&gt; &#123; const reg &#x3D; new RegExp(&#39;(^|&amp;)&#39; + name + &#39;&#x3D;([^&amp;]*)(&amp;|$)&#39;, &#39;i&#39;); const search &#x3D; window.location.search.split(&#39;?&#39;)[1] || &#39;&#39;; const r &#x3D; search.match(reg) || []; return r[2];&#125; 27.动态引入js 12345678export const injectScript &#x3D; (src) &#x3D;&gt; &#123; const s &#x3D; document.createElement(&#39;script&#39;); s.type &#x3D; &#39;text&#x2F;javascript&#39;; s.async &#x3D; true; s.src &#x3D; src; const t &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; t.parentNode.insertBefore(s, t);&#125; 28.根据url地址下载 1234567891011121314151617181920212223export const download &#x3D; (url) &#x3D;&gt; &#123; var isChrome &#x3D; navigator.userAgent.toLowerCase().indexOf(&#39;chrome&#39;) &gt; -1; var isSafari &#x3D; navigator.userAgent.toLowerCase().indexOf(&#39;safari&#39;) &gt; -1; if (isChrome || isSafari) &#123; var link &#x3D; document.createElement(&#39;a&#39;); link.href &#x3D; url; if (link.download !&#x3D;&#x3D; undefined) &#123; var fileName &#x3D; url.substring(url.lastIndexOf(&#39;&#x2F;&#39;) + 1, url.length); link.download &#x3D; fileName; &#125; if (document.createEvent) &#123; var e &#x3D; document.createEvent(&#39;MouseEvents&#39;); e.initEvent(&#39;click&#39;, true, true); link.dispatchEvent(e); return true; &#125; &#125; if (url.indexOf(&#39;?&#39;) &#x3D;&#x3D;&#x3D; -1) &#123; url +&#x3D; &#39;?download&#39;; &#125; window.open(url, &#39;_self&#39;); return true;&#125; 29.el是否包含某个class 1234export const hasClass &#x3D; (el, className) &#x3D;&gt; &#123; let reg &#x3D; new RegExp(&#39;(^|\\\\s)&#39; + className + &#39;(\\\\s|$)&#39;) return reg.test(el.className)&#125; 30.el添加某个class 12345678export const addClass &#x3D; (el, className) &#x3D;&gt; &#123; if (hasClass(el, className)) &#123; return &#125; let newClass &#x3D; el.className.split(&#39; &#39;) newClass.push(className) el.className &#x3D; newClass.join(&#39; &#39;)&#125; 31.el去除某个class 1234567export const removeClass &#x3D; (el, className) &#x3D;&gt; &#123; if (!hasClass(el, className)) &#123; return &#125; let reg &#x3D; new RegExp(&#39;(^|\\\\s)&#39; + className + &#39;(\\\\s|$)&#39;, &#39;g&#39;) el.className &#x3D; el.className.replace(reg, &#39; &#39;)&#125; 32.获取滚动的坐标 1234export const getScrollPosition &#x3D; (el &#x3D; window) &#x3D;&gt; (&#123; x: el.pageXOffset !&#x3D;&#x3D; undefined ? el.pageXOffset : el.scrollLeft, y: el.pageYOffset !&#x3D;&#x3D; undefined ? el.pageYOffset : el.scrollTop&#125;); 33.滚动到顶部 1234567export const scrollToTop &#x3D; () &#x3D;&gt; &#123; const c &#x3D; document.documentElement.scrollTop || document.body.scrollTop; if (c &gt; 0) &#123; window.requestAnimationFrame(scrollToTop); window.scrollTo(0, c - c &#x2F; 8); &#125;&#125; 34.el是否在视口范围内 12345678export const elementIsVisibleInViewport &#x3D; (el, partiallyVisible &#x3D; false) &#x3D;&gt; &#123; const &#123; top, left, bottom, right &#125; &#x3D; el.getBoundingClientRect(); const &#123; innerHeight, innerWidth &#125; &#x3D; window; return partiallyVisible ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp; ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth)) : top &gt;&#x3D; 0 &amp;&amp; left &gt;&#x3D; 0 &amp;&amp; bottom &lt;&#x3D; innerHeight &amp;&amp; right &lt;&#x3D; innerWidth;&#125; 35.洗牌算法随机 12345678910export const shuffle &#x3D; (arr) &#x3D;&gt; &#123; var result &#x3D; [], random; while (arr.length &gt; 0) &#123; random &#x3D; Math.floor(Math.random() * arr.length); result.push(arr[random]) arr.splice(random, 1) &#125; return result;&#125; 36.劫持粘贴板 12345678910111213export const copyTextToClipboard &#x3D; (value) &#x3D;&gt; &#123; var textArea &#x3D; document.createElement(&quot;textarea&quot;); textArea.style.background &#x3D; &#39;transparent&#39;; textArea.value &#x3D; value; document.body.appendChild(textArea); textArea.select(); try &#123; var successful &#x3D; document.execCommand(&#39;copy&#39;); &#125; catch (err) &#123; console.log(&#39;Oops, unable to copy&#39;); &#125; document.body.removeChild(textArea);&#125; 37.判断类型集合 12345678910111213141516171819202122232425262728293031323334353637383940export const checkStr &#x3D; (str, type) &#x3D;&gt; &#123; switch (type) &#123; case &#39;phone&#39;: &#x2F;&#x2F;手机号码 return &#x2F;^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$&#x2F;.test(str); case &#39;tel&#39;: &#x2F;&#x2F;座机 return &#x2F;^(0\\d&#123;2,3&#125;-\\d&#123;7,8&#125;)(-\\d&#123;1,4&#125;)?$&#x2F;.test(str); case &#39;card&#39;: &#x2F;&#x2F;身份证 return &#x2F;(^\\d&#123;15&#125;$)|(^\\d&#123;18&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)&#x2F;.test(str); case &#39;pwd&#39;: &#x2F;&#x2F;密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线 return &#x2F;^[a-zA-Z]\\w&#123;5,17&#125;$&#x2F;.test(str) case &#39;postal&#39;: &#x2F;&#x2F;邮政编码 return &#x2F;[1-9]\\d&#123;5&#125;(?!\\d)&#x2F;.test(str); case &#39;QQ&#39;: &#x2F;&#x2F;QQ号 return &#x2F;^[1-9][0-9]&#123;4,9&#125;$&#x2F;.test(str); case &#39;email&#39;: &#x2F;&#x2F;邮箱 return &#x2F;^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$&#x2F;.test(str); case &#39;money&#39;: &#x2F;&#x2F;金额(小数点2位) return &#x2F;^\\d*(?:\\.\\d&#123;0,2&#125;)?$&#x2F;.test(str); case &#39;URL&#39;: &#x2F;&#x2F;网址 return &#x2F;(http|ftp|https):\\&#x2F;\\&#x2F;[\\w\\-_]+(\\.[\\w\\-_]+)+([\\w\\-\\.,@?^&#x3D;%&amp;:&#x2F;~\\+#]*[\\w\\-\\@?^&#x3D;%&amp;&#x2F;~\\+#])?&#x2F;.test(str) case &#39;IP&#39;: &#x2F;&#x2F;IP return &#x2F;((?:(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d)\\\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\\\d|[01]?\\\\d?\\\\d))&#x2F;.test(str); case &#39;date&#39;: &#x2F;&#x2F;日期时间 return &#x2F;^(\\d&#123;4&#125;)\\-(\\d&#123;2&#125;)\\-(\\d&#123;2&#125;) (\\d&#123;2&#125;)(?:\\:\\d&#123;2&#125;|:(\\d&#123;2&#125;):(\\d&#123;2&#125;))$&#x2F;.test(str) || &#x2F;^(\\d&#123;4&#125;)\\-(\\d&#123;2&#125;)\\-(\\d&#123;2&#125;)$&#x2F;.test(str) case &#39;number&#39;: &#x2F;&#x2F;数字 return &#x2F;^[0-9]$&#x2F;.test(str); case &#39;english&#39;: &#x2F;&#x2F;英文 return &#x2F;^[a-zA-Z]+$&#x2F;.test(str); case &#39;chinese&#39;: &#x2F;&#x2F;中文 return &#x2F;^[\\\\u4E00-\\\\u9FA5]+$&#x2F;.test(str); case &#39;lower&#39;: &#x2F;&#x2F;小写 return &#x2F;^[a-z]+$&#x2F;.test(str); case &#39;upper&#39;: &#x2F;&#x2F;大写 return &#x2F;^[A-Z]+$&#x2F;.test(str); case &#39;HTML&#39;: &#x2F;&#x2F;HTML标记 return &#x2F;&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;&#x2F;.test(str); default: return true; &#125;&#125; 38.严格的身份证校验 1234567891011121314151617181920212223242526272829303132333435export const isCardID &#x3D; (sId) &#x3D;&gt; &#123; if (!&#x2F;(^\\d&#123;15&#125;$)|(^\\d&#123;17&#125;(\\d|X|x)$)&#x2F;.test(sId)) &#123; console.log(&#39;你输入的身份证长度或格式错误&#39;) return false &#125; &#x2F;&#x2F;身份证城市 var aCity &#x3D; &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;; if (!aCity[parseInt(sId.substr(0, 2))]) &#123; console.log(&#39;你的身份证地区非法&#39;) return false &#125; &#x2F;&#x2F; 出生日期验证 var sBirthday &#x3D; (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(&#x2F;-&#x2F;g, &quot;&#x2F;&quot;), d &#x3D; new Date(sBirthday) if (sBirthday !&#x3D; (d.getFullYear() + &quot;&#x2F;&quot; + (d.getMonth() + 1) + &quot;&#x2F;&quot; + d.getDate())) &#123; console.log(&#39;身份证上的出生日期非法&#39;) return false &#125; &#x2F;&#x2F; 身份证号码校验 var sum &#x3D; 0, weights &#x3D; [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2], codes &#x3D; &quot;10X98765432&quot; for (var i &#x3D; 0; i &lt; sId.length - 1; i++) &#123; sum +&#x3D; sId[i] * weights[i]; &#125; var last &#x3D; codes[sum % 11]; &#x2F;&#x2F;计算出来的最后一位身份证号码 if (sId[sId.length - 1] !&#x3D; last) &#123; console.log(&#39;你输入的身份证号非法&#39;) return false &#125; return true&#125; 39.随机数范围 1234567export const random &#x3D; (min, max) &#x3D;&gt; &#123; if (arguments.length &#x3D;&#x3D;&#x3D; 2) &#123; return Math.floor(min + Math.random() * ((max + 1) - min)) &#125; else &#123; return null; &#125;&#125; 40.将阿拉伯数字翻译成中文的大写数字 1234567891011121314151617181920212223242526272829303132333435363738394041export const numberToChinese &#x3D; (num) &#x3D;&gt; &#123; var AA &#x3D; new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;); var BB &#x3D; new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;); var a &#x3D; (&quot;&quot; + num).replace(&#x2F;(^0*)&#x2F;g, &quot;&quot;).split(&quot;.&quot;), k &#x3D; 0, re &#x3D; &quot;&quot;; for (var i &#x3D; a[0].length - 1; i &gt;&#x3D; 0; i--) &#123; switch (k) &#123; case 0: re &#x3D; BB[7] + re; break; case 4: if (!new RegExp(&quot;0&#123;4&#125;&#x2F;&#x2F;d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;) .test(a[0])) re &#x3D; BB[4] + re; break; case 8: re &#x3D; BB[5] + re; BB[7] &#x3D; BB[5]; k &#x3D; 0; break; &#125; if (k % 4 &#x3D;&#x3D; 2 &amp;&amp; a[0].charAt(i + 2) !&#x3D; 0 &amp;&amp; a[0].charAt(i + 1) &#x3D;&#x3D; 0) re &#x3D; AA[0] + re; if (a[0].charAt(i) !&#x3D; 0) re &#x3D; AA[a[0].charAt(i)] + BB[k % 4] + re; k++; &#125; if (a.length &gt; 1) &#x2F;&#x2F; 加上小数部分(如果有小数部分) &#123; re +&#x3D; BB[6]; for (var i &#x3D; 0; i &lt; a[1].length; i++) re +&#x3D; AA[a[1].charAt(i)]; &#125; if (re &#x3D;&#x3D; &#39;一十&#39;) re &#x3D; &quot;十&quot;; if (re.match(&#x2F;^一&#x2F;) &amp;&amp; re.length &#x3D;&#x3D; 3) re &#x3D; re.replace(&quot;一&quot;, &quot;&quot;); return re;&#125; 41.将数字转换为大写金额 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149export const changeToChinese &#x3D; (Num) &#x3D;&gt; &#123; &#x2F;&#x2F;判断如果传递进来的不是字符的话转换为字符 if (typeof Num &#x3D;&#x3D; &quot;number&quot;) &#123; Num &#x3D; new String(Num); &#125;; Num &#x3D; Num.replace(&#x2F;,&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的“,” Num &#x3D; Num.replace(&#x2F; &#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换tomoney()中的空格 Num &#x3D; Num.replace(&#x2F;￥&#x2F;g, &quot;&quot;) &#x2F;&#x2F;替换掉可能出现的￥字符 if (isNaN(Num)) &#123; &#x2F;&#x2F;验证输入的字符是否为数字 &#x2F;&#x2F;alert(&quot;请检查小写金额是否正确&quot;); return &quot;&quot;; &#125;; &#x2F;&#x2F;字符处理完毕后开始转换，采用前后两部分分别转换 var part &#x3D; String(Num).split(&quot;.&quot;); var newchar &#x3D; &quot;&quot;; &#x2F;&#x2F;小数点前进行转化 for (var i &#x3D; part[0].length - 1; i &gt;&#x3D; 0; i--) &#123; if (part[0].length &gt; 10) &#123; return &quot;&quot;; &#x2F;&#x2F;若数量超过拾亿单位，提示 &#125; var tmpnewchar &#x3D; &quot;&quot; var perchar &#x3D; part[0].charAt(i); switch (perchar) &#123; case &quot;0&quot;: tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar; break; &#125; switch (part[0].length - i - 1) &#123; case 0: tmpnewchar &#x3D; tmpnewchar + &quot;元&quot;; break; case 1: if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;; break; case 2: if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;; break; case 3: if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;; break; case 4: tmpnewchar &#x3D; tmpnewchar + &quot;万&quot;; break; case 5: if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;; break; case 6: if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;佰&quot;; break; case 7: if (perchar !&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;仟&quot;; break; case 8: tmpnewchar &#x3D; tmpnewchar + &quot;亿&quot;; break; case 9: tmpnewchar &#x3D; tmpnewchar + &quot;拾&quot;; break; &#125; var newchar &#x3D; tmpnewchar + newchar; &#125; &#x2F;&#x2F;小数点之后进行转化 if (Num.indexOf(&quot;.&quot;) !&#x3D; -1) &#123; if (part[1].length &gt; 2) &#123; &#x2F;&#x2F; alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;); part[1] &#x3D; part[1].substr(0, 2) &#125; for (i &#x3D; 0; i &lt; part[1].length; i++) &#123; tmpnewchar &#x3D; &quot;&quot; perchar &#x3D; part[1].charAt(i) switch (perchar) &#123; case &quot;0&quot;: tmpnewchar &#x3D; &quot;零&quot; + tmpnewchar; break; case &quot;1&quot;: tmpnewchar &#x3D; &quot;壹&quot; + tmpnewchar; break; case &quot;2&quot;: tmpnewchar &#x3D; &quot;贰&quot; + tmpnewchar; break; case &quot;3&quot;: tmpnewchar &#x3D; &quot;叁&quot; + tmpnewchar; break; case &quot;4&quot;: tmpnewchar &#x3D; &quot;肆&quot; + tmpnewchar; break; case &quot;5&quot;: tmpnewchar &#x3D; &quot;伍&quot; + tmpnewchar; break; case &quot;6&quot;: tmpnewchar &#x3D; &quot;陆&quot; + tmpnewchar; break; case &quot;7&quot;: tmpnewchar &#x3D; &quot;柒&quot; + tmpnewchar; break; case &quot;8&quot;: tmpnewchar &#x3D; &quot;捌&quot; + tmpnewchar; break; case &quot;9&quot;: tmpnewchar &#x3D; &quot;玖&quot; + tmpnewchar; break; &#125; if (i &#x3D;&#x3D; 0) tmpnewchar &#x3D; tmpnewchar + &quot;角&quot;; if (i &#x3D;&#x3D; 1) tmpnewchar &#x3D; tmpnewchar + &quot;分&quot;; newchar &#x3D; newchar + tmpnewchar; &#125; &#125; &#x2F;&#x2F;替换所有无用汉字 while (newchar.search(&quot;零零&quot;) !&#x3D; -1) newchar &#x3D; newchar.replace(&quot;零零&quot;, &quot;零&quot;); newchar &#x3D; newchar.replace(&quot;零亿&quot;, &quot;亿&quot;); newchar &#x3D; newchar.replace(&quot;亿万&quot;, &quot;亿&quot;); newchar &#x3D; newchar.replace(&quot;零万&quot;, &quot;万&quot;); newchar &#x3D; newchar.replace(&quot;零元&quot;, &quot;元&quot;); newchar &#x3D; newchar.replace(&quot;零角&quot;, &quot;&quot;); newchar &#x3D; newchar.replace(&quot;零分&quot;, &quot;&quot;); if (newchar.charAt(newchar.length - 1) &#x3D;&#x3D; &quot;元&quot;) &#123; newchar &#x3D; newchar + &quot;整&quot; &#125; return newchar;&#125; 42.判断一个元素是否在数组中 123export const contains &#x3D; (arr, val) &#x3D;&gt; &#123; return arr.indexOf(val) &gt; -1;&#125; 43.数组排序，{type} 1：从小到大 2：从大到小 3：随机 1234567891011121314export const sort &#x3D; (arr, type &#x3D; 1) &#x3D;&gt; &#123; return arr.sort((a, b) &#x3D;&gt; &#123; switch (type) &#123; case 1: return a - b; case 2: return b - a; case 3: return Math.random() - 0.5; default: return arr; &#125; &#125;)&#125; 44.去重 1234567891011121314export const unique &#x3D; (arr) &#x3D;&gt; &#123; if (Array.hasOwnProperty(&#39;from&#39;)) &#123; return Array.from(new Set(arr)); &#125; else &#123; var n &#x3D; &#123;&#125;, r &#x3D; []; for (var i &#x3D; 0; i &lt; arr.length; i++) &#123; if (!n[arr[i]]) &#123; n[arr[i]] &#x3D; true; r.push(arr[i]); &#125; &#125; return r; &#125;&#125; 45.求两个集合的并集 1234export const union &#x3D; (a, b) &#x3D;&gt; &#123; var newArr &#x3D; a.concat(b); return this.unique(newArr);&#125; 46.求两个集合的交集 1234567export const intersect &#x3D; (a, b) &#x3D;&gt; &#123; var _this &#x3D; this; a &#x3D; this.unique(a); return this.map(a, function (o) &#123; return _this.contains(b, o) ? o : null; &#125;);&#125; 47.删除其中一个元素 1234567export const remove &#x3D; (arr, ele) &#x3D;&gt; &#123; var index &#x3D; arr.indexOf(ele); if (index &gt; -1) &#123; arr.splice(index, 1); &#125; return arr;&#125; 48.将类数组转换为数组 123456789export const formArray &#x3D; (ary) &#x3D;&gt; &#123; var arr &#x3D; []; if (Array.isArray(ary)) &#123; arr &#x3D; ary; &#125; else &#123; arr &#x3D; Array.prototype.slice.call(ary); &#125;; return arr;&#125; 49.最大值 123export const max &#x3D; (arr) &#x3D;&gt; &#123; return Math.max.apply(null, arr);&#125; 50.最小值 123export const min &#x3D; (arr) &#x3D;&gt; &#123; return Math.min.apply(null, arr);&#125; 51.求和 12345export const sum &#x3D; (arr) &#x3D;&gt; &#123; return arr.reduce((pre, cur) &#x3D;&gt; &#123; return pre + cur &#125;)&#125; 52.平均值 123export const average &#x3D; (arr) &#x3D;&gt; &#123; return this.sum(arr) &#x2F; arr.length&#125; 53.去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格 123456789101112131415export const trim &#x3D; (str, type) &#x3D;&gt; &#123; type &#x3D; type || 1 switch (type) &#123; case 1: return str.replace(&#x2F;\\s+&#x2F;g, &quot;&quot;); case 2: return str.replace(&#x2F;(^\\s*)|(\\s*$)&#x2F;g, &quot;&quot;); case 3: return str.replace(&#x2F;(^\\s*)&#x2F;g, &quot;&quot;); case 4: return str.replace(&#x2F;(\\s*$)&#x2F;g, &quot;&quot;); default: return str; &#125;&#125; 54.字符转换，type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写 12345678910111213141516171819202122232425262728export const changeCase &#x3D; (str, type) &#x3D;&gt; &#123; type &#x3D; type || 4 switch (type) &#123; case 1: return str.replace(&#x2F;\\b\\w+\\b&#x2F;g, function (word) &#123; return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase(); &#125;); case 2: return str.replace(&#x2F;\\b\\w+\\b&#x2F;g, function (word) &#123; return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase(); &#125;); case 3: return str.split(&#39;&#39;).map(function (word) &#123; if (&#x2F;[a-z]&#x2F;.test(word)) &#123; return word.toUpperCase(); &#125; else &#123; return word.toLowerCase() &#125; &#125;).join(&#39;&#39;) case 4: return str.toUpperCase(); case 5: return str.toLowerCase(); default: return str; &#125;&#125; 55.检测密码强度 12345678910111213141516171819export const checkPwd &#x3D; (str) &#x3D;&gt; &#123; var Lv &#x3D; 0; if (str.length &lt; 6) &#123; return Lv &#125; if (&#x2F;[0-9]&#x2F;.test(str)) &#123; Lv++ &#125; if (&#x2F;[a-z]&#x2F;.test(str)) &#123; Lv++ &#125; if (&#x2F;[A-Z]&#x2F;.test(str)) &#123; Lv++ &#125; if (&#x2F;[\\.|-|_]&#x2F;.test(str)) &#123; Lv++ &#125; return Lv;&#125; 56.函数节流器 123456export const debouncer &#x3D; (fn, time, interval &#x3D; 200) &#x3D;&gt; &#123; if (time - (window.debounceTimestamp || 0) &gt; interval) &#123; fn &amp;&amp; fn(); window.debounceTimestamp &#x3D; time; &#125;&#125; 57.在字符串中插入新字符串 1234export const insertStr &#x3D; (soure, index, newStr) &#x3D;&gt; &#123; var str &#x3D; soure.slice(0, index) + newStr + soure.slice(index); return str;&#125; 58.判断两个对象是否键值相同 1234567891011121314151617export const isObjectEqual &#x3D; (a, b) &#x3D;&gt; &#123; var aProps &#x3D; Object.getOwnPropertyNames(a); var bProps &#x3D; Object.getOwnPropertyNames(b); if (aProps.length !&#x3D;&#x3D; bProps.length) &#123; return false; &#125; for (var i &#x3D; 0; i &lt; aProps.length; i++) &#123; var propName &#x3D; aProps[i]; if (a[propName] !&#x3D;&#x3D; b[propName]) &#123; return false; &#125; &#125; return true;&#125; 59.16进制颜色转RGBRGBA字符串 1234567891011121314151617181920212223export const colorToRGB &#x3D; (val, opa) &#x3D;&gt; &#123; var pattern &#x3D; &#x2F;^(#?)[a-fA-F0-9]&#123;6&#125;$&#x2F;; &#x2F;&#x2F;16进制颜色值校验规则 var isOpa &#x3D; typeof opa &#x3D;&#x3D; &#39;number&#39;; &#x2F;&#x2F;判断是否有设置不透明度 if (!pattern.test(val)) &#123; &#x2F;&#x2F;如果值不符合规则返回空字符 return &#39;&#39;; &#125; var v &#x3D; val.replace(&#x2F;#&#x2F;, &#39;&#39;); &#x2F;&#x2F;如果有#号先去除#号 var rgbArr &#x3D; []; var rgbStr &#x3D; &#39;&#39;; for (var i &#x3D; 0; i &lt; 3; i++) &#123; var item &#x3D; v.substring(i * 2, i * 2 + 2); var num &#x3D; parseInt(item, 16); rgbArr.push(num); &#125; rgbStr &#x3D; rgbArr.join(); rgbStr &#x3D; &#39;rgb&#39; + (isOpa ? &#39;a&#39; : &#39;&#39;) + &#39;(&#39; + rgbStr + (isOpa ? &#39;,&#39; + opa : &#39;&#39;) + &#39;)&#39;; return rgbStr;&#125; 60.追加url参数 1234567891011121314export const appendQuery &#x3D; (url, key, value) &#x3D;&gt; &#123; var options &#x3D; key; if (typeof options &#x3D;&#x3D; &#39;string&#39;) &#123; options &#x3D; &#123;&#125;; options[key] &#x3D; value; &#125; options &#x3D; $.param(options); if (url.includes(&#39;?&#39;)) &#123; url +&#x3D; &#39;&amp;&#39; + options &#125; else &#123; url +&#x3D; &#39;?&#39; + options &#125; return url;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"},{"name":"function","slug":"function","permalink":"http://yoursite.com/tags/function/"}]},{"title":"前端周刊【202005-3】","slug":"weeks/2020/202005-3","date":"2020-05-24T10:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/05/24/weeks/2020/202005-3/","link":"","permalink":"http://yoursite.com/2020/05/24/weeks/2020/202005-3/","excerpt":"","text":"Deno 正式发布，彻底弄明白和 node 的区别 带你实现 react-redux Chrome DevTools中的这些骚操作，你都知道吗 终于讲清楚了nodejs中exports和module.exports的区别","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"uni-app 笔记","slug":"frame/vue/uni-app 笔记","date":"2020-05-23T10:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/05/23/frame/vue/uni-app 笔记/","link":"","permalink":"http://yoursite.com/2020/05/23/frame/vue/uni-app%20%E7%AC%94%E8%AE%B0/","excerpt":"","text":"应用生命周期 onLaunch 当uni-app 初始化完成时触发（全局只触发一次) onShow 当 uni-app 启动，或从后台进入前台显示 onHide 当 uni-app 从前台进入后台 页面生命周期onLoad 监听页面加载，其参数为上个页面传递的数据，参数类型为Object（用于页面传参 onShow 监听页面显示 onReady 监听页面初次渲染完成 onHide 监听页面隐藏 onUnload 监听页面卸载 onPullDownRefresh 监听用户下拉动作 ，一般用于下拉刷新 onReachBottom 页面上拉触底事件的处理函数 onPageScroll 监听页面滚动 ，参数为 Object onTabItemTap 当前是 tab 页时，点击 tab 时触发。 onShareAppMessage 用户点击右上角分享 先触发 uni-app onReady ，后触发 vue 的 mounted 建议使用uni-app的onLoad 代替 vue的 created publicPath 未生效1234567891011121314151617181920212223&lt;image class=\"logo\" src=\"../../static/logo.png\"&gt;&lt;/image&gt;需要这样来写&lt;image class=\"logo\" :src=\"require('../../static/logo.png')\"&gt;&lt;/image&gt;或webpack module.exports = &#123; chainWebpack(webpackConfig) &#123; webpackConfig.module .rule('vue') .test([/\\.vue$/, /\\.nvue$/]) .use('vue-loader') .tap(options =&gt; Object.assign(options, &#123; transformAssetUrls: &#123; 'v-uni-image': 'src' &#125; &#125;)) .end() &#125;, configureWebpack (config) &#123; // ...blablabla &#125;,&#125; uni.getStorageSync &amp;&amp; uni.getStorage经常获取不到值1234567891011121314151617try &#123; const userInfo = uni.getStorageSync('userInfo'); if(userInfo)&#123; // do &#125;&#125;catch(e)&#123; //error&#125;uni.getStorage(&#123; key: 'userInfo', success: function (res) &#123; console.log(res.data); that.seal=res.data &#125;&#125;); store 设计思路123456789101112131415161718192021222324252627282930313233343536373839404142434445import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; hasLogin: false, token:'', userInfo: &#123;&#125; &#125;, mutations: &#123; login(state, provider) &#123; uni.setStorage(&#123;//缓存用户token key: 'token', data: provider &#125;) &#125;, userInfo(state, provider)&#123; state.hasLogin = true; uni.setStorage(&#123;//缓存用户登陆状态 key: 'userInfo', data: provider &#125;) &#125;, logout(state) &#123; state.hasLogin = false; state.userInfo = &#123;&#125;; state.token = ''; uni.removeStorage(&#123; key: 'userInfo' &#125;) uni.removeStorage(&#123; key: 'token' &#125;) uni.reLaunch(&#123; url:'/pages/login/login' &#125;) &#125; &#125;, actions: &#123; &#125;&#125;)export default store $http封装思路123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// config.jsimport request from \"./request\";// 全局配置的请求域名let baseUrl = \"http://localhost:8762\";//可以new多个request来支持多个域名请求let $http = new request(&#123; //接口请求地址 baseUrl: baseUrl, //服务器本地上传文件地址 fileUrl: baseUrl, //设置请求头（如果使用报错跨域问题，可能是content-type请求类型和后台那边设置的不一致） header: &#123; 'content-type': 'application/json;charset=UTF-8' &#125;, //以下是默认值可不写 //是否提示--默认提示 isPrompt: true, //是否显示请求动画 load: true, //是否使用处理数据模板 isFactory: true&#125;);//当前接口请求数let requestNum = 0;//请求开始拦截器$http.requestStart = function(options) &#123; if (options.load) &#123; if (requestNum &lt;= 0) &#123; //打开加载动画 uni.showLoading(&#123; title: '加载中', mask: true &#125;); &#125; requestNum += 1; &#125; // 图片上传大小限制 if (options.method == \"FILE\" &amp;&amp; options.maxSize) &#123; // 文件最大字节: options.maxSize 可以在调用方法的时候加入参数 maxSize = options.maxSize; for (let item of options.files) &#123; if (item.size &gt; maxSize) &#123; setTimeout(() =&gt; &#123; uni.showToast(&#123; title: \"图片过大，请重新上传\", icon: \"none\" &#125;); &#125;, 500); return false; &#125; &#125; &#125; //请求前加入token options.header['token'] = \"1234568\"; return options;&#125;//请求结束$http.requestEnd = function(options, resolve) &#123; //判断当前接口是否需要加载动画 if (options.load) &#123; requestNum = requestNum - 1; if (requestNum &lt;= 0) &#123; uni.hideLoading(); &#125; &#125; if (resolve.errMsg &amp;&amp; resolve.statusCode &amp;&amp; resolve.statusCode &gt; 300) &#123; setTimeout(() =&gt; &#123; uni.showToast(&#123; title: \"网络错误，请检查一下网络\", icon: \"none\" &#125;); &#125;, 500); &#125;&#125;//登录弹窗次数let loginPopupNum = 0;//所有接口数据处理（可在接口里设置不调用此方法）//此方法需要开发者根据各自的接口返回类型修改，以下只是模板$http.dataFactory = function(res) &#123; // 判断接口请求是否成功 if (res.response.statusCode &amp;&amp; res.response.statusCode == 200) &#123; let httpData = res.response.data; /*********以下只是模板(及共参考)，需要开发者根据各自的接口返回类型修改*********/ //判断数据是否请求成功 if (httpData.success) &#123; // 返回正确的结果(then接受数据) res.resolve(httpData); &#125; else &#123; //其他错误提示 if (res.isPrompt) &#123; //设置可以提示的时候 setTimeout(function() &#123; uni.showToast(&#123; title: httpData.msg, //提示后台接口抛出的错误信息 icon: \"none\", duration: 3000 &#125;); &#125;, 500); &#125; // 返回错误的结果(catch接受数据) res.reject(res.response); &#125; /*********以上只是模板(及共参考)，需要开发者根据各自的接口返回类型修改*********/ &#125; else &#123; // 返回错误的结果(catch接受数据) res.reject(res.response); &#125;&#125;;export default $http; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226//request.jsexport default class request &#123; constructor(options) &#123; //请求公共地址 this.baseUrl = options.baseUrl || \"\"; //公共文件上传请求地址 this.fileUrl = options.fileUrl || \"\"; //默认请求头 this.header = options.header || &#123;&#125;; //默认配置 this.config = &#123; isPrompt: options.isPrompt === false ? false : true, load: options.load === false ? false : true, isFactory: options.isFactory === false ? false : true, loadMore: options.loadMore === false ? false : true &#125;; &#125; // 获取默认信息 getDefault(data, options = &#123;&#125;) &#123; //判断url是不是链接 let urlType = /^([hH][tT]&#123;2&#125;[pP]:\\/\\/|[hH][tT]&#123;2&#125;[pP][sS]:\\/\\/)(([A-Za-z0-9-~]+).)+([A-Za-z0-9-~/])+$/.test(data.url); let config = Object.assign(&#123;&#125;, this.config, options, data); if (data.method == \"FILE\") &#123; config.url = urlType ? data.url : this.fileUrl + data.url; &#125; else &#123; config.url = urlType ? data.url : this.baseUrl + data.url; &#125; //请求头 if (options.header) &#123; config.header = Object.assign(&#123;&#125;, this.header, options.header); &#125; else if (data.header) &#123; config.header = Object.assign(&#123;&#125;, this.header, data.header); &#125; else &#123; config.header = this.header; &#125; return config; &#125; //post请求 post(url = '', data = &#123;&#125;, options = &#123;&#125;) &#123; return this.request(&#123; method: \"POST\", data: data, url: url, ...options &#125;); &#125; //get请求 get(url = '', data = &#123;&#125;, options = &#123;&#125;) &#123; return this.request(&#123; method: \"GET\", data: data, url: url, ...options &#125;); &#125; //put请求 put(url = '', data = &#123;&#125;, options = &#123;&#125;) &#123; return this.request(&#123; method: \"PUT\", data: data, url: url, ...options &#125;); &#125; //delete请求 delete(url = '', data = &#123;&#125;, options = &#123;&#125;) &#123; return this.request(&#123; method: \"DELETE\", data: data, url: url, ...options &#125;); &#125; //接口请求方法 request(data) &#123; return new Promise((resolve, reject) =&gt; &#123; if (!data.url) &#123; console.log(\"request缺失数据url\"); reject(&#123; errMsg: \"缺失数据url\", statusCode: 0 &#125;); return; &#125; let requestInfo = this.getDefault(data); //请求前回调 if (this.requestStart) &#123; let requestStart = this.requestStart(requestInfo); if (typeof requestStart == \"object\") &#123; requestInfo.data = requestStart.data; requestInfo.header = requestStart.header; requestInfo.isPrompt = requestStart.isPrompt; requestInfo.load = requestStart.load; requestInfo.isFactory = requestStart.isFactory; &#125; else &#123; //请求完成回调 _this.requestEnd &amp;&amp; _this.requestEnd(requestInfo, &#123; errMsg: \"请求开始拦截器未通过\", statusCode: 0 &#125;); reject(&#123; errMsg: \"请求开始拦截器未通过\", statusCode: 0 &#125;); return; &#125; &#125; let requestData = &#123; url: requestInfo.url, header: requestInfo.header, //加入请求头 success: (res) =&gt; &#123; //请求完成回调 this.requestEnd &amp;&amp; this.requestEnd(requestInfo, res); //是否用外部的数据处理方法 if (requestInfo.isFactory &amp;&amp; this.dataFactory) &#123; //数据处理 this.dataFactory(&#123; ...requestInfo, response: res, resolve: resolve, reject: reject &#125;); &#125; else &#123; resolve(res); &#125; &#125;, fail: (err) =&gt; &#123; console.log(\"err\"); //请求完成回调 this.requestEnd &amp;&amp; this.requestEnd(requestInfo, err); reject(err); &#125; &#125;; //请求类型 if (requestInfo.method) &#123; requestData.method = requestInfo.method; &#125; if (requestInfo.data) &#123; requestData.data = requestInfo.data; &#125; // #ifdef MP-WEIXIN || MP-ALIPAY if (requestInfo.timeout) &#123; requestData.timeout = requestInfo.timeout; &#125; // #endif if (requestInfo.dataType) &#123; requestData.dataType = requestInfo.dataType; &#125; // #ifndef APP-PLUS || MP-ALIPAY if (requestInfo.responseType) &#123; requestData.responseType = requestInfo.responseType; &#125; // #endif // #ifdef H5 if (requestInfo.withCredentials) &#123; requestData.withCredentials = requestInfo.withCredentials; &#125; // #endif uni.request(requestData); &#125;); &#125; //jsonp请求(只限于H5使用) jsonp(url = '', data = &#123;&#125;, options = &#123;&#125;) &#123; let requestInfo = this.getDefault(&#123; method: \"JSONP\", data: data, url: url, &#125;, options); let dataStr = ''; Object.keys(data).forEach(key =&gt; &#123; dataStr += key + '=' + data[key] + '&amp;'; &#125;); //匹配最后一个&amp;并去除 if (dataStr !== '') &#123; dataStr = dataStr.substr(0, dataStr.lastIndexOf('&amp;')); &#125; requestInfo.url = requestInfo.url + '?' + dataStr; const _this = this; return new Promise((resolve, reject) =&gt; &#123; let callbackName = \"callback\" + Math.ceil(Math.random() * 1000000); if (_this.requestStart) &#123; requestInfo.data = data; let requestStart = _this.requestStart(requestInfo); if (typeof requestStart == \"object\") &#123; requestInfo.data = requestStart.data; requestInfo.header = requestStart.header; requestInfo.isPrompt = requestStart.isPrompt; requestInfo.load = requestStart.load; requestInfo.isFactory = requestStart.isFactory; &#125; else &#123; //请求完成回调 _this.requestEnd &amp;&amp; _this.requestEnd(requestInfo, &#123; errMsg: \"请求开始拦截器未通过\", statusCode: 0 &#125;); reject(&#123; errMsg: \"请求开始拦截器未通过\", statusCode: 0 &#125;); return; &#125; &#125; // #ifdef H5 window[callbackName] = function(data) &#123; resolve(data); &#125; let script = document.createElement(\"script\"); script.src = requestInfo.url + \"&amp;callback=\" + callbackName; document.head.appendChild(script); // 及时删除，防止加载过多的JS document.head.removeChild(script); // #endif //请求完成回调 _this.requestEnd &amp;&amp; _this.requestEnd(requestInfo, &#123; errMsg: \"request:ok\", statusCode: 200 &#125;); &#125;); &#125;&#125;","categories":[],"tags":[{"name":"uni","slug":"uni","permalink":"http://yoursite.com/tags/uni/"}]},{"title":"如何配置一台新的云服务器","slug":"build/如何配置一台新的云服务器","date":"2020-05-17T10:42:04.000Z","updated":"2022-03-17T15:15:23.570Z","comments":true,"path":"2020/05/17/build/如何配置一台新的云服务器/","link":"","permalink":"http://yoursite.com/2020/05/17/build/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E5%8F%B0%E6%96%B0%E7%9A%84%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"安装yum1234567wget http://yum.baseurl.org/download/3.2/yum-3.2.28.tar.gztar xvf yum-3.2.28.tar.gz cd yum-3.2.28 ./yummain.py install yum yum check-update yum update yum clean all 安装node12345678910cd /usr/local/node/wget node-v11.12.0-linux-x64.tar.gztar -zxvf node-v11.12.0-linux-x64.tar.gzcd node-v11.12.0-linux-x64# 创建软连接ln -s /usr/local/node/node-v11.12.0-linux-x64/bin/npm /usr/local/bin/npmln -s /usr/local/node/node-v11.12.0-linux-x64/bin/node /usr/local/bin/nodeln -s /usr/local/node/node-v11.12.0-linux-x64/bin/npx /usr/local/bin/npx mysql 5.7123456789101112131415161718# 安装wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpmyum -y install mysql57-community-release-el7-10.noarch.rpmyum -y install mysql-community-server# 启动systemctl start mysqld.service # 状态systemctl status mysqld.service# 找密码 G9hLnliLXd?pgrep \"password\" /var/log/mysqld.log# 进入rootmysql -uroot -p# 修改密码 降低复杂难度mysql&gt; set global validate_password_policy=0;mysql&gt; set global validate_password_length=1;mysql&gt; ALTER USER 'root'@'localhost' IDENTIFIED BY 'password';# del Yum Repositoryyum -y remove mysql57-community-release-el7-10.noarch 设置mysql远程访问12345mysql -u root -p;mysql&gt;use mysql;mysql&gt;update user set host = '%' where user = 'root';mysql&gt;select host, user from user;flush privileges; 允许服务器的远程连接1234567891011121314vim /etc/ssh/sshd_config#将 #PermitRootLogin yes 这一行的注释去掉#，这样就可以允许远程连接了# 重启ssh服务：systemctl restart sshdsystemctl status sshd （能查看到服务正常了）# 此时应该就可以远程连接服务器了，如果还不能连接，有如下提示：#ECDSA host key “ip地址” for has changed and you have requested strict checking#解决方法：https://blog.csdn.net/weixin_40712763/article/details/82292185ssh-keygen -R “你的远程服务器ip地址” 前端相关安装nimg 服务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. 下载NImgwget https:&#x2F;&#x2F;github.com&#x2F;ofpay&#x2F;nimg&#x2F;archive&#x2F;master.zip -O nimg.zip2. 解压刚才下载的文件nimg.zip unzip nimg.zip3.安装依赖模块组 cd nimg-master npm install4.修改配置，确保图片存储以及上传目录有足够的权限vi config.jsexports.tmproot&#x3D;&#39;&#x2F;node&#x2F;temp&#39;; &#x2F;&#x2F;上传临时目录，exports.imgroot&#x3D;&#39;&#x2F;node&#x2F;img&#39;; &#x2F;&#x2F;图片存储目录，exports.errorlog&#x3D;&#39;&#x2F;node&#x2F;log&#x2F;error.log&#39;; &#x2F;&#x2F;程序错误日志，记录exports.port&#x3D;9000; &#x2F;&#x2F;http端口号exports.appname&#x3D;&#39;NImg&#39;;exports.maxFileSize&#x3D;1024*1024;&#x2F;&#x2F;上传最大限制单位字节 1024kb 1mbexports.maxSide&#x3D;800; &#x2F;&#x2F;最大截图边长exports.minSide&#x3D;30; &#x2F;&#x2F;最小截图边长 &#x2F;&#x2F;支持图像文件类型exports.imgtypes&#x3D;&#123; &quot;gif&quot;: &quot;image&#x2F;gif&quot;, &quot;jpeg&quot;: &quot;image&#x2F;jpeg&quot;, &quot;jpg&quot;: &quot;image&#x2F;jpeg&quot;, &quot;png&quot;: &quot;image&#x2F;png&quot;&#125;; 5.启动sh nimg.sh start6.查看控制台输出taillf nohup.out7.关闭sh nimg.sh stop# nimg 压缩convent图片 缺少ImageMagick 巨坑yum install -y libjpeg* libpng* libtiff* libungif* freetype zlibwget https:&#x2F;&#x2F;www.imagemagick.org&#x2F;download&#x2F;ImageMagick.tar.gztar zxvf ImageMagick.tar.gzcd ImageMagick.tar.gz.&#x2F;configuremakemake installldconfig &#x2F;usr&#x2F;local&#x2F;lib检测是否成功 convert -version 一定一定要先测试上传 有坑Error: Buffer.write(string, encoding, offset[, length]) is no longer supported #6package.json 里边 改下express版本， “express”: “3.21.2” pm2 进程管理12345678npm install -g pm2ln -s /usr/local/node/node-v11.12.0-linux-x64/bin/pm2 /usr/local/bin/pm2 listpm2 startpm2 stop allpm2 restart app.jspm2 delete 0 nginx1234567891011121314151617181920# 相关依赖yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel pcre-devel# installmkdir /usr/local/nginxwget http://nginx.org/download/nginx-1.18.0.tar.gztar zxvf nginx-1.18.0.tar.gzcd nginx-1.18.0./configuremake &amp;&amp; make install# nginx 无效或log不存在/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf# HTTPS 安装注意./configure --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module# 编译make# 关闭/usr/local/nginx/sbin/nginx -s stop# 覆盖cp ./objs/nginx /usr/local/nginx/sbin/ 其他相关1234# 删除端口netstat -ntlplsof -i tcp:portkill -9 pid gitlab12345678910111213141516$ docker pull gitlab/gitlab-ce$ docker run -d -p 443:443 -p 6001:80 -p 222:22 --name gitlab --restart always -v /home/gitlab/config:/etc/gitlab -v /home/gitlab/logs:/var/log/gitlab -v /home/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce# -d：后台运行# -p：将容器内部端口向外映射# --name：命名容器名称# -v：将容器内数据文件夹或者日志、配置等文件夹挂载到宿主机指定目录external_url 'http://192.168.199.231'# 配置ssh协议所使用的访问地址和端口gitlab_rails['gitlab_ssh_host'] = '192.168.199.231'gitlab_rails['gitlab_shell_ssh_port'] = 222 # 此端口是run时22端口映射的222端口:wq #保存配置文件并退出$ docker restart gitlab","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"yum","slug":"yum","permalink":"http://yoursite.com/tags/yum/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"aliyun","slug":"aliyun","permalink":"http://yoursite.com/tags/aliyun/"},{"name":"pm2","slug":"pm2","permalink":"http://yoursite.com/tags/pm2/"},{"name":"nimg","slug":"nimg","permalink":"http://yoursite.com/tags/nimg/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}]},{"title":"HTML状态码常规总结","slug":"build/http/HTML状态码常规总结","date":"2020-05-14T10:42:04.000Z","updated":"2022-03-17T15:15:23.560Z","comments":true,"path":"2020/05/14/build/http/HTML状态码常规总结/","link":"","permalink":"http://yoursite.com/2020/05/14/build/http/HTML%E7%8A%B6%E6%80%81%E7%A0%81%E5%B8%B8%E8%A7%84%E6%80%BB%E7%BB%93/","excerpt":"","text":"1、消息类这一类型的状态码，代表请求已被接受，需要继续处理。 123100 Continue：服务器已经接收到请求头，并且客户端应继续发送请求主体101 Switching Protocols：服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。102 Processing：服务器已经收到并正在处理请求，但无响应可用。 2、成功类这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。 123200 OK：请求已成功。201 Created：请求已经被实现。202 Accepted：服务器已接受请求，但尚未处理复制代码 3、重定向这类状态码代表需要客户端采取进一步的操作才能完成请求 1234301 Moved Permanently：被请求的资源已永久移动到新位置。302 临时移动，转为GET，跳新URL。304 Not Modified：表示资源未被修改复制代码307 与302类似，可被保确保请求主体和消息主体不改变。 4、客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。 1234400 Bad Request：由于明显的客户端错误，服务器不能或不会处理该请求。401 Unauthorized：401语义即“未认证”，即用户没有必要的凭据。403 Forbidden：服务器已经理解请求，但是拒绝执行它。404 Not Found：请求失败，请求所希望得到的资源未被在服务器上发现，但允许用户的后续请求。 5、服务器错误表示服务器无法完成明显有效的请求。 12345500 Internal Server Error: 通用错误消息，服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。501 Not Implemented: 服务器不支持当前请求所需要的某个功能。502 BAD GATEWAY 网关或代理服务器发起请求，无效响应。503 Service Unavailable: 由于临时的服务器维护或者过载，服务器当前无法处理请求。504 GATE TIMEOUT 超时，未能从上游收到响应。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"}]},{"title":"nginx的location、root、alias指令用法和区别","slug":"build/nginx指令用法和区别","date":"2020-05-13T10:42:04.000Z","updated":"2022-03-17T15:15:23.570Z","comments":true,"path":"2020/05/13/build/nginx指令用法和区别/","link":"","permalink":"http://yoursite.com/2020/05/13/build/nginx%E6%8C%87%E4%BB%A4%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/","excerpt":"","text":"转载请注明本文地址: https://www.nginx.cn/4658.html nginx指定文件路径有两种方式root和alias，指令的使用方法和作用域： [root]语法：root path默认值：root html配置段：http、server、location、if [alias]语法：alias path配置段：location root与alias主要区别在于nginx如何解释location后面的uri，这会使两者分别以不同的方式将请求映射到服务器文件上。root的处理结果是：root路径＋location路径alias的处理结果是：使用alias路径替换location路径alias是一个目录别名的定义，root则是最上层目录的定义。还有一个重要的区别是alias后面必须要用“/”结束，否则会找不到文件的。。。而root则可有可无~~ root实例： 123location ^~ &#x2F;t&#x2F; &#123; root &#x2F;www&#x2F;root&#x2F;html&#x2F;;&#125; 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/t/a.html的文件。 alias实例： 123location ^~ &#x2F;t&#x2F; &#123; alias &#x2F;www&#x2F;root&#x2F;html&#x2F;new_t&#x2F;;&#125; 如果一个请求的URI是/t/a.html时，web服务器将会返回服务器上的/www/root/html/new_t/a.html的文件。注意这里是new_t，因为alias会把location后面配置的路径丢弃掉，把当前匹配到的目录指向到指定的目录。 注意： 使用alias时，目录名后面一定要加”/“。 alias在使用正则匹配时，必须捕捉要匹配的内容并在指定的内容处使用。 alias只能位于location块中。（root可以不放在location中）","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"前端资源预加载 resloader.js","slug":"basic/js/前端资源预加载js","date":"2020-05-12T01:42:04.000Z","updated":"2022-03-17T15:15:23.540Z","comments":true,"path":"2020/05/12/basic/js/前端资源预加载js/","link":"","permalink":"http://yoursite.com/2020/05/12/basic/js/%E5%89%8D%E7%AB%AF%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BDjs/","excerpt":"","text":"为什么需要资源预加载预加载的资源，浏览器会缓存下来 资源预加载的场景范围应该锁定单页面应用，SPA的视图一般都是一步一步来呈现的，各种资源通过异步请求来获取，为了追求原生app般的流畅体验，可以把一些资源预加载下来。当然对于一些业务相关的图片资源，也可考虑延迟加载，但延迟加载不是本文讨论的范畴。 视图/图片较多的专题页面，或者是需要逐帧图片来完成的动画效果，最好都要做预加载。 HTML5游戏，图片一般都比较多，而且很多逐帧动画，必须要预加载，事实上一些游戏引擎都会提供相应功能。 哪些资源需要预加载呢？web中包含的资源有很多种，图片、音视频之类的媒体文件 js、css文件不需进行预加载。现在写js基本都用requirejs之类的加载器，而且最后都会进行压缩合并，将请求数降到最低，最终只有一个文件，有些团队甚至还将压缩后的代码直接放在行内，这样一个多余的请求都没有了。 那么需要预加载的就是媒体文件了，图片、音视频之类。这类资源也得根据实际情况来选择哪些需要预加载。比如大多数页面装饰性图片就需要预加载，而由业务动态获取的图片则无法预加载（预先不知道地址）。用作音效、小动画的音视频可以预加载，一个半小时长的视频就不能预加载了。 resLoader.js 自定义资源列表，用于预加载 自定义onProgress，想展示成进度条还是百分比数字还是个性的设计都可 开始和结束可配置回调函数 只支持图片的预加载 支持amd、cmd加载器加载，同时支持直接用标签引入使用 不依赖其他库 123456789101112131415161718192021222324252627282930var loader = new resLoader(&#123; resources : [ 'http://p2.qhimg.com/t01ed1438874f940dc0.jpg', 'http://p9.qhimg.com/t01b4ff03b72c7dc6c7.jpg', 'http://p2.qhimg.com/t01dd90dfbec92074d0.jpg', 'http://p7.qhimg.com/t01cfec6d87cde457c5.jpg', 'http://p9.qhimg.com/t01943ced462da67833.jpg', 'http://p0.qhimg.com/t01943ced462da67833.jpg', 'http://p6.qhimg.com/t01aa15a7ba7ccb49a7.jpg', 'http://p8.qhimg.com/t010f1e8badf1134376.jpg', 'http://p8.qhimg.com/t01cf37ea915533a032.jpg', 'http://p3.qhimg.com/t0193d8a3963e1803e9.jpg', 'http://p3.qhimg.com/t01cd6a4d4b4bd4457b.jpg' ], onStart : function(total)&#123; console.log('start:'+total); &#125;, onProgress : function(current, total)&#123; console.log(current+'/'+total); var percent = current/total*100; $('.progressbar').css('width', percent+'%'); $('.progresstext .current').text(current); $('.progresstext .total').text(total); &#125;, onComplete : function(total)&#123; alert('加载完毕:'+total+'个资源'); &#125;&#125;);loader.start(); 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; //AMD define(factory); &#125; else if (typeof exports === 'object') &#123; //Node, CommonJS之类的 module.exports = factory(); &#125; else &#123; //浏览器全局变量(root 即 window) root.resLoader = factory(root); &#125;&#125;(this, function () &#123; var isFunc = function(f)&#123; return typeof f === 'function'; &#125; //构造器函数 function resLoader(config)&#123; this.option = &#123; resourceType : 'image', //资源类型，默认为图片 baseUrl : './', //基准url resources : [], //资源路径数组 onStart : null, //加载开始回调函数，传入参数total onProgress : null, //正在加载回调函数，传入参数currentIndex, total onComplete : null //加载完毕回调函数，传入参数total &#125; if(config)&#123; for(i in config)&#123; this.option[i] = config[i]; &#125; &#125; else&#123; alert('参数错误！'); return; &#125; this.status = 0; //加载器的状态，0：未启动 1：正在加载 2：加载完毕 this.total = this.option.resources.length || 0; //资源总数 this.currentIndex = 0; //当前正在加载的资源索引 &#125;; resLoader.prototype.start = function()&#123; this.status = 1; var _this = this; var baseUrl = this.option.baseUrl; for(var i=0,l=this.option.resources.length; i&lt;l; i++)&#123; var r = this.option.resources[i], url = ''; if(r.indexOf('http://')===0 || r.indexOf('https://')===0)&#123; url = r; &#125; else&#123; url = baseUrl + r; &#125; var image = new Image(); image.onload = function()&#123;_this.loaded();&#125;; image.onerror = function()&#123;_this.loaded();&#125;; image.src = url; &#125; if(isFunc(this.option.onStart))&#123; this.option.onStart(this.total); &#125; &#125; resLoader.prototype.loaded = function()&#123; if(isFunc(this.option.onProgress))&#123; this.option.onProgress(++this.currentIndex, this.total); &#125; //加载完毕 if(this.currentIndex===this.total)&#123; if(isFunc(this.option.onComplete))&#123; this.option.onComplete(this.total); &#125; &#125; &#125; //暴露公共方法 return resLoader;&#125;)); preload.js使用了XHR2来提供实时的加载进度信息，如果不支持则使用标签式的简化进度来实现进度展示，支持支持多队列，多连接，暂停队列 在PreloadJS中，LoadQueue是主要用来预加载内容的API，LoadQueue是一个加载管理器即：可以预先加载一个文件或者一个文件队列传递的参数是boolean类型，false则强制使用标签式的加载，LoadQueue支持的相关的文件: BINARY: XHR调用的二进制文件TEXT: 文本文件 - 仅支持XHRCSS: CSS文件IMAGE: 一般图片文件格式JAVASCRIPT: JavaScript文件JSON: JSON数据XML: XML数据JSONP: 跨域JSON文件SOUND: 音频文件VIDEO: 视频文件SVG: SVG文件MANIFEST: JSON格式的文件列表LoadQueue包含了以下几个常用的监听事件： complete: 当队列完成加载所有文件时。error: 当队列与任何文件遇到错误时。progress: 对于整个队列进展已经改变。fileload: 单个文件已完成加载。fileprogress: 单个文件进度变化。注意,只有文件装载XHR(或可能通过插件)将 file 事件进展除了0或100%。 12// 初始化加载管理器：（创建队列）var preload = new createjs.LoadQueue(true); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .loading &#123; display: table; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #00ffb1; &#125; .loading &gt; .progress &#123; display: table-cell; vertical-align: middle; text-align: center; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"loading\"&gt; &lt;div class=\"progress\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;img src=\"images/ts.jpg\" style=\"display: none\"/&gt; &lt;script src=\"js/jquery-3.3.1.js\"&gt;&lt;/script&gt; &lt;script src=\"js/preloadjs.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;script&gt; var preload; var mainfest; // 初始化预加载manifest清单 function setupManifest()&#123; mainfest = [ &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125;, &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125;, &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125;, &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125;, &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125;, &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125;, &#123; src:\"images/ts.jpg\"&#125; , &#123; src:\"images/ts.jpg\"&#125; ]; &#125; // 预加载函数 function startPreload() &#123; preload = new createjs.LoadQueue(true); //注意加载音频文件需要调用如下代码行 preload.installPlugin(createjs.SOUND); //为preloaded添加整个队列变化时展示的进度事件 preload.addEventListener(\"progress\",handleFileProgress); //为preloaded添加当队列完成全部加载后触发事件 preload.addEventListener(\"complete\",loadComplete); //设置最大并发连接数 最大值为10 preload.setMaxConnections(1); preload.loadManifest(mainfest); &#125; // 当整个队列变化时展示的进度事件的处理函数 function handleFileProgress(event) &#123; $(\".progress\").text(\"loading...\"+Math.ceil(event.loaded * 100)+ \"%\"); console.log(event.loaded); &#125; // 处理preload添加当队列完成全部加载后触发事件 function loadComplete() &#123; // 设置定时器，当全部加载完毕后让100%停留0.4秒，提高用户体验，不至于让用户感觉不到 window.setTimeout(()=&gt;&#123; $(\".loading\").remove(); &#125;,400); &#125; setupManifest(); startPreload(); &lt;/script&gt;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"resloader","slug":"resloader","permalink":"http://yoursite.com/tags/resloader/"},{"name":"资源预加载","slug":"资源预加载","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD/"}]},{"title":"Nginx解决前端跨域问题","slug":"build/nginx解决前端跨域问题","date":"2020-05-10T12:42:04.000Z","updated":"2022-03-17T15:15:23.570Z","comments":true,"path":"2020/05/10/build/nginx解决前端跨域问题/","link":"","permalink":"http://yoursite.com/2020/05/10/build/nginx%E8%A7%A3%E5%86%B3%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"123456789101112131415161718192021location /aoda-web &#123; add_header 'Access-Control-Allow-Origin' $http_origin; add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS'; add_header 'Access-Control-Allow-Headers' 'DNT,web-token,app-token,Authorization,Accept,Origin,Keep-Alive,User-Agent,X-Mx-ReqToken,X-Data-Type,X-Auth-Token,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range'; add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range'; if ($request_method = 'OPTIONS') &#123; add_header 'Access-Control-Max-Age' 1728000; add_header 'Content-Type' 'text/plain; charset=utf-8'; add_header 'Content-Length' 0; return 204; &#125; root html; index index.html index.htm; proxy_pass http://127.0.0.1:8080; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_connect_timeout 5;&#125; 1、Access-Control-Allow-Origin，这里使用变量 $http_origin取得当前来源域，大家说用“*”代表允许所有，我实际使用并不成功，原因未知； 2、Access-Control-Allow-Credentials，为 true 的时候指请求时可带上Cookie，自己按情况配置吧； 3、Access-Control-Allow-Methods，OPTIONS一定要有的，另外一般也就GET和POST，如果你有其它的也可加进去； 4、Access-Control-Allow-Headers，这个要注意，里面一定要包含自定义的http头字段（就是说前端请求接口时，如果在http头里加了自定义的字段，这里配置一定要写上相应的字段），从上面可看到我写的比较长，我在网上搜索一些常用的写进去了，里面有“web-token”和“app-token”，这个是我项目里前端请求时设置的，所以我在这里要写上； 5、Access-Control-Expose-Headers，可不设置，看网上大致意思是默认只能获返回头的6个基本字段，要获取其它额外的，先在这设置才能获取它； 6、语句“ if ($request_method = ‘OPTIONS’) { ”，因为浏览器判断是否允许跨域时会先往后端发一个 options 请求，然后根据返回的结果判断是否允许跨域请求，所以这里单独判断这个请求，然后直接返回；","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"JS两张图片合并成一张图片","slug":"basic/js/JS两张图片合并成一张图片","date":"2020-05-10T12:42:04.000Z","updated":"2022-03-17T15:15:23.540Z","comments":true,"path":"2020/05/10/basic/js/JS两张图片合并成一张图片/","link":"","permalink":"http://yoursite.com/2020/05/10/basic/js/JS%E4%B8%A4%E5%BC%A0%E5%9B%BE%E7%89%87%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334function drawAndShareImage()&#123; var canvas = document.createElement(\"canvas\"); canvas.width = 700; canvas.height = 700; var context = canvas.getContext(\"2d\"); context.rect(0 , 0 , canvas.width , canvas.height); context.fillStyle = \"#fff\"; context.fill(); var myImage = new Image(); myImage.src = \"./2.png\"; //背景图片 你自己本地的图片或者在线图片 myImage.crossOrigin = 'Anonymous'; myImage.onload = function()&#123; context.drawImage(myImage , 0 , 0 , 700 , 700); context.font = \"60px Courier New\"; context.fillText(\"我是文字\",350,450); var myImage2 = new Image(); myImage2.src = \"./1.png\"; //你自己本地的图片或者在线图片 myImage2.crossOrigin = 'Anonymous'; myImage2.onload = function()&#123; context.drawImage(myImage2 , 175 , 175 , 225 , 225); var base64 = canvas.toDataURL(\"image/png\"); //\"image/png\" 这里注意一下 var img = document.getElementById('avatar'); // document.getElementById('avatar').src = base64; img.setAttribute('src' , base64); &#125; &#125;&#125; 安卓手机 华为 小米等canvas生成不了的问题以及长按canvas保存不了图片的问题 使用html2canvas domtoimg等合成图片 其中 安卓兼容性较高为html2canvas 12345678910111213html2canvas(document.getElementById('posterCode'), &#123; useCORS: true, allowTaint: true &#125;).then(function(canvas) &#123; const base64_p = canvas.toDataURL('image/png') const dom = document.getElementById('posterCode') const myImage1 = new Image() myImage1.src = base64_p myImage1.onload = function() &#123; dom.innerHTML = '' dom.appendChild(myImage1) setTimeout(() =&gt; &#123; that.mergeCanvas() &#125;, 2000) &#125;&#125;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"}]},{"title":"TCP 三次握手 四次挥手","slug":"build/http/TCP 三次握手 四次挥手","date":"2020-05-10T10:42:04.000Z","updated":"2022-03-17T15:15:23.560Z","comments":true,"path":"2020/05/10/build/http/TCP 三次握手 四次挥手/","link":"","permalink":"http://yoursite.com/2020/05/10/build/http/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%20%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/","excerpt":"","text":"- SYN(建立联机) - ACK(确认) - PSH(传送) - FIN(结束) - RST(重置) - URG(紧急) 第一次握手 客户端向服务器发出请求连接的报文 这时同部位SYN=1 同时生成随机初始序列号 seq =x 客户端进去同步已经发送的状态 SYN = 1 不能携带数据的 但是需要消耗掉一个序列号 表示的意思是 客户端想要和服务器建立连接 第二次握手 收到请求后 如果同意连接的话 会发出确认的报文 需要初始化一个序列号 确认号 ack = x+1 进入了一个同步收到状态 也是不能携带数据的 询问你是都准备好 第三次握手 客户端收到确认后 还要向服务器给出确认 确认的报文 进入已经连接的状态 如果不携带数据是不需要消耗序号的 我已经准备好了 * 原因？ 网络不好 请求没有及时到达这个服务端 直到摸个时间点才到达 失效的报文 一直的等待客户端发来消息 * 建立连接传输数据 Ack = Seq + 传递的字节数 + 1 第一次挥手 客户端发出连接释放的报文 停止发送数据 也要消耗一个序号 第二次挥手 收到连接释放的报文 发出确认的报文 ACk = 1 ack = u + 1 seq = u 服务端进去 close-wait （关闭等待的状态) 服务端发送数据的话 客户端依然要接受 第三次挥手 服务端发送一个FIN结束到客户端 服务端关闭客户端的连接 服务器将最后的数据发送完毕之后 就向客户端发送连接释放的报文 服务端可能又发送了一些数据 进入一个最终确认的状态 第四次挥手 * 原因？？？ 握手是可以直接发送 syn ack ack 是用来应答的 syn 是用来同步的 server端收到 fin 结束的报文的时候 不会立即关闭 先回复一个ack 报文 你的分手请求我收到了 但是我还是有点不能接受 你容我伤心一会 （要把数据传输完毕）（只有等我server的所有报文斗殴传输完毕 ） * SYN 洪水攻击 利用服务端超时处理 时间内 不断发送 syn的包 检测？？ 服务端看到大量的办连接的状态 ip是随机的 Linux系统有自带的命令去检测 防御？？ 缩短超时 cookies 过滤网关防护SYN 白天求生存 晚上求发展 不走弯路 目标明确","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"}]},{"title":"前端周刊【202005-2】微前端","slug":"weeks/2020/202005-2","date":"2020-05-10T10:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/05/10/weeks/2020/202005-2/","link":"","permalink":"http://yoursite.com/2020/05/10/weeks/2020/202005-2/","excerpt":"","text":"微前端方向doc 前端单页应用微服务化解决方案1 - 思考 前端单页应用微服务化解决方案2 - Single-SPA 前端单页应用微服务化解决方案3 - 模块加载器 前端单页应用微服务化解决方案4 - 消息总线 前端单页应用微服务化解决方案5 - 路由分发 前端单页应用微服务化解决方案6 - 构建与部署 前端单页应用微服务化解决方案7 - 静态数据共享 前端单页应用微服务化解决方案8 - 二次构建 Single-Spa + Vue Cli 微前端落地指南 也许这才是你想要的微前端方案 微前端在小米 CRM 系统的实践","categories":[],"tags":[{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"}]},{"title":"vue项目实现前端导出excel+样式控制","slug":"frame/vue/vue excel导出","date":"2020-05-10T10:42:04.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/05/10/frame/vue/vue excel导出/","link":"","permalink":"http://yoursite.com/2020/05/10/frame/vue/vue%20excel%E5%AF%BC%E5%87%BA/","excerpt":"","text":"摘抄1234# 商业转载请联系作者获得授权，非商业转载请注明出处。# For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source.# 协议(License)：署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0)# 作者(Author)：XIAOJUN Setup123npm install --save xlsx-styleimport XLSX from \"xlsx-style\"#本地src目录新建vendor/Export2Excel.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282require('script-loader!file-saver');import XLSX from 'xlsx-style' function generateArray(table) &#123; var out = []; var rows = table.querySelectorAll('tr'); var ranges = []; for (var R = 0; R &lt; rows.length; ++R) &#123; var outRow = []; var row = rows[R]; var columns = row.querySelectorAll('td'); for (var C = 0; C &lt; columns.length; ++C) &#123; var cell = columns[C]; var colspan = cell.getAttribute('colspan'); var rowspan = cell.getAttribute('rowspan'); var cellValue = cell.innerText; if (cellValue !== \"\" &amp;&amp; cellValue == +cellValue) cellValue = +cellValue; //Skip ranges ranges.forEach(function (range) &#123; if (R &gt;= range.s.r &amp;&amp; R &lt;= range.e.r &amp;&amp; outRow.length &gt;= range.s.c &amp;&amp; outRow.length &lt;= range.e.c) &#123; for (var i = 0; i &lt;= range.e.c - range.s.c; ++i) outRow.push(null); &#125; &#125;); //Handle Row Span if (rowspan || colspan) &#123; rowspan = rowspan || 1; colspan = colspan || 1; ranges.push(&#123; s: &#123; r: R, c: outRow.length &#125;, e: &#123; r: R + rowspan - 1, c: outRow.length + colspan - 1 &#125; &#125;); &#125; ; //Handle Value outRow.push(cellValue !== \"\" ? cellValue : null); //Handle Colspan if (colspan) for (var k = 0; k &lt; colspan - 1; ++k) outRow.push(null); &#125; out.push(outRow); &#125; return [out, ranges];&#125;; function datenum(v, date1904) &#123; if (date1904) v += 1462; var epoch = Date.parse(v); return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);&#125; function sheet_from_array_of_arrays(data, opts) &#123; var ws = &#123;&#125;; var range = &#123; s: &#123; c: 10000000, r: 10000000 &#125;, e: &#123; c: 0, r: 0 &#125; &#125;; for (var R = 0; R != data.length; ++R) &#123; for (var C = 0; C != data[R].length; ++C) &#123; if (range.s.r &gt; R) range.s.r = R; if (range.s.c &gt; C) range.s.c = C; if (range.e.r &lt; R) range.e.r = R; if (range.e.c &lt; C) range.e.c = C; var cell = &#123; v: data[R][C] &#125;; if (cell.v == null) continue; var cell_ref = XLSX.utils.encode_cell(&#123; c: C, r: R &#125;); if (typeof cell.v === 'number') cell.t = 'n'; else if (typeof cell.v === 'boolean') cell.t = 'b'; else if (cell.v instanceof Date) &#123; cell.t = 'n'; cell.z = XLSX.SSF._table[14]; cell.v = datenum(cell.v); &#125; else cell.t = 's'; ws[cell_ref] = cell; &#125; &#125; if (range.s.c &lt; 10000000) ws['!ref'] = XLSX.utils.encode_range(range); return ws;&#125; function Workbook() &#123; if (!(this instanceof Workbook)) return new Workbook(); this.SheetNames = []; this.Sheets = &#123;&#125;;&#125; function s2ab(s) &#123; var buf = new ArrayBuffer(s.length); var view = new Uint8Array(buf); for (var i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp; 0xFF; return buf;&#125; export function export_table_to_excel(id) &#123; var theTable = document.getElementById(id); var oo = generateArray(theTable); var ranges = oo[1]; /* original data */ var data = oo[0]; var ws_name = \"SheetJS\"; var wb = new Workbook(), ws = sheet_from_array_of_arrays(data); /* add ranges to worksheet */ // ws['!cols'] = ['apple', 'banan']; ws['!merges'] = ranges; /* add worksheet to workbook */ wb.SheetNames.push(ws_name); wb.Sheets[ws_name] = ws; var wbout = XLSX.write(wb, &#123; bookType: 'xlsx', bookSST: false, type: 'binary' &#125;); saveAs(new Blob([s2ab(wbout)], &#123; type: \"application/octet-stream\" &#125;), \"test.xlsx\")&#125; export function export_json_to_excel(&#123; title, multiHeader = [], header, data, filename, merges = [], autoWidth = true, bookType = 'xlsx' &#125; = &#123;&#125;) &#123; /* original data */ filename = filename || 'excel-list' data = [...data] data.unshift(header); data.unshift(title); for (let i = multiHeader.length - 1; i &gt; -1; i--) &#123; data.unshift(multiHeader[i]) &#125; var ws_name = \"SheetJS\"; var wb = new Workbook(), ws = sheet_from_array_of_arrays(data); if (merges.length &gt; 0) &#123; if (!ws['!merges']) ws['!merges'] = []; merges.forEach(item =&gt; &#123; ws['!merges'].push(XLSX.utils.decode_range(item)) &#125;) &#125; if (autoWidth) &#123; /*设置worksheet每列的最大宽度*/ const colWidth = data.map(row =&gt; row.map(val =&gt; &#123; /*先判断是否为null/undefined*/ if (val == null) &#123; return &#123; 'wch': 10 &#125;; &#125; /*再判断是否为中文*/ else if (val.toString().charCodeAt(0) &gt; 255) &#123; return &#123; 'wch': val.toString().length * 2 &#125;; &#125; else &#123; return &#123; 'wch': val.toString().length &#125;; &#125; &#125;)) /*以第一行为初始值*/ let result = colWidth[0]; for (let i = 1; i &lt; colWidth.length; i++) &#123; for (let j = 0; j &lt; colWidth[i].length; j++) &#123; if (result[j]['wch'] &lt; colWidth[i][j]['wch']) &#123; result[j]['wch'] = colWidth[i][j]['wch']; &#125; &#125; &#125; ws['!cols'] = result; &#125; /* add worksheet to workbook */ wb.SheetNames.push(ws_name); wb.Sheets[ws_name] = ws; var dataInfo = wb.Sheets[wb.SheetNames[0]]; const borderAll = &#123; //单元格外侧框线 top: &#123; style: 'thin' &#125;, bottom: &#123; style: 'thin' &#125;, left: &#123; style: 'thin' &#125;, right: &#123; style: 'thin' &#125; &#125;; //给所以单元格加上边框 for (var i in dataInfo) &#123; if (i == '!ref' || i == '!merges' || i == '!cols' || i == 'A1') &#123; &#125; else &#123; dataInfo[i + ''].s = &#123; border: borderAll &#125; &#125; &#125; // 去掉标题边框 let arr = [\"A1\", \"B1\", \"C1\", \"D1\", \"E1\", \"F1\", \"G1\", \"H1\", \"I1\", \"J1\", \"K1\", \"L1\", \"M1\", \"N1\", \"O1\", \"P1\", \"Q1\", \"R1\", \"S1\", \"T1\", \"U1\", \"V1\", \"W1\", \"X1\", \"Y1\", \"Z1\"]; arr.some(function (v) &#123; let a = merges[0].split(':') if (v == a[1]) &#123; dataInfo[v].s = &#123;&#125; return true; &#125; else &#123; dataInfo[v].s = &#123;&#125; &#125; &#125;) //设置主标题样式 dataInfo[\"A1\"].s = &#123; font: &#123; name: '宋体', sz: 18, color: &#123;rgb: \"ff0000\"&#125;, bold: true, italic: false, underline: false &#125;, alignment: &#123; horizontal: \"center\", vertical: \"center\" &#125;, // fill: &#123; // fgColor: &#123;rgb: \"008000\"&#125;, // &#125;, &#125;; // console.log(merges) // console.log(dataInfo) var wbout = XLSX.write(wb, &#123; bookType: bookType, bookSST: false, type: 'binary' &#125;); saveAs(new Blob([s2ab(wbout)], &#123; type: \"application/octet-stream\" &#125;), `$&#123;filename&#125;.$&#123;bookType&#125;`);&#125; 组件中使用12345678910111213141516171819202122232425262728293031exportExcel() &#123; import('@/vendor/Export2Excel').then(excel =&gt; &#123; const tHeader = ['船名', '船长', '货种', '载重吨', '净吨', '锚地', '预抵时间', '下锚时间', '预靠泊位'] //表头 const title = ['锚地船舶', '', '', '', '', '', '', '', ''] //标题//表头对应字段 const filterVal = ['NAME', 'VESSEL_LENGTH', 'CARGO_NAME', 'DEADWEIGHT_TONNAGE', 'NET_TONNAGE', 'ANCHORAGE_ID', 'EXP_ARCHORAGE_TIME', 'AC_ARCHORAGE_TIME', 'RECOMMEND_BERTH'] const list = this.anchorTable const data = this.formatJson(filterVal, list) data.map(item =&gt; &#123; // console.log(item) item.map((i, index) =&gt; &#123; if (!i) &#123; item[index] = '' &#125; &#125;) &#125;) const merges = ['A1:I1'] //合并单元格 excel.export_json_to_excel(&#123; title: title, header: tHeader, data, merges, filename: '锚地船舶', autoWidth: true, bookType: 'xlsx' &#125;)&#125;)&#125;,formatJson(filterVal, jsonData) &#123; return jsonData.map(v =&gt; filterVal.map(j =&gt; v[j]))&#125;,","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"}]},{"title":"nginx配置证书实现HTTPS","slug":"build/nginx配置https","date":"2020-04-29T10:42:04.000Z","updated":"2022-06-05T14:08:41.962Z","comments":true,"path":"2020/04/29/build/nginx配置https/","link":"","permalink":"http://yoursite.com/2020/04/29/build/nginx%E9%85%8D%E7%BD%AEhttps/","excerpt":"","text":"本地配置12345678cd /usr/local/nginx# 创建服务器私钥，命令会让你输入一个口令openssl genrsa -des3 -out server.key 1024# 创建签名请求的证书（CSR）openssl req -new -key server.key -out server.csr# 设置信息# 最后标记证书使用上述私钥和CSRopenssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt 12345678910111213server &#123; listen 443 ssl; server_name work.com; index index.html; ssl on; ssl_certificate /etc/nginx/server.crt; ssl_certificate_key /etc/nginx/server.key; ssl_session_timeout 5m; location / &#123; root /usr/local/web/; add_header 'Cache-Control' 'no-store'; &#125;&#125; 云服务器配置1. 申请证书124122000_www.xxx.com.pem4122000_www.xxx.com.key 2. 配置1234567891011121314151617181920212223server &#123; listen 443 ssl; server_name localhost; ssl_certificate /usr/local/nginx/conf/4122000_www.xxx.com.pem; ssl_certificate_key /usr/local/nginx/conf/4122000_www.xxx.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers code; #使用此加密套件 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置 ssl_prefer_server_ciphers on; location /server/ &#123; proxy_pass http://localhost:3920/; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect default ; client_max_body_size 200m; &#125;&#125;","categories":[],"tags":[{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"}]},{"title":"深入浅出NODEJS - [未完]","slug":"book/2020/深入浅出NODEJS","date":"2020-04-05T01:00:00.000Z","updated":"2022-06-05T14:08:41.957Z","comments":true,"path":"2020/04/05/book/2020/深入浅出NODEJS/","link":"","permalink":"http://yoursite.com/2020/04/05/book/2020/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANODEJS/","excerpt":"","text":"第一章 NODE简介第二章 模块化机制第三章 异步I/O第四章 异步编程第五章 内存控制NODE受制于V8，主要提到V8的内存限制。主要是V8堆内存。 123456789&gt; node&gt; process.memoryUsage();&gt; &#123; rss: heapTotal:申请到的堆内存 headUsed 当前使用的堆内存&#125;// node启动时可传递调整内存限制大小&gt; node --max-old-space-size=1700 // mb&gt; node --max-new-space-size=1024 // kb V8内存分代 新生代 存活时间短 ，主要通过scavenge算法进行垃圾回收 老生代 存活时间长 或常驻，主要使用 mark-sweep &amp;&amp; mark-compact进行垃圾回收 12345# 查看垃圾回收日志 --trace_gc&gt; node --trace_gc -e ...# 查看性能分析数据 --prof# v8使用 linux-tick-processor 统计日志信息 高效使用内存如何让垃圾回收机制更高效的工作。 作用域：标识符查找；作用域链；变量的主动释放； 闭包 查看内存使用情况 memoryUsage() 查看NODE进程的内存占用情况 totalmem() 查看操作系统内存使用情况，返回系统总内存 freemem() 查看操作系统内存使用情况，返回系统闲置内存 内存泄漏原因：缓存；队列消费不及时；作用域未释放。解决办法 ： 慎将内存当作缓存：缓存限制策略；缓存的解决，使用redis&amp;memcached 关注队列状态 bagpipe排查： v8-profiler node-heapdump * node-mtrace dtace node-memwatch * 大内存的使用NODE提供了stream模块用于处理大文件。由于V8限制，无法通过fs.readFile fs.writeFile处理大文件。改用 fs.createReadStream() fs.createWriteStream() 第六章 BufferBuffer是一个类似array对象，主要用于操作字节。所占用的内存不是通过v8分配的，属于堆外内存，将其放到全局对象中，可以无需引入直接使用new Buffer。buffer属于二进制数据流,与字符串之间存在编码关系。 Buffer的结构 Buffer对象：类似数组，它的元素为16进制的两位数，0-255的数值 内存分配：堆外内存，node采用了slab分配机制，动态内存管理机制。三种状态（full完全分配；partial部分分配状态；empty没有被分配状态）。1.分配小的buffer时，按照小对象进行分配，使用局部变量pool作为中间件，使处于分配状态的slab单元都指向它。2. 分配大的buffer时，直接分配一个slab。 Buffer的转化 支持的类型有：ASCII UTF-8 UTF-16 Base64 Binary Hex不支持的编码类型:GBK GB2312 BIG-5 1234// 字符串 Buffernew Buffer(str, [encoding])// Buffer转字符串Buf.toString([encoding],[start],[end]) Buffer的拼接 设置编码的方法 setEncoding() 第七章 网络编程NODE提供了net dgram http https四个模块，分别用于处理TCP\\UDP\\HTTP\\HTTPS适用于服务器和客户端。NODE在网络安全上提供了 crypto tls https三个模块 crypto用于加密解密（SHA1 MD5） tls/ssl 公钥和私钥的结构，非对称的结构，数字证书CA 第八章 web服务器 已经有非常成熟的服务框架 express koa Connect 以下记录一些注意事项 、常见问题 cookie性能影响（cookies过多，导致 报头较大） 减小cookie的大小 为表态组件使用不同的域名 减少DNS查询 Session安全 XSS漏洞 缓存为了提高性能 添加expires cache-control到报文头中 配置ETags 让AJAX可缓存 清理缓存 接口RESTful规范设计第九章 玩转进程历程：同步、复制进程、多线程、事件驱动、集群 child_process模块给与NODE可随意创建子进程的能力 进程间通信 WebWorker API: onmessage() postMessage() 句柄传递：句柄是一种可以用来标识资源的引用，它的内部包含指向对象的文件描述符 集群稳定之路 进程事件 send() message error exit close disconnect 自动重启：自杀信号；限量重启 负载均衡 状态存储：第三方数据存储 （缓存服务redis 数据库 磁盘文件 ） 一是让各个子进程去像第三方进行定时轮询 二是改进方式是当数据发生更新时，主动通知子进程 Cluster模块用以解决多核CPU的利用率的问题，同时也提供了较完善的API，用以处理进程的健壮性的问题。原理即是 child_process 和 net模块的组合应用事件：fork;online;listening;disconnect;exit;setup 第十章 测试测试包含 单元测试、性能测试、安全测试、功能测试 编写可测试代码的原则 单一职责：某段代码承担的职责不能过多，解耦分离 接口抽像：具体代码实现的变化 不影响 为接口编写的单元测试 层次分离：MVC中即是典型层次分离模型 单元测试 断言：有个规范：ok()、equl()、notEqual()、deepEqual()、notDeepEqual()、strictEqual()、notStricEqual()、throws() 测试框架: TDD测试驱动开发 BDD行为驱动开发 测试报告：mocha –reporters 可以查看各种类型的测试报告 测试用例：一个行为或者功能需要有完善的 多方面的测试用例，一个测试用例中包含至少一个断言。！！！异步测试 mocha；！！！超时设置 需要关注 测试覆盖率：通过不停的给代码添加测试用例，将会不断的覆盖代码的分支和不同的情况 mock：通过伪造被调用方法来测试上层代码的健壮性 持续集成 工程化和自动化 工程化 构建使用makefile 持续集成：使用travis-ci实现持续集成 性能测试 基准测试：要统计的就是在多少时间内执行了多少次某个方法 压力测试：对网络接口做压力测试要考查的几个指标有吞吐率 响应时间 和并发数，这些指标反映了并发处理的能力。常用的工具是ab\\siege\\http_load，来构造压力测试。 基准测试驱动开发(BDD) 写基准测试代码 写 改 代码 收集数据 找出问题 回到第2步 测试数据与业务数据的转换：换算公式：QPS = PV / 10h 第十一章项目工程化 目录机构：遵循CommonJS模块约定 构建工具：老牌就是 make 配置makefile将测试、测试覆盖率、项目清理、依赖安装行装整合进make命令，但是缺陷是跨平台问题，最终出现了grunt。 编码规范：JSLINT 或 ESLINT 代码审核：建立在具体的代码提交过程中 部署流程代码=》stage测试环境=》pre-release预发布环境=》product生产环境 性能 原则 做专一的事 让擅长的工具做擅长的事 将模型简化 将风险分离 动静分离 启用缓存：redis memcached 多进程架构：cluster pm forever pm2 读写分享：读取数据的时候不授到写入的影响 日志 访问日志 异常日志 日志与数据库 分割日志：分为访问日志、异常日志 或 按日期分割 监控报警 监控 （日志监控、响应时间、进程监控、磁盘监控、内存监控、CPU占用监控、CPU load监控、I/O 负载、网络监控、应用状态监控、DNS监控） 报警的实现（邮件报警 nodemailer模块、短信或电话报警） 监控系统稳定性 稳定性 多机器 多机房 容灾备份 异构共存在node应用的过程中，不存在为了用它而推翻已有设计的情况。NODE能够通过协议与已有的系统很好的异构共存。 附录 调试NODE（Debugger node-inspector） NODE编码规范","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"Javascript 设计模式之美","slug":"book/2020/设计模式","date":"2020-03-10T12:42:04.000Z","updated":"2022-03-17T15:15:23.560Z","comments":true,"path":"2020/03/10/book/2020/设计模式/","link":"","permalink":"http://yoursite.com/2020/03/10/book/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一、面向对象编程二、创建型设计模式 一类处理对象创建的模式，通过某种方式控制对象的创建来避免基本对象创建时可能导致设计上的问题或增加设计上的复杂度。 1.简单工厂模式 静态工厂方法，由一个工厂对象决定创建某一种产品对象的实例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//方式一、通过类实例化对象创建var LoginAlert = function(text)&#123; this.content = text;&#125;LoginAlert.prototype.show = function()&#123; //显示alert&#125;var LoginConfirm = function(text)&#123; this.content = text;&#125;LoginConfirm.prototype.show = function()&#123; //显示confirm&#125;var LoginPrompt = function(text)&#123; this.content = text;&#125;LoginPrompt.prototype.show = function()&#123; //显示Prompt&#125;var PopFactory = function(name)&#123; switch(name)&#123; case 'alert': return new LoginAlert(); case 'confirm': return new LoginConfirm(); case 'prompt': return new LoginPrompt(); &#125;&#125;// 方法二 通过创建一个新对象然后包装增强其属性和功能来实现的function createPop(type,text)&#123; var o = new Object(); o.content = text; o.show = function()&#123; // show &#125;; if(type==='alert')&#123; // alert &#125; if(type==='prompt')&#123; // prompt &#125; if(type==='confirm')&#123; // confirm &#125; return o;&#125;var usernamealert = createPop('alert','用户名只能是26个字母'); 2.工厂方法模式通过对产品类的抽象使其创建业务主要负责用于创建多累产品的实例。 1234567891011121314151617181920212223242526272829303132333435var Factory = function(type,content)&#123; if(this instanceof Factory)&#123; var s = new this[type](content); return s; &#125;else&#123; return new Factory(type,content); &#125;&#125;Factory.prototype = &#123; Java:function(content)&#123; // &#125;, Javascript:function(content)&#123; // &#125;, UI:function(content)&#123; this.content = content; (function(content)&#123; var div = document.createElement('div'); div.innerHTML = content; div.style.border = '1px solid #ccc'; document.getElementById('container').appendChild(div); &#125;)(content); &#125; ...&#125;var data = [ &#123;type:'Java',content:'...'&#125;, &#123;type:'Javascript',content:'...'&#125;, &#123;type:'UI',content:'...'&#125;,]for(var i = 6;i&gt;=0;i--)&#123; Factory(s[i].type,s[i].content); &#125; 3.抽象工厂模式通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var VehicleFactory = function(subType,supperType)&#123; // 判断抽象工厂中是否有该抽象类 if(typeof VehicleFactory[subType] === 'function')&#123; function F()&#123;&#125;; //缓存类 F.prototype = new VehicleFactory[subType]();//继承父类属性和方法 subType.constructor = subType;//将子类constructor指向子类 subType.prototype = new F();//子类原型继承父类 &#125;else&#123; throw new Error('未创建该抽象类'); &#125;&#125;// 小汽车抽像类VehicleFactory.Car = function()&#123; this.type = 'car';&#125;;VehicleFactory.Car.prototype = &#123; getPrice:function()&#123; return new Error('抽象方法不能调用'); &#125;, getSpeed:function()&#123; return new Error('抽象方法不能调用'); &#125;&#125;// 公交车抽像类VehicleFactory.Car = function()&#123; this.type = 'bus';&#125;;VehicleFactory.Bus.prototype = &#123; getPrice:function()&#123; return new Error('抽象方法不能调用'); &#125;, getSpeed:function()&#123; return new Error('抽象方法不能调用'); &#125;&#125;// 卡车抽像类VehicleFactory.Truck = function()&#123; this.type = 'truck';&#125;;VehicleFactory.Car.prototype = &#123; getPrice:function()&#123; return new Error('抽象方法不能调用'); &#125;, getSpeed:function()&#123; return new Error('抽象方法不能调用'); &#125;&#125;// 抽象工厂实现对CAR抽象类的继承var BMW = function(price,speed)&#123; this.price = price; this.speed = speed;&#125;VehicleFactory(BMW,'car');BMW.prototype.getPrice = function()&#123; return this.price;&#125;BMW.prototype.getSpeed = function()&#123; return this.speed;&#125; 4.建造者模式Builder将一个复杂对象的构建层与其表示层相互分离。 创建的对象是一个复合对象 关心的是建造的过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 创建一位人类var Human = function(param)&#123; this.skill = param &amp;&amp; param.skill || '保密'; this.hobby = param &amp;&amp; param.hobby || '保密';&#125;// 类人的原型方法Human.prototype = &#123; getSkill:function()&#123; return this.skill; &#125;, getHobby:function()&#123; return this.hobby; &#125;&#125;//实例化var Named = function(name)&#123; var that = this; (function(name,that)&#123; that.woleName = name; if(name.indexOf(' ')&gt;-1)&#123; that.FirstName = name.slice(0,name.indexOf(' ')); that.SecondName = name.slice(name.indexOf(' ')); &#125; &#125;)(name,that);&#125;var Work = funciton(work)&#123; var that = this; (function(work,that)&#123; switch(work)&#123; case 'code': that.work = '工程师'; that.workDescript = 'programer'; case 'UI': that.work = '设计师'; that.workDescript = 'designer'; default : that.work = work; that.workDescript = 'sorry'; &#125; &#125;)(work,that)&#125;//更换期望职位Work.prototype.changeWork = function(work)&#123; this.work = work;&#125;//添加职位描述Work.prototype.changeDescript = function(setence)&#123; this.changeDescript = setence;&#125; 创建一位应聘者 123456789var Person = function(name,work)&#123; var _person = new Human(); _person.name = new Named(name); _person.work = new Work(work); return _person;&#125;var person = new Person('lee','code'); 5.原型模式Prototype用原型实例指向创建对象的类，使用于创建新的对象的类共享 原型对象的属性及方法。 12345678910111213141516171819202122232425262728293031323334353637var LoopImages = function(imgArr,container)&#123; this.imageArray = imgArr; this.container = container;&#125;LoopImages.prototype = &#123; createImage: fucntion()&#123; // &#125;, changeImage: fucntion()&#123; // &#125;&#125;var SlideLoopImg = function(imgArr,container)&#123; LoopImages.call(this,imgArr,container)&#125;SlideLoopImg.prototype = new LoopImages();// 重写继承SlideLoopImg.prototype.changeImage = function()&#123; console.log(\"changeImage fn\");&#125;var FadeLoopImg = function(imgArr,container,arrow)&#123; LoopImages.call(this,imgArr,container) this.arrow = arrow;&#125;FadeLoopImg.prototype = new LoopImages();FadeLoopImg.prototype.changeImage = function()&#123; console.log(\"changeImage fn\");&#125;// 原型可以扩展LoopImages.prototype.getImageLength = function()&#123; return this.imagesArray.length;&#125;LoopImages.prototype.getContainer = function()&#123; return this.container;&#125; 6.单例模式单体模式，只允许实例化一次的对象类。 命名空间，namespace 12345678var Ming = &#123; g: function(id)&#123; return document.getElementById(id); &#125;, css: function(id,key,value)&#123; this.g(id).style[key] = value; &#125;&#125; 小型代码库 1234567891011121314var A = &#123; Util:&#123; util_methods1 : function()&#123;&#125;, util_methods2 : function()&#123;&#125; &#125;, Tool:&#123; tool_methods1 : function()&#123;&#125;, tool_methods2 : function()&#123;&#125; &#125;, Ajax:&#123; get : function()&#123;&#125;, post : function()&#123;&#125; &#125;&#125; 无法修改的静态变量 123456789101112var Conf = (function()&#123; var conf = &#123; NUM:1, COUNT:100 &#125; return &#123; get:function(name)&#123; return conf[name] ? conf[name] : null; &#125; &#125;&#125;)Conf.get('COUNT'); 惰性单例 1234567891011121314151617var LazySingle = function()&#123; var instance = null function Single()&#123; return &#123; publicMethod : function()&#123;&#125;, publicProperty : '1.0' &#125; &#125;' return function()&#123; if(!_instance)&#123; _instance = Single(); &#125; return _instance; &#125;&#125;//testLazySingle().publickProperty; // 1.0 三、结构型设计模式 关注如何将类或对象组合成更大、更复杂的架构，以简化设计 1.外观模式 为一组复杂的子系统接口提供一个更高级的统一接口，使访问更容易。底层结构兼容性做统一的简化用户使用。 addEventListener &amp;&amp; attachEvent 123456789101112131415161718// 兼容模式function addEvent(dom,type,fn)&#123; if(dom.addEventListener)&#123; dom.addEventListener(type,fn,false); &#125;else if()&#123; dom.attachEvent(\"on\"+type,fn); &#125;else&#123; dom['on'+type] = fn; &#125;&#125;// 这样就可以开始绑定事件了var myInput = document.getElementById('myinput');addEvent(myInput,'click',function()&#123; console.log('绑定的第一个事件');&#125;)addEvent(myInput,'click',function()&#123; console.log('绑定的第二个事件');&#125;) e.preventDefault &amp;&amp; e.target 123456789101112131415161718192021222324252627282930// 获取事件对象var getEvent = function(event)&#123; return event || window.event;&#125;// 获取元素var getTarget = function(event)&#123; var event = getEvent(event); return event.target || event.srcElement;&#125;// 阻止默认行为var preventDefault = function(event)&#123; var event = getEvent(event); //非IE if(event.preventDefault)&#123; event.preventDefault(); &#125;else&#123; //IE event.returnValue = false; &#125;&#125;//兼容模式开始了document.onclick=function(e)&#123; //阻止默认为行 preventDefault(e); // 获取事件源目标对象 if(getTarget(e) !== document.getElementById('myInput'))&#123; hideInputSug(); &#125;&#125; 小型代码库 1234567891011121314var A = &#123; g: fucntion(id)&#123; return docuemnt.getElementById(id); &#125;, css: fucntion(id,key,value)&#123; docuemnt.getElementById(id)[key] = value; &#125;, html: fucntion(id,html)&#123; docuemnt.getElementById(id).innerHtml = html; &#125;&#125;A.css('box','background','red');// ... 2.适配器模式 将一个类的接口转化成另一个接口，以满足用户需求，使类之间接口的不兼容问题通过适配器得以解决。 12// jQuery 适配器window.A = A = jQuery; 参数适配器 12345678910111213function doSomeThing(obj)&#123; var _adapter = &#123; name:'', title:'', age:'', color:'', size:100, prize:50 &#125; for(var i in _adapter)&#123; _adapter[i] = obj[i] || _adapter[i]; &#125;&#125; 数据适配 1234567891011121314151617181920212223var obj = &#123; name:'', age:'', job:''&#125;function arrToObjAdapter(arr)&#123; return &#123; name:arr[0], age:arr[1], job[2] &#125;&#125;var test = arrToObjAdapter[obj];console.log(test);// 服务端数据适配function ajaxAdapter(data)&#123; return [data['key1'],data['key2'],data['key3']];&#125;$.ajax....&#123; doSomeThing(ajaxAdapter(res));&#125; 3.代理模式由于一个对象不能直接引用另一个对象 ，所以需要通过代理对象 在这2个对象之间起到中介的作用。 跨域 1.同一域名不同的端口号 http://www.baidu.com:8081 http://www.baidu.com:8082 2.同一域名不同协议 http://www.baidu.com https://www.baidu.com 3.域名和域名对应的IP http://www.baidu.com http://10.10.10.10 4.主域和子域 http://www.baidu.com http://xx.baidu.com 5.子域和子域 http://tieba.baidu.com http://fanyi.baidu.com script代理 和 JSONP 4.装饰者模式在不改变原对象的基础上，通过对其进行包装拓展使原有对象可以满足用户的更复杂需求。 123456789101112131415161718192021222324// 装饰已有的功能对象var decorator = function(input,fn)&#123; // 获取事件源 var input = document.getElementById(input); // 若事件源已经已经绑定事件 if(typeof input.onclick === 'function')&#123; // 缓存事件源原有回调函数 var oldClickFn = input.onclick; // 为事件源定义新的事件 input.onclick = function()&#123; // 事件源原有回调函数 oldClickFn(); // 执行事件源新增回调函数 fn(); &#125; &#125;else&#123; // 事件源未绑定事件，直接为事件源添加新增回调函数 input.onclick = fn; &#125;&#125;// 为输入框装修decorator('tel_input',function()&#123; document.getElementById('tel_demo_text').style.display = 'none';&#125;) 5.桥接模式在系统沿着多个维度变化的同时，又不增加其复杂度并已达到解耦。 实现层（元素绑定的事件）和抽象层（如修饰页面UI逻辑）解耦分离，使两部分可以独立变化。 提取共同点：相同逻辑代码提取处理 1234function changeColor(dom,color,bg)&#123; dom.style.color = color; dom.style.background = bg;&#125; 桥接：事件与业务 逻辑之间的桥梁：需要用一个方法将他们链接起来 123456spans[0].onmouseover = function()&#123; changeColor(this,'red','#ddd');&#125;spans[0].onmouseout = function()&#123; changeColor(this,'#333','#f5f5f5');&#125; 6.组合模式又称部份-整体模式，将对象组合成树形结构以表示部份整体的层次结构。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 每个成员要现有祖先 虚拟类var News = function()&#123; this.children = []; //子类 this.element = null; //当前元素&#125;News.prototype = &#123; init:funticon()&#123; throw new Error('请重写你的方法'); &#125;, add:funticon()&#123; throw new Error('请重写你的方法'); &#125;, getElement:funticon()&#123; throw new Error('请重写你的方法'); &#125;&#125;// 容器类构造函数var Container = function(id,parent)&#123; News.call(this); // 继承父类 this.id = id; // 模块ID this.parent = parent; // 模块父容器 this.init(); // 构造方法&#125;// 寄生式继承父类原型方法inheritPrototype(Container,News);//构建方法Container.prototype.init = function()&#123; this.element = document.createElement('ul'); this.element.id = this.id; this.element.className = 'new-container';&#125;// 添加子元素Container.prototype.add = function(child)&#123; this.children.push(child); this.element.appendChild(child.getElement()); return this;&#125;// 获取当前元素Container.prototype.getElement = function()&#123; return this.element;&#125;// 显示方法Container.prototype.show = function()&#123; this.parent.appendChild(this.element);&#125;// 模块创建var news1 = new Container('news',document.body);news1.add( //).add( //) 7.享元模式运用共享技术有效地支持大量的颗粒度的对象，避免对象间拥有相同内容造成多余的开销。 123456789101112131415161718192021222324252627var Flyweight = function()&#123; //已创建的元素 var created = []; // 创建一个新闻包装容器 function create()&#123; var dom = document.createElement('div'); // 将容器插入新闻列表容器中 document.getElementById('container').appendChild(dom); // 缓存新创建的元素 created.push(dom); // 返回创建的新元素 return dom; &#125; return &#123; // 获取创建新闻元素方法 getDiv: function()&#123; // 如果已创建的元素小于当前页元素总个数，则创建 if(created.length&lt;5)&#123; return create(); &#125;else&#123; var div = created.shift(); created.push(div); return div; &#125; &#125; &#125;&#125; 四、行为型设计模式 用于不同对象 之间职责划分或算法的抽像，不仅涉及类和对象，还涉及类或对象之间的交流模式并加以实现 1.模板方法模式父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同事可重新定义算法中某些实现步骤。（封装 弹出框方法 或提示框的思路） 2.观察者模式又称作发布-订阅模式或消息机制，定义了一种依赖关系，解决主体对象 与观察者之间的功能耦合。 123456789//将观察者放到闭包中，当页面加载就立即执行var Observer = (function()&#123; var _message = &#123;&#125;; //防止消息队列暴露而篡改 因此设置私有变量 return &#123; regist:function()&#123;&#125;, fire:function()&#123;&#125;, remove:function()&#123;&#125;, &#125;&#125;)(); 3.状态模式当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//创建超级玛丽状态类var MarryState = function()&#123; var _currentState = &#123;&#125;; //内部状态私有变量 var states = &#123; jump:function()&#123;&#125;, move:function()&#123;&#125;, shoot:function()&#123;&#125;, squat:function()&#123;&#125;, &#125; // 动作控制类 var Action = function()&#123; changeState:function()&#123; // 组合动作通过传递多个参数实现 var arg = arguments; // 重置对内状态 _currentState = &#123;&#125;; 如果有动作就添加动作 if(arg.length)&#123; for(var i = 0;i&lt;arg.length;i++)&#123; _currentState[arg[i]] =true; &#125; &#125; // 返回动作控制类 return this; &#125;, goes: function()&#123; // 触发一次动作 for(var i in currentState)&#123; states[i] &amp;&amp; states[i](); &#125; return this; &#125; &#125; // 返回接口方法 return &#123; change:Action.changeState, goes:Action.goes &#125;&#125;// 第一种使用MarryState() .change('jump','shoot') .goes() .goes()// 第二种使用var marry = new MarryState();marry .change('jump','shoot') .goes() .goes() 4.策略模式将定义的一组算法封装起来，使其相互之间可以替换。 1234567891011121314// 价值策略对象var priceStrategy = function()&#123; var stragtegy = &#123; return30 :function(price)&#123;&#125;, // 100返30 return50 :function(price)&#123;&#125;, // 100返50 percent90 :function(price)&#123;&#125;, // 九折 &#125; return function(algorithm,price)&#123; return stragtegy[algorithm] &amp;&amp; stragtegy[algorithm](price) &#125;&#125;var price = priceStrategy('return50','314');console.log(price); 5.职责链模式解决请求的发送者与请求的接受者之间的耦合，通过职责上的多个对象 对分解请求流程，实现请求在多个对象之间传递，直到最后一个对象完成请求的处理。 请求模块 响应数据适配模块 创建组件模块 单元测试 6.命令模式将请求与实现解耦，并封装成独立对象，从而使不同的请求对客户端的实现参数化。 例如：将执行的命令封装，解决命令发起者与命令执行者之间的耦合。 12345678910111213141516171819202122232425262728var canvasCMD = (function()&#123; var canvas = document.getElementById('canvas'); ctx = canvas.getContext('2d'); var Action = &#123; fillStyle : function(c)&#123; ctx.fillStyle = c; &#125;, fillRect : function(x,y,width,height)&#123; ctx.fillRect(x,y,width,height); &#125;, // ... &#125; return &#123; // 命令接口 excute:function(msg)&#123; if(!msg) return; if(msg.length)&#123; for(var i=0;i&lt;msg.length;i++)&#123; arguments.callee(msg[i]); &#125; &#125;else&#123; msg.param = Object.prototype.toString.call(msg.param) === '[Object Array]'? msg.param : [msg.param]; Action[msg.command].apply(Action,msg.param); &#125; &#125; &#125;&#125;)(); 7.访问者模式针对于对象结构中的元素，定义在不改变此对象的前提下访问结构中元素的新方法。 解决数据与数据的操作方法之间的耦合，将数据的操作方法独立于数据，使其可以自由变化。 12345678// 访问器var Visitor = (function()&#123; reutrn&#123; splice:function()&#123;&#125;, push:function()&#123;&#125;, pop:function()&#123;&#125;, &#125;&#125;)(); 8.中介者模式通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。 同观察者模式一样，中介者模式的主要业务也是通过模块间或者对象间的通信 ，来解决模块间或对象间的耦合。 1234567891011121314151617181920212223// 中介者对象var Mediator = function()&#123; var _msg = &#123;&#125;; return &#123; // 订阅消息 register:function(type,action)&#123; if(_msg[type])&#123; _msg[type].push(action); &#125;else&#123; _msg[type] = []; _msg[type].push(action); &#125; &#125;, // 发送消息 send:function(type)&#123; if(_msg[type])&#123; for(var i = 0;i&lt;_msg[type].length;i++)&#123; _msg[type][i] &amp;&amp; _msg[type][i](); &#125; &#125; &#125; &#125;&#125;(); 9.备忘录模式在不破坏对象的封装性的前提下，在对象之外铺货并保存该对象内部的状态以便日后对象使用或者对象恢复到以前的某个状态。 主要针对现有的数据或状态做为缓存，为将来某个时刻使用或恢复做准备。 123456789101112131415161718// 缓存数据 分页点击下一页的数据 又返回上一页 数据可以缓存var Paget = function&#123; var cache = &#123;&#125;; return function(page,fn)&#123; if(cache[page])&#123; showPage(page,cache[page]); fn &amp;&amp; fn(); &#125;else&#123; $.post((),&#123; showPage(page,res.data); cache[page] = res.data; fn &amp;&amp; fn(); &#125;) &#125; &#125;&#125;(); 10.迭代器模式在不暴露对象 内部结构的同时，可以顺序地访问聚合对象内部的元素。 优化循环语句的一种可行方案，它使得程序清晰易读。可以顺序的访问一个聚合对象中的每一个元素。 123456789101112131415161718// 迭代器var Iterator = function(items,container)&#123; var container = container &amp;&amp; document.getElementById(container) || document, items = container.getElementByTagName(items), length = item.length, index = 0; var splice = [].splice; return &#123; first : function()&#123;&#125;, second : function()&#123;&#125;, pre : function()&#123;&#125;, next : function()&#123;&#125;, get : function()&#123;&#125;, dealEach : function()&#123;&#125;, dealItem : function()&#123;&#125;, exclusive : function()&#123;&#125;, &#125;&#125; 11.解释器模式对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这种解释器来解释语言中定义的句子。 对客户提出的需求，经过解析而形成的一个抽象解释程序。 123456789101112131415// xPath解释器var Interpreter = (function()&#123; function getSublingName(node)&#123;&#125; return function(node,wrap)&#123; var path = []; var wrap = wrap || document; if(node===wrap)&#123; if(wrap.nodeType == 1)&#123; path.push(wrap.nodeName.toUpperCase()); return path; &#125; &#125; return path; &#125;&#125;)(); 五、技巧型设计模式 通过一些特定技巧来解决组件的某些方面的总理，这些技巧一般通过实践经验总结得到。 1.链模式 通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。 123456789101112131415161718192021222324252627282930var A = function(selector)&#123; return new A.fn.init(selector);&#125;A.fn = A.prototype = &#123; constructor:A, init:function(selector)&#123; // &#125;&#125;A.fn.init.prototype = A.fn;// 添加方法A.fn.extend(&#123; on:(function()&#123; //... &#125;)()&#125;)A.fn.extend(&#123; css:(function()&#123; //... &#125;)()&#125;)A('div').css(&#123; //...&#125;).on('click',function()&#123; //...&#125;) 2.委托模式 多个对象 接收 并处理同一个请求，他们将请求委托给另一个对象 统一处理请求。 通过委托者将请求给被委托者去处理实现，解决了请求与委托者之间的耦合。 还能解决内存泄露（IE旧浏览器） 123456789$.get(\"./deal.php?g=banner\",function(res)&#123; //&#125;)$.get(\"./deal.php?g=news\",function(res)&#123; //&#125;)$.get(\"./deal.php?g=member\",function(res)&#123; //&#125;) 数据分发 12345678910111213141516var Deal =&#123; banner:function()&#123; // &#125;, news:function()&#123; // &#125;, member:function()&#123; // &#125;&#125;$.get('./deal.php?',fucntion(res)&#123; for(var i in res)&#123; Deal[i] &amp;&amp; Deal[i](res[i]) &#125;&#125;) 3.数据访问对象模式 抽象和封装数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。 123456789101112131415161718192021222324252627282930313233/*本地存储类*/var BaseLocalStorage = function(preId,timeSign)&#123; this.preId = preId; this.timeSign = timeSign || '|-|';&#125;BaseLocalStorage.protorype = &#123; // 操作状态 status:&#123; SUCCESS : 0, FAILURE : 1, OVERFLOW : 2, TIMEOUT : 3 &#125;, // 保存本地存储链接 storage: localStorage || window.localStorage, // 获取本地存储数据库数据真实字段 getKey: function(key)&#123; return this.preId + key; &#125;, // 添加数据 set: function(key,value,callback,time)&#123; &#125;, // 获取数据 get: function(key,callback)&#123; &#125;, // 删除数据 remove: function(key,callback)&#123; &#125;&#125; 4.节流模式 对重复的业务逻辑进行节流控制，执行最后一次操作并取消其它操作，以提高性能。 清除将要执行的函数，传递两个参数（是否清除，执行函数）。如果true，则表示清除将要执行的函数，同时会判断第二个参数有没有计时器句柄，有则清除计时器。 延迟执行函数（执行函数，相关参数）。在节流器内部首先要为执行函数绑定一个计时器句柄，来保存该执行函数的计时器；相关参数包括执行函数在执行时的作用域，执行函数的参数，执行函数延迟执行的时间。 适用于：返回顶部、浮层、图片延迟加载…. 5.简单模板模式 通过格式化字符串拼凑出视图避免创建视图时大量字点操作。优化内存开销。 DOM操作创建视图造成大量消耗。正则方式去格式化字符串更好。 目前已经有成熟的模板第三方，当然底层的模板生成器原理也是非常重要的知识。 12345678910111213141516A.view = function(name)&#123; var v = &#123; code: '&lt;pre&gt;&lt;code&gt; &#123;#code#&#125; &lt;/code&gt;&lt;/pre&gt;', img: '&lt;img src=\"&#123;#src#&#125;\" alt=\"&#123;#alt#&#125;\" title=\"&#123;#title#&#125;\"&gt;', part: '&lt;div id=\"&#123;#id#&#125;\"&gt;&#123;#part#&#125;&lt;/div&gt;' &#125; if(Object.prototype.toString.call(name)===\"[object Array]\")&#123; var tpl = ''; for(var i=0,len=name.length;i&lt;len;i++)&#123; tpl += arguments.callee(name[i]); &#125; return tpl; &#125;else&#123; return v[name] ? v[name] : ('&lt;'+name+'&gt;&#123;#'+name+'#&#125;&lt;/'+name+'&gt;'); &#125;&#125; 6.惰性模式 减少每次代码执行时的重复性分支判断，通过对对象重定义来屏蔽原对象中的分支判断。 这是一种拖延模式，由于对象的创建或者数据的计算会花费高昂的代价，因此页面之处会延迟对这一类对象的创建。 文件加载后立即执行对象方法来冲定义对象 当第一次使用对象时重新定义对象。 123456789101112131415161718192021222324252627282930313233343536// 加载即执行A.on = function(dom,type,fn)&#123; if(document.addEventListener)&#123; return function(dom,type,fn)&#123; dom.addEventListener(type,fn,false); &#125; &#125; else if(document.attachEvent)&#123; return function(dom,type,fn)&#123; dom.attachEvent('on'+type,fn); &#125; &#125; else &#123; return function(dom,type,fn)&#123; dom('on'+type) = fn; &#125; &#125;&#125;();// 惰性执行A.on = function(dom,type,fn)&#123; if(document.addEventListener)&#123; A.on = function(dom,type,fn) dom.addEventListener(type,fn,false); &#125; &#125; else if(document.attachEvent)&#123; A.on = function(dom,type,fn) dom.attachEvent('on'+type,fn); &#125; &#125; else &#123; A.on = function(dom,type,fn) dom('on'+type) = fn; &#125; &#125; // 执行重新定义on方法 A.on(dom,type,fn);&#125; 7.参与者模式 在特定的作用域中执行给定的函数，并将参数原封不动地传递。 重点：函数绑定和函数柯理化 后期重点学习 8.等待着模式 通过对多个异步进程的监控，来触发未来发生的动作。 主要处理耗时比较长的操作。提供回调方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 等待者对象 var Waiter = function()&#123; // 注册等待对象容器 var dfd = [], doneArr = [], failArr = [], slice = Array.prototype.sclice, that = this; // 监控对象类 var Primise = function()&#123; this.resolved = false; this.rejected = false; &#125; // 监控对象原型方法 Primise.prototype = &#123; resolve: function()&#123;i this.resolved = true; if(!dfd.length) return; // 遍历所有注册了的监控对象 for(var i =dfd.length-1;i&gt;=0;i--)&#123; if(dfd[i]&amp;&amp;!dfd[i].resolved || dfd[i].rejected)&#123; return; &#125; &#125; dfd.slice(i,1);//清除监控对象 _exec(doneArr); &#125;, reject: function()&#123; this.rejected = true; if(!dfd.length) return; dfd.slice(0); //清除所有监控对象 _exec(failArr); &#125; &#125; // 创建监控对象 that.Deferred = function()&#123; return new Promise(); &#125; // 回调执行方法 function _exec(arr)&#123; var i = 0,len = arr.length; for(;i&lt;len;i++)&#123; try&#123; arr[i] &amp;&amp; arr[i](); &#125;catch(e)&#123;&#125; &#125; &#125; // 监控异步方法 参数 ：监控对象 that.when = function()&#123; dfd = slice.call(arguments); // 设置监控对象 var i = dfd.length; for(--i,i&gt;=0;i--)&#123; // 如果不存在监控对象，监控对象已经解决，不是监控对象 if(!dfd[i] || dfd[i].resolved || dfd[i].rejected || !dfd[i] instanceof Primise)&#123; dfd.slice(i,1); //清理内存 清理当前监控对象 &#125; &#125; // 返回等待者对象 return that; &#125;; // 解决成功回调函数添加方法 that.done = function()&#123; doneArr = doneArr.concat(slice.call(arguments)); return that; &#125;; // 解决失败回调函数添加方法 that.fail = function()&#123; failArr = failArr.concat(slice.call(arguments)); return that; &#125;;&#125;// 监控对象 六、架构型设计模式 是一类框架 结构，通过提供一些子系统，指定他们的职责，并将他们条理清楚地组织在一起。 已经有非常成熟的框架，只作简要概述，底层原理查看相关页码。 1.同步模块模式 模块化：将复杂的系统分解成高内聚、低耦合的模块 ，使系统开发变得可控、可维护、可拓展，提高模块 的复用率。 同步模块模式：SMD 请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。分而治之。 底层原理：P255 2.异步模块模式 异步模块模式：AMD请求发出后，继续其他业务 逻辑，知道模块加载完成执行后续逻辑，实现模块开发中对模块加载完成后的引用。 底层原理：P255 3.Widget模式 将页面分解成部件，针对部件开发，最终组合成完整的页面。 12345678// 模板引擎F.moudule('lib/template',function()&#123; var _TplEngine = function()&#123;&#125;, _getTpl = function()&#123;&#125;, _dealTpl = function()&#123;&#125;, _compileTpl = function()&#123;&#125; return _TplEngine;&#125;) 4.MVC模式 model view controller 将业务逻辑、数据、视图分离的方式组织架构代码。 12345678910111213141516171819202122232425262728293031323334353637var MVC = MVC || &#123;&#125;;MVC.model = function()&#123; var M = &#123;&#125;; M.data = &#123;&#125;; M.conf = &#123;&#125;; return &#123; getData:function(m)&#123;//获取服务端数据 return M.data[m]; &#125;, getConf:function(c)&#123;// 获取配置数据 return M.conf[c]; &#125;, setData:function(m,v)&#123;//设置服务端数据 M.data[m] = v; return this; &#125;, setConf:function(c)&#123;//设置配置数据 M.data[c] = v; return this; &#125;, &#125;&#125;();MVC.view = function()&#123; var M = MVC.model; var V = &#123;&#125;; return function(v)&#123; V[v]; &#125;&#125;();MVC.controller = function()&#123; var M = MVC.model; var V = MVC.view; var C = &#123;&#125;;&#125;(); 5.MVP模式 模型 视图 管理器Presenter。View不直接引用Model的数据，而是通过presenter实现对model层的数据访问。 12345678910111213141516171819202122~(function(window)&#123; var MVP = function()&#123;&#125;; MVP.model = function()&#123;&#125;; MVP.view = function()&#123;&#125;; MVP.presenter = function()&#123; var V = MVP.view; var M = MVP.model; var C = &#123;&#125;; return &#123; init: function()&#123; for(var i in C)&#123; C[i] &amp;&amp; C[i][M,V,i]; &#125; &#125; &#125; &#125;; // 入口 MVP.init = function()&#123;&#125;; // 向外暴露 window.MVP = MVP;&#125;)(window) 6.MVVM模式 模型 - 视图 - 视图模型 (VM) 底层原理:P298","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"TypeScript基础&实战[未完]","slug":"book/video/202001Typescript基础&实战","date":"2020-01-15T06:42:04.000Z","updated":"2022-06-05T14:08:41.959Z","comments":true,"path":"2020/01/15/book/video/202001Typescript基础&实战/","link":"","permalink":"http://yoursite.com/2020/01/15/book/video/202001Typescript%E5%9F%BA%E7%A1%80&%E5%AE%9E%E6%88%98/","excerpt":"","text":"基础篇强类型和弱类型动态类型和静态类型 1. 基本类型 数据类型 boolean numberstringarrayfunctionobjectsymbolundefinednull 新增 voidanynever元祖枚举高级类型 类型注解相当于强类型语言中的类型声明语法：(函数/变量):type 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 原型类型let bool: boolean = truelet num: number = 123let str: string = 'abc'// 数组let arr1: number[] = [1,2,3]let arr2: Array&lt;number&gt; = [1,2,3]let arr3: Array&lt;number | string&gt; = [1,2,3,'123']// 元组 限制类型和个数let tuple: [number,string] = [1,'1']tuple.push(2) //允许插入 // console.log(tuple[2]) // 但是不可以访问// 函数 ):number 返回值的类型let add = (x:number, y:number):number =&gt; x+ylet compute: (x:number,y:number) =&gt; numbercompute = (a,b) =&gt; a+b// 对象let obj: &#123;x:number,y:number&#125; = &#123;x:1,y:2&#125;obj.x = 3// symbollet s1: symbol = Symbol()let s2 = Symbol()// undefined,nulllet un:undefined = undefinedlet nu: null = null// num = undefined //可配置 strictNullChecks// num = nulllet n : number | undefined | null = 1// void 没有任何返回值的类型let noReturn = () =&gt; &#123;&#125;// anylet xx=1x='1'x=()=&gt;&#123;&#125;// never 永远不会有返回值的类型 死循环let error = () =&gt;&#123; throw new Error('error')&#125;let endless = () =&gt;&#123; while(true) &#123;&#125;&#125; 2. 枚举类型（一组具有名字的常量集合）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 枚举类型 */ // 数字枚举 0,1,2,3,4,5 反向映射 enum Role&#123; Reporter = 1, Developer, Maintainer, Owner, Guest &#125; // 字符串枚举 enum Message &#123; Success = '恭喜你，成功了', Fail = '抱歉，失败了' &#125; // 异构枚举 混用 不建议使用 enum Answer &#123; N, Y = 'YES' &#125; // 枚举成员 enum Char&#123; // const a, b=Char.a, c=1+3, // computed 编译阶段不计算 运行阶段才计算 在此后声明的常量必须初始化值 d=Math.random(), e='123'.length &#125; // 常量枚举 const enum Month &#123; Jan, Feb, Mar &#125; // 枚举类型 enum E &#123; a,b &#125; enum F &#123; a = 0, b=1&#125; enum G &#123; a='apple', b='banana'&#125; let e:E = 3 let f:F = 3 let e1:E.a let e2:E.b let e3:E.a let g1:G let g2:G.a 3. 接口1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 对象类型接口 */interface List &#123; id:number, name:string&#125;interface Result &#123; data: List[]&#125;function render(result: Result)&#123; result.data.forEach((value)=&gt;&#123; console.log(value.id,value.name) &#125;)&#125;let result = &#123; // 第0种，赋值变量 data:[ &#123;id:1,name:'1'&#125;, &#123;id:2,name:'2'&#125; ]&#125;render(result)// 类型断言 as Result 绕过类型检查 第一种render(&#123; data:[ &#123;id:1,name:'1',sex:'women'&#125;, &#123;id:2,name:'2'&#125; ]&#125; as Result)//or 第二种render(&lt;Result&gt;&#123; data:[ &#123;id:1,name:'1',sex:'women'&#125;, &#123;id:2,name:'2'&#125; ]&#125;)//or 第三种// interface List &#123;// readonly id:number, 只读属性// name:string// [x:string]:any// age?: number 可选属性 可以有也可以没有// &#125;// 数字索引接口interface StringArray &#123; [index:number]:string&#125;let chars:StringArray = ['A','B']// 字符串索引接口interface Names &#123; [index:string]:string&#125; 1234567891011121314151617181920212223242526272829/** * 函数类型接口 */// let add2: (x:number, y:number) =&gt; number// interface Add &#123;// (x:number,y:number):number// &#125; // 类型别名 type Add = (x:number,y:number) =&gt; number let add2:Add = (a,b)=&gt; a+b // 混合接口 interface Lib&#123; ():void; version: string; doSomething():void; &#125;function getLib()&#123; let lib:Lib =(()=&gt;&#123;&#125;) as Lib; //类型断言 lib.version = '1.0'; lib.doSomething = () =&gt;&#123;&#125; return lib&#125;let lib1 = getLib() //可创建多个实例lib1()lib1.doSomething() 函数相关知识点：可选参数、函数重载、默认值、剩余参数 123456789101112131415161718192021222324252627282930// 可选参数 ? 必须位于必选参数后面;必须参数不能位于可选参数之后function add5(x:string,y?:number)&#123; return y?x+y:x;&#125;add5('1')// 默认值function add6(x:number,y=0,z:number,q=1)&#123; return x+y+z+q;&#125;// 剩余参数function add7(x:number,...rest:number[])&#123; return x+rest.reduce((pre,cur)=&gt; pre+cur) //reduce求和&#125;add7(1,2,3,4,5)// 函数重载function add8(...rest: number[]):numberfunction add8(...rest: string[]):stringfunction add8(...rest: any[]):any&#123; let first = rest[0] if(typeof first === 'string')&#123; return rest.join('') &#125;else if(typeof first === 'number')&#123; return rest.reduce((pre,cur)=&gt; pre+cur) &#125;&#125;console.log(add8(1,2,3))console.log(add8('a','b','c')) 4. 类：继承和成员修饰符123456789101112131415161718192021222324// 类class Dog&#123; constructor(name:string)&#123; // 构造函数 可以设置为受保护 protected constructor() 可以被继承 this.name = name &#125; name:string run()&#123;&#125; private pri()&#123;&#125; //私有成员 不能在实例和子类中调用 protected pro()&#123;&#125; //受保护成员 不能在实例中调用 可以在子类中调用 readonly legs: number = 4 // 只读 static food:string ='boon' //静态成员 只能通过类名调用 可以被继承&#125;let dog = new Dog('wangwang')console.log(Dog.food)// 类的继承class Husky extends Dog&#123; constructor(name:string,public color:string)&#123; //构造函数 的参数 可以添加修饰符 public 将参数变成实例的属性 super(name) this.color = color &#125; // color:string&#125; 5. 类：抽象类和多态123456789101112131415161718// this 链式调用class WorkFlow&#123; step1()&#123; return this &#125; step2()&#123; return this &#125;&#125;new WorkFlow().step1().step2() // 子类class Myflow extends WorkFlow&#123; next()&#123; return this &#125;&#125;new Myflow().next().step1().next().step2() 6.类与接口1234567891011121314151617181920212223242526272829// 接口的继承 多个接口合并interface Man extends Human&#123; run(): void&#125;interface Child&#123; cry():void&#125;interface Boy extends Man,Child&#123;&#125;let boy: Boy=&#123; name:'123', run()&#123;&#125;, eat()&#123;&#125;, cry()&#123;&#125;&#125;class Auto&#123; state = 1 // private state2 = 0 // 非子类 C不能继承 私有属性&#125;interface AutoInterface extends Auto&#123;&#125;class C implements AutoInterface&#123; state = 1&#125;class Bus extends Auto implements AutoInterface&#123;&#125; 7.泛型12345678910111213141516171819202122232425262728293031323334353637383940414243/**泛型 * 不预先确定的数据类型，具体的类型在使用的时候才能确定 * 1.函数和类可以轻松的支持多种类型，增强程序的扩展性 * 2.不必谢多条函数重载，冗长的联合类型声明，增强代码可读书生 * 3.灵活控制类型之间的约束 * */ function log&lt;T&gt;(value:T):T&#123; console.log(value) return value&#125;log&lt;string[]&gt;(['a','b'])log(['a','b'])// 泛型接口interface Log&#123; &lt;T&gt;(value: T):T&#125;let myLog: Log = logmyLog('1')// 泛型类 和 泛型约束class LogClass&lt;T&gt;&#123; run(value:T)&#123; console.log(value) return value &#125;&#125;let log1 = new LogClass&lt;number&gt;() //指定类型log1.run(1)let log2 = new LogClass() //不指定log2.run('1')// 泛型约束interface Length&#123; length:number&#125;function logRule&lt;T extends Length&gt;(value:T)&#123; console.log(value,value.length) return value&#125;logRule([1])logRule('123')logRule(&#123;length:1&#125;) 8.1.类型检查机制123456789101112131415161718// 类型推断 从右向左let a = 1let b = [1]let c = (x=1) =&gt; x+1// 类型推断 从左到右 上下文推断window.onkeydown = (event) =&gt;&#123; console.log(event)&#125;interface Foo&#123; bar:number&#125;// let foo = &#123;&#125; as Foo 遗漏barlet foo:Foo = &#123; bar:1&#125; 8.2.类型兼容性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 类型的兼容性问题// X兼容Y：X目标类型 = Y源类型// 结构之间兼容：成员少的兼容成员多的// 函数之间兼容：参数多的兼容参数少的let s: string = 'a's = 'b'// 接口兼容性interface X&#123; a:any b:any&#125;interface Y&#123; a:any b:any c:any&#125;let x1:X=&#123;a:1,b:2&#125;let y1:Y = &#123;a:1,b:2,c:3&#125;x1 = y1// 函数兼容性type Handler = (a:number,b:number) =&gt; voidfunction hof(handler:Handler)&#123; return handler&#125;//1参数个数let handler1 = (a:number) =&gt;&#123;&#125;hof(handler1)let handler2 = (a:number,b:number,c:number) =&gt;&#123;&#125;// hof(handler2) 此就不兼容 多了C// 可选参数和剩余参数let a1 = (p1:number,p2:number) =&gt;&#123;&#125;let b1 = (p1?:number,p2?:number) =&gt;&#123;&#125;let c1 = (...args:number[]) =&gt;&#123;&#125;a1 = b1a1 = c1b1 = c1b1 = a1c1 = a1c1 = b1//2参数类型let handler3 = (a:string) =&gt;&#123;&#125;// hof(handler3)interface Point3D&#123; x:number y:number z:number&#125;interface point2D&#123; x:number y:number&#125;let p3d = (point: Point3D) =&gt;&#123;&#125;let p2d = (point: point2D) =&gt;&#123;&#125;p3d = p2dp2d = p3d//3 返回值类型 成员少的兼容成员多的let f1 = () =&gt; (&#123;name:'Alice'&#125;)let f2 = () =&gt; (&#123;name:'Alice',loacation:'beijing'&#125;)f1=f2function overload(a:number,b:number):numberfunction overload(a:string,b:string):stringfunction overload(a:any,b:any):any &#123;&#125;// 枚举兼容性enum Fruit &#123;Apple,Banana&#125;enum Color &#123;Red,Yellow&#125;let fruit:Fruit.Apple = 3let no:number = Fruit.Apple// let color:Color.Red = Fruit.Apple 不兼容//类兼容性class Ab&#123; constructor(p:number,q:number)&#123;&#125; id:number = 1&#125;class Bb&#123; static s=1 constructor(p:number)&#123;&#125; id:number=2&#125;let aa = new Ab(1,2)let bb = new Bb(1)aa = bb // 兼容 因为都有ID，静态成员不做比较 如果有私有成员，就不兼容bb = aa// 如果有私有成员，子类就兼容class CC extends Ab&#123;&#125;let cc = new CC(1,2)aa=cccc=aa//泛型兼容性 interface Empty&lt;T&gt;&#123; value:T&#125;let obj1:Empty&lt;number&gt; = &#123;&#125;let obj2:Empty&lt;string&gt; = &#123;&#125;// obj1 = obj2 不兼容//如果两个泛型定义相同，没有指定参数，是兼容的let logx1 = &lt;T&gt;(x:T):T=&gt;&#123; console.log('x') return x&#125;let logx2 = &lt;T&gt;(y:T):T=&gt;&#123; console.log('y') return y&#125;logx1 = logx2 8.3.类型保护机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 类型保护机制// TS能够在特定的区块中保证变量属于某种确定的类型// 可以在区块中放心的使用类型的属性，并且调用类型的方法enum Type&#123;Strong,Week&#125;class Java&#123; helloJava()&#123; console.log('HelloJava') &#125; java:any&#125;class JavaScript&#123; helloJavaScript()&#123; console.log('JavaScript') &#125; javascript:any&#125;function getLanguage(type:Type,x:string | number)&#123; let lang = type ===Type.Strong ? new Java():new JavaScript() // 1 比较麻烦的判断 // if((lang as Java).helloJava)&#123; // (lang as Java).helloJava() // &#125;else&#123; // (lang as JavaScript).helloJavaScript() // &#125; //2 使用instanceof属于哪个类 // if(lang instanceof Java)&#123; // lang.helloJava() // &#125;else&#123; // lang.helloJavaScript() // &#125; // 3 in 判断是属于某个对象 // if('java' in lang)&#123; // lang.helloJava() // &#125;else&#123; // lang.helloJavaScript() // &#125; // 4 typeof 判断 // if(typeof x==='string')&#123; // x.length // &#125;else&#123; // x.toFixed(2) // &#125; // 5 使用函数isJava if(isJava(lang))&#123; lang.helloJava() &#125;else&#123; lang.helloJavaScript() &#125; return lang&#125;function isJava(lang:Java | JavaScript):lang is Java&#123; //返回值为类型伪词 return (lang as Java).helloJava !== undefined&#125; 工程篇1.ES6 commonjs2.tsconfig.json 文件选项 files include exclude编译选项 complierOptions 【重点】工程引用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; \"compilerOptions\": &#123; \"allowUnreachableCode\": true, // 不报告执行不到的代码错误。 \"allowUnusedLabels\": false, // 不报告未使用的标签错误 \"alwaysStrict\": false, // 以严格模式解析并为每个源文件生成 \"use strict\"语句 \"baseUrl\": \".\", // 工作根目录 \"experimentalDecorators\": true, // 启用实验性的ES装饰器 \"jsx\": \"react\", // 在 .tsx文件里支持JSX \"sourceMap\": true, // 是否生成map文件 \"module\": \"commonjs\", // 指定生成哪个模块系统代码 \"noImplicitAny\": false, // 是否默认禁用 any \"removeComments\": true, // 是否移除注释 \"types\": [ //指定引入的类型声明文件，默认是自动引入所有声明文件，一旦指定该选项，则会禁用自动引入，改为只引入指定的类型声明文件，如果指定空数组[]则不引用任何文件 \"node\", // 引入 node 的类型声明 ], \"paths\": &#123; // 指定模块的路径，和baseUrl有关联，和webpack中resolve.alias配置一样 \"src\": [ //指定后可以在文件之直接 import * from 'src'; \"./src\" ], &#125;, \"target\": \"ESNext\", // 编译的目标是什么版本的 \"outDir\": \"./dist\", // 输出目录 \"declaration\": true, // 是否自动创建类型声明文件 \"declarationDir\": \"./lib\", // 类型声明文件的输出目录 \"allowJs\": true, // 允许编译javascript文件。 \"lib\": [ // 编译过程中需要引入的库文件的列表 \"es5\", \"es2015\", \"es2016\", \"es2017\", \"es2018\", \"dom\" ] &#125;, // 指定一个匹配列表（属于自动指定该路径下的所有ts相关文件） \"include\": [ \"src/**/*\" ], // 指定一个排除列表（include的反向操作） \"exclude\": [ \"demo.ts\" ], // 指定哪些文件使用该配置（属于手动一个个指定文件） \"files\": [ \"demo.ts\" ]&#125; 实战篇1. 创建工程 手动创建 制作组件 引入组件 修改webpack 修改typeconfig利用脚手架 sudo npx create-react-app ts-reat-app –typescript NPX为避免全局安装","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"}]},{"title":"高性能响应式WEB开发实战 & 响应式WEB设计 HTML5CSS3实战","slug":"book/2020/高性能响应式WEB开发实战","date":"2020-01-09T12:00:00.000Z","updated":"2022-06-05T14:08:41.958Z","comments":true,"path":"2020/01/09/book/2020/高性能响应式WEB开发实战/","link":"","permalink":"http://yoursite.com/2020/01/09/book/2020/%E9%AB%98%E6%80%A7%E8%83%BD%E5%93%8D%E5%BA%94%E5%BC%8FWEB%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/","excerpt":"","text":"定义响应式Responsive web design 流式布局。媒体查询。a day of web design视口的概念viewport 1、布局 全局样式 reset.css normalize.css ｜｜ 自定义全局样式 导航栏 桌面端 移动端 2、布局-响应式篇 媒体查询 移动优先 桌面优先 不支持媒体查询（IE8） 伸缩布局 FLEXBOX a complete guide to flex box // flexbox.css 3、相对单位 覆盖浏览器默认字体大小 PX永远不会被放大 在编写媒体查询代码（不适合） EM REM 标题布局 背景 6 methods for vertical centering with css 响应式文字 4、响应式图片 100% 响应式图片用例 Sir set 语法 Picture元素 离线优先 service workersCall HalCss3 新特性！！！！ 如何实现响应式设计 使用真实设备 Browsersync同步刷新 确定需要支持的浏览器 分层的用户体验 将CSS断点和JS联系起来 避免在生产中使用框架 采用务实的解决方案 尽可能使用简洁的代码 根据视口隐藏 展示 加载内容 验证器和代码检测工具 性能 下一个时代产物","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"高性能","slug":"高性能","permalink":"http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"},{"name":"响应式","slug":"响应式","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"}]},{"title":"It has never been too late to start","slug":"start","date":"2020-01-01T01:00:00.000Z","updated":"2022-03-17T15:15:23.580Z","comments":true,"path":"2020/01/01/start/","link":"","permalink":"http://yoursite.com/2020/01/01/start/","excerpt":"","text":"AboutMarong UI/UX Designer and Web developer for Web and Mobile. ContactWeb: http://www.marongrong.com Note: https://mrr3000.github.io QQ：849285229 Email：marong87@sina.com","categories":[],"tags":[]},{"title":"React学习手册 - 【未完】","slug":"book/2019/react学习手册","date":"2019-12-05T12:42:04.000Z","updated":"2022-06-05T14:08:41.954Z","comments":true,"path":"2019/12/05/book/2019/react学习手册/","link":"","permalink":"http://yoursite.com/2019/12/05/book/2019/react%E5%AD%A6%E4%B9%A0%E6%89%8B%E5%86%8C/","excerpt":"","text":"yarn 进行依赖管理 npm i -g yarn yarn add yarn remove javascript 新特性let const模版字符串 $(name)js - console.log($(name),$(name2))html - $(name) 默认参数123function log(name&#x3D;’nick’,active&#x3D;‘sking’)&#123; &#x2F;&#x2F;&#125; 箭头函数 =&gt; 。ES6转译 babel。ES6对象和数组。扩展运算符。Promise对象。类。模块。JS函数式编程函数添加到对象中123456const obj &#x3D; &#123; message:’this is ‘, log(message):&#123; console.log(message) &#125;&#125; 函数添加到数组中123const obj&#x3D;[‘this is’,message &#x3D;&gt; console.log(message),’like it’,message &#x3D;&gt; console.log(message)]message[1](message(0) &#x2F;&#x2F; this ismessage[3](message(2) &#x2F;&#x2F; like it 函数作为其他函数参数进行传递123const insidefn &#x3D; log &#x3D;&gt; log(“this is”)insidefn(message &#x3D;&gt; console.log(message)&#x2F;&#x2F; this is 函数作为其他函数的执行结果返回1234567var A &#x3D; function(log)&#123; return function(message)&#123; log(message.toUpperCase()+’!!’) &#125;&#125;const B &#x3D; A(message &#x3D;&gt; console.log(message))B(‘funciton can be returned from others’) 一个以上的箭头表示高阶函数1const create &#x3D; log &#x3D;&gt; message &#x3D;&gt; log(message.toUpperCase()+”!!!”) 命令式和声明式react声明式编程：对执行结果的描述远胜于执行过程命令式编程：重点关注达成目标的具体过程 函数式编程基本概念 不可变性 数据不可变，无法修改。 纯函数 数据转换 array.map array.reduce array.filter array.join 高阶函数 1将其他函数当作参数传递的函数 2 柯里化 递归 用户创建的函数调用自身的一种技术","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"WEB高效编程与优化实践","slug":"book/2019/WEB高效编程与优化实践","date":"2019-07-10T12:42:04.000Z","updated":"2022-06-05T14:08:41.954Z","comments":true,"path":"2019/07/10/book/2019/WEB高效编程与优化实践/","link":"","permalink":"http://yoursite.com/2019/07/10/book/2019/WEB%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"E1 能用HTML CSS解决的问题就不要用js 导航高亮 :hover 鼠标悬浮时的显示 display / before after 自定义radio/checkbox的样式 :checked 多列等高(使用margin负值法来实现；或使用table的自适应display:table-cell) 需要根据个数显示不同的样式(nth-last-of-type) 使用表单提交 自动监听回车时间 巧用css3伪类(:focus :invalid) 存在的问题 不兼容老的浏览器 &gt;ie9 E2 优化html标签 选择合适的标签 文字使用p h1~h6 表单 form html input type=email/number/tel 列表 ul li / ol li 表格 table 加粗 b/strong 跳转 a 按钮button 分隔线hr 使用HTML5语义化标签 div section article nav aside E3 使用CSS画一个三角形123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F; 向上的三角形实体.triangle&#123; border-right:50px solid transparent; border-left:50px solid transparent; border-top:50px solid transparent; border-bottom:50px solid #333; &#x2F;&#x2F; 50px控制大小 width:100px; height:100px; background:#ccc;&#125;&#x2F;&#x2F; 向左的三角形带边框.chat-msg&#123; width:300px; height:80px; border:1px solid #ccc; &#x2F;&#x2F; * position:relative; &#x2F;&#x2F; *&#125;.chat-msg:before&#123; content:&#39;&#39;; position:absolute; left:-10px; &#x2F;&#x2F; * top:34px; border-top:6px solid transparent; border-bottom:6px solid transparent; border-right:6px solid #ccc; &#x2F;&#x2F; *&#125;.chat-msg:after&#123; content:&#39;&#39;; position:absolute; left:-8px; &#x2F;&#x2F; * top:34px; border-top:6px solid transparent; border-bottom:6px solid transparent; border-right:6px solid #fff; &#x2F;&#x2F; *&#125; E4 使用伪元素 清除浮动 分割线、圆点小元素 展示文字content 。。。 伪元素适合辅助性的视觉元素 E5 减少前端代码耦合 避免全局耦合（全局变量推荐使用全局数据结构，使用模块化引入） JS CSS HTML的耦合 减少重复的代码（出现了重复的代码-》封装成一个函数-》封装成一个函数-》封装成一个模块-》封装成一个插件，抽象级别不断提高；根据单一责职原则，一个模块只负责一个功能） 封装成为一个类（模块化思想） 使用策略模式 访问者模式 E6 JS书写优化 按强类型风格写代码 定义变量的时候要指明类型(var tableStr,obj,num) 不要随意改变变量的类型 函数返回的类型应该是确定的 减少作用域查找 不要让代码暴露在全局作用域下（$(function(){})包一下制造局部作用域） 不要滥用闭包（嵌套太深，向上查找变量就越长时间） 避免==的使用 合并表达式 使用三木运算符取代ifelse 连等{…} 自增 ++ – 减少魔数123用此方法声明var number &#x3D; 1,type&#x3D;&#39;news&#39;,count&#x3D;30;keyfun(number,type,count) 使用ES6简化代码 使用箭头函数 使用CLASS代替prototype 字符串拼接减少使用+ 而使用反引号` 作用域变量 let const E8 加快页面打开速度 ready时间 load时间 减少渲染阻塞 避免head标签JS堵塞放在head标签里的CSS和JS都会阻塞渲染：解决方法一种是把script放到body后面；一种是给script加defer属性，是html5新属性，异步加载。 减少head标签里的css资源不要放太多base64放在css里，会导到css极速膨胀，不直接使用SVG，尽量使用图标字体；把CSS写成内联 优化图片 使用响应式图片 延迟加载图片 压缩和缓存 gzip压缩12345&#x2F;&#x2F; nginx配置里开启server&#123; gzip on; gzip_types text&#x2F;plain applicationjavascript application&#x2F;x-javascript text&#x2F;javascript text&#x2F;xml text&#x2F;css;&#125; cache-control设置缓存指把200变3041234567&#x2F;&#x2F; nginx配置 cache-control请求里会改变location ~*\\.(jpg|jpeg|png|gif|webp)$&#123; expires 30d;&#125;location ~*\\.(css|js)$&#123; expires 7d;&#125; 使用etag设置缓存两者都有优缺点12&#x2F;&#x2F; nginx配置开启只需一行etag on; 升级http/2优点在于对于一个域只建立一次tcp连接，使用多路复用，传输多个资源，这样就不用使用诸如雪碧、合并js/css文件等技术减少请求数。还能进行报文压缩。需要使用nginx 1.10.0 openssl 1.0.2以上版本。安装好后再nginx配置上加上http2。123listen 443 ssl http2;&#x2F;&#x2F; 浏览器资源加载显示协议就会由1.1变成2&#x2F;&#x2F; 若浏览器不支持http2，那nginx会自用处理只支持https，如果没有这些信息，会自动切换http&#x2F;1.1 其他优化方案 dns预读取12345&lt;link rel&#x3D;&quot;dns-prefecth&quot; href&#x3D;&#39;...&#39;&gt;&lt;link rel&#x3D;&quot;dns-prefecth&quot; href&#x3D;&#39;...&#39;&gt;&lt;link rel&#x3D;&quot;dns-prefecth&quot; href&#x3D;&#39;...&#39;&gt;&#x2F;&#x2F; 对于以上几个网站提前解析DNS，由于是并行的，不会阻塞页面渲染，缩短资源加载时间。 html优化 把本地html部署到服务器上前，可以对Html优化，把注释去掉，把行前缩进删掉，效果其实可观可以减少1/3。 代码优化html别嵌套太多层，否则加重LAYOUT的压力，CSS选择器别写太复杂，不然匹配的计算量会比较大。对JS，别滥用闭包，闭包会加深作用域连，加长变量查找时间。 E9 增强用户体验 加载loading效果 加载图片、数据需要加loading；加载ajax请求或上传文件 需要加进度条。 加载过渡动画效果 轮播过渡效果；导航动画效果。 单击和输入 用户单击时的效果；使用Html5 input type不同，显示的键盘也不同；自动补全。 记住 用户使用习惯 记住位置；记住用户输入的信息。 避免页面闪动 E10 用好chrome devtools 打印 console.table 常用的是console.log，但是在Obj时比较吃力，因此使用console.table console.dir 字符串化的打印，能递归打印所有属性 打印带样式 %c 检测没有用的css js coverage标签栏 截图全屏的功能 capture full size screenshot debugger console.trace追踪函数调用 查看某个函数绑定的事件 elements=&gt;event listenersf10 涵养f8 下一个断点command/ctrl + ; step into 进入函数执行shift + command/ctrl + ; step out 跳出当前函数 open in sources pannel 在sources pannel面板 查看源码 模拟断网做一些出错处理 network conditions 选项卡 研究重绘 rendering 标签研究重绘 使用timeline /perfomance看执行时间 黄色表示js cup占用率；红线表示失帧比较厉害；紫色表示css cpu；格子表示频率。 检查内存泄露 只要存在一个引用就不会进行gc回收，有些dom节点没有append到dom中，但存在引用指向它，它就是一个分离的dom节点，这叫做dom内存泄露。 profile &gt; take heap snapshot &gt; take snapshot 显示当前内存使用情况，在搜索框输入detached，出来的红色表示已经分离但没有引用，黄色表示已经分离有引用。 查看内存消耗 select profiling type &gt; record allocation timeline &gt; starttips：总的内存可以通过chrome的任务管理器查看 垃圾回收 在timeline里面查看。JS HEAP聚降，表示进行了一个垃圾回收，回收比较频繁，说明有问题。 查看链接时间 dns lookup - DNS解析Inltial connection - TCP连接ssl - HTTP连接 页面性能评测 使用audits栏提供的工具，可以对页面的性能PWA 最佳实践做一些评测。 E11 使用H5的HISTORY改善AJAX列表请求体验window.history.state E12 使用图标代替雪碧图雪碧图缺点 高清屏会失真 不方便变化变色变大 图标字体iconfont webkit浏览器会在边缘加粗一个像素 会有缓存，所以font-face导入的版本号参数腰带参数 多人协作 结合使用SVG 尽量少用吧 E13 理解和使用css3动画E14 实现前端裁剪压缩图片 拖拽显示图片 drag 压缩图片 借助canvas 和在 compress函数里 裁剪图片 cropper插件 上传进度条 E15 实现跨浏览器的html5表单验证支持跨浏览器的插件 html5 form 统一UI和文案 支持异步验证 支持多重类型规则验证 能够中英文切换 E16 使用Service Worker做一个PWA离线网页应用","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"高效","slug":"高效","permalink":"http://yoursite.com/tags/%E9%AB%98%E6%95%88/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"高效前端（WEB高效编程与优化实践）","slug":"book/2019/高效前端（WEB高效编程与优化实践）","date":"2019-07-09T12:42:04.000Z","updated":"2022-06-05T14:08:41.955Z","comments":true,"path":"2019/07/09/book/2019/高效前端（WEB高效编程与优化实践）/","link":"","permalink":"http://yoursite.com/2019/07/09/book/2019/%E9%AB%98%E6%95%88%E5%89%8D%E7%AB%AF%EF%BC%88WEB%E9%AB%98%E6%95%88%E7%BC%96%E7%A8%8B%E4%B8%8E%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5%EF%BC%89/","excerpt":"","text":"E1 能用HTML CSS解决的问题就不要用js 导航高亮 :hover 鼠标悬浮时的显示 display / before after 自定义radio/checkbox的样式 :checked 多列等高(使用margin负值法来实现；或使用table的自适应display:table-cell) 需要根据个数显示不同的样式(nth-last-of-type) 使用表单提交 自动监听回车时间 巧用css3伪类(:focus :invalid) 存在的问题 不兼容老的浏览器 &gt;ie9 E2 优化html标签 选择合适的标签 文字使用p h1~h6 表单 form html input type=email/number/tel 列表 ul li / ol li 表格 table 加粗 b/strong 跳转 a 按钮button 分隔线hr 使用HTML5语义化标签 div section article nav aside E3 使用CSS画一个三角形123456789101112131415161718192021222324252627282930313233343536&#x2F;&#x2F; 向上的三角形实体.triangle&#123; border-right:50px solid transparent; border-left:50px solid transparent; border-top:50px solid transparent; border-bottom:50px solid #333; &#x2F;&#x2F; 50px控制大小 width:100px; height:100px; background:#ccc;&#125;&#x2F;&#x2F; 向左的三角形带边框.chat-msg&#123; width:300px; height:80px; border:1px solid #ccc; &#x2F;&#x2F; * position:relative; &#x2F;&#x2F; *&#125;.chat-msg:before&#123; content:&#39;&#39;; position:absolute; left:-10px; &#x2F;&#x2F; * top:34px; border-top:6px solid transparent; border-bottom:6px solid transparent; border-right:6px solid #ccc; &#x2F;&#x2F; *&#125;.chat-msg:after&#123; content:&#39;&#39;; position:absolute; left:-8px; &#x2F;&#x2F; * top:34px; border-top:6px solid transparent; border-bottom:6px solid transparent; border-right:6px solid #fff; &#x2F;&#x2F; *&#125; E4 使用伪元素 清除浮动 分割线、圆点小元素 展示文字content 。。。 伪元素适合辅助性的视觉元素 E5 减少前端代码耦合 避免全局耦合（全局变量推荐使用全局数据结构，使用模块化引入） JS CSS HTML的耦合 减少重复的代码（出现了重复的代码-》封装成一个函数-》封装成一个函数-》封装成一个模块-》封装成一个插件，抽象级别不断提高；根据单一责职原则，一个模块只负责一个功能） 封装成为一个类（模块化思想） 使用策略模式 访问者模式 E6 JS书写优化 按强类型风格写代码 定义变量的时候要指明类型(var tableStr,obj,num) 不要随意改变变量的类型 函数返回的类型应该是确定的 减少作用域查找 不要让代码暴露在全局作用域下（$(function(){})包一下制造局部作用域） 不要滥用闭包（嵌套太深，向上查找变量就越长时间） 避免==的使用 合并表达式 使用三木运算符取代ifelse 连等{…} 自增 ++ – 减少魔数123用此方法声明var number &#x3D; 1,type&#x3D;&#39;news&#39;,count&#x3D;30;keyfun(number,type,count) 使用ES6简化代码 使用箭头函数 使用CLASS代替prototype 字符串拼接减少使用+ 而使用反引号` 作用域变量 let const E8 加快页面打开速度 ready时间 load时间 减少渲染阻塞 避免head标签JS堵塞放在head标签里的CSS和JS都会阻塞渲染：解决方法一种是把script放到body后面；一种是给script加defer属性，是html5新属性，异步加载。 减少head标签里的css资源不要放太多base64放在css里，会导到css极速膨胀，不直接使用SVG，尽量使用图标字体；把CSS写成内联 优化图片 使用响应式图片 延迟加载图片 压缩和缓存 gzip压缩12345&#x2F;&#x2F; nginx配置里开启server&#123; gzip on; gzip_types text&#x2F;plain applicationjavascript application&#x2F;x-javascript text&#x2F;javascript text&#x2F;xml text&#x2F;css;&#125; cache-control设置缓存指把200变3041234567&#x2F;&#x2F; nginx配置 cache-control请求里会改变location ~*\\.(jpg|jpeg|png|gif|webp)$&#123; expires 30d;&#125;location ~*\\.(css|js)$&#123; expires 7d;&#125; 使用etag设置缓存两者都有优缺点12&#x2F;&#x2F; nginx配置开启只需一行etag on; 升级http/2优点在于对于一个域只建立一次tcp连接，使用多路复用，传输多个资源，这样就不用使用诸如雪碧、合并js/css文件等技术减少请求数。还能进行报文压缩。需要使用nginx 1.10.0 openssl 1.0.2以上版本。安装好后再nginx配置上加上http2。123listen 443 ssl http2;&#x2F;&#x2F; 浏览器资源加载显示协议就会由1.1变成2&#x2F;&#x2F; 若浏览器不支持http2，那nginx会自用处理只支持https，如果没有这些信息，会自动切换http&#x2F;1.1 其他优化方案 dns预读取12345&lt;link rel&#x3D;&quot;dns-prefecth&quot; href&#x3D;&#39;...&#39;&gt;&lt;link rel&#x3D;&quot;dns-prefecth&quot; href&#x3D;&#39;...&#39;&gt;&lt;link rel&#x3D;&quot;dns-prefecth&quot; href&#x3D;&#39;...&#39;&gt;&#x2F;&#x2F; 对于以上几个网站提前解析DNS，由于是并行的，不会阻塞页面渲染，缩短资源加载时间。 html优化 把本地html部署到服务器上前，可以对Html优化，把注释去掉，把行前缩进删掉，效果其实可观可以减少1/3。 代码优化html别嵌套太多层，否则加重LAYOUT的压力，CSS选择器别写太复杂，不然匹配的计算量会比较大。对JS，别滥用闭包，闭包会加深作用域连，加长变量查找时间。 E9 增强用户体验 加载loading效果 加载图片、数据需要加loading；加载ajax请求或上传文件 需要加进度条。 加载过渡动画效果 轮播过渡效果；导航动画效果。 单击和输入 用户单击时的效果；使用Html5 input type不同，显示的键盘也不同；自动补全。 记住 用户使用习惯 记住位置；记住用户输入的信息。 避免页面闪动 E10 用好chrome devtools 打印 console.table 常用的是console.log，但是在Obj时比较吃力，因此使用console.table console.dir 字符串化的打印，能递归打印所有属性 打印带样式 %c 检测没有用的css js coverage标签栏 截图全屏的功能 capture full size screenshot debugger console.trace追踪函数调用 查看某个函数绑定的事件 elements=&gt;event listenersf10 涵养f8 下一个断点command/ctrl + ; step into 进入函数执行shift + command/ctrl + ; step out 跳出当前函数 open in sources pannel 在sources pannel面板 查看源码 模拟断网做一些出错处理 network conditions 选项卡 研究重绘 rendering 标签研究重绘 使用timeline /perfomance看执行时间 黄色表示js cup占用率；红线表示失帧比较厉害；紫色表示css cpu；格子表示频率。 检查内存泄露 只要存在一个引用就不会进行gc回收，有些dom节点没有append到dom中，但存在引用指向它，它就是一个分离的dom节点，这叫做dom内存泄露。 profile &gt; take heap snapshot &gt; take snapshot 显示当前内存使用情况，在搜索框输入detached，出来的红色表示已经分离但没有引用，黄色表示已经分离有引用。 查看内存消耗 select profiling type &gt; record allocation timeline &gt; starttips：总的内存可以通过chrome的任务管理器查看 垃圾回收 在timeline里面查看。JS HEAP聚降，表示进行了一个垃圾回收，回收比较频繁，说明有问题。 查看链接时间 dns lookup - DNS解析Inltial connection - TCP连接ssl - HTTP连接 页面性能评测 使用audits栏提供的工具，可以对页面的性能PWA 最佳实践做一些评测。 E11 使用H5的HISTORY改善AJAX列表请求体验window.history.state E12 使用图标代替雪碧图雪碧图缺点 高清屏会失真 不方便变化变色变大 图标字体iconfont webkit浏览器会在边缘加粗一个像素 会有缓存，所以font-face导入的版本号参数腰带参数 多人协作 结合使用SVG 尽量少用吧 E13 理解和使用css3动画E14 实现前端裁剪压缩图片 拖拽显示图片 drag 压缩图片 借助canvas 和在 compress函数里 裁剪图片 cropper插件 上传进度条 E15 实现跨浏览器的html5表单验证支持跨浏览器的插件 html5 form 统一UI和文案 支持异步验证 支持多重类型规则验证 能够中英文切换 E16 使用Service Worker做一个PWA离线网页应用","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"高效","slug":"高效","permalink":"http://yoursite.com/tags/%E9%AB%98%E6%95%88/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"深入浅出WEBPACK","slug":"book/2019/深入浅出webpack","date":"2019-07-05T12:42:04.000Z","updated":"2022-06-05T14:08:41.955Z","comments":true,"path":"2019/07/05/book/2019/深入浅出webpack/","link":"","permalink":"http://yoursite.com/2019/07/05/book/2019/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAwebpack/","excerpt":"","text":"一、入门核心概念 Entry 入口 Module 模块 一切皆模块 Chunk 代码块 用于代码合并与分割 Loader 模块转换器 Plugin 扩展插件 Output 输出 源码 使用Loader / Plugin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const path &#x3D; require(&#39;path&#39;)module.exports &#x3D; &#123; &#x2F;*JS执行入口页面*&#x2F; entry: &#123; app: [&quot;babel-polyfill&quot;,&quot;.&#x2F;src&#x2F;main.js&quot;] &#125;, &#x2F;*输出配置*&#x2F; output: &#123; path: path.resolve(__dirname, &#39;..&#x2F;dist&#39;), &#x2F;&#x2F; 将输出文件都放到dist目录下 filename: &#39;bundle.js&#39;, &#x2F;&#x2F; 将所有依赖的模块合并输出到一个bundle.js文件 publicPath: &#39;.&#x2F;static&#x2F;&#39; &#x2F;&#x2F; 输出解析文件的目录 &#125;, resolve: &#123; extensions: [&#39;.js&#39;, &#39;.vue&#39;, &#39;.json&#39;], alias: &#123; &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;, &#39;@&#39;: resolve(&#39;src&#39;), &#39;src&#39;: path.resolve(__dirname, &#39;..&#x2F;src&#39;) &#125; &#125;, externals: &#123; jquery: &#39;jQuery&#39; &#125;, &#x2F;* * 使用Loader * Webpack不原生支持解析非JS类型的类型，需要通用Loader机制 * - use 属性值需要是一个由Loader名称组成的数组 执行顺序是由后到前 * - 每个Loader都可以通过URL querystring的方式传入参数 还可以通过object * 需要按需安装 style-loader css-loader vue-loader * 更多的规则 https:&#x2F;&#x2F;github.com&#x2F;webpack-contrib&#x2F;css-loader *&#x2F; module: &#123; rules: [ &#123; test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 用正则表达式去匹配 use:[&#39;style-loader&#39;,&#39;css-loader?minimize&#39;] &#x2F;&#x2F; minimize告诉css-loader要开启css压缩 先执行css-loader 再执行sytle-loader &#125; ] &#125;, &#x2F;* * 使用plugin 扩展功能 * 每一项都是插件的一个实例 *&#x2F; plugins: [ new webpack.optimize.CommonsChunkPlugin(&#39;common.js&#39;), new webpack.ProvidePlugin(&#123; jQuery: &quot;jquery&quot;, $: &quot;jquery&quot; &#125;)， &#x2F;&#x2F; 从.js文件中提取出来的.css文件的名称 需要安装extract-text-webpack-plugin new ExtractTextPlugin(&#123; filename: &#96;[name]_[contenthash:8].css&#96; &#125;) ]&#125; 使用devserver 提供HTTP服务而不是使用本地文件预览 监听文件的变化并自动刷新网页 实时预览 支持SOURCE MAP 方便调试 webpack-dev-server 二、实战SCSS 又叫做sass，区别在于SASS语法类似于Ruby。SCSS类似于CSS。推荐SCSS node-sass1234$blue:#1875e7;div&#123; color:$blue;&#125; 12345678module:&#123; rules:[ &#123; test:&#x2F;\\.scss&#x2F;, use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;sass-loader&#39;] &#125; ]&#125; PostCSS css 预处理器 下一代的CSS 采用JS编写 运行在NODE123456:root&#123; --red:#d33;&#125;h1&#123; color:var(--red);&#125; 12345rules:[ &#x2F;&#x2F; 使用postcss处理CSS文件 test:&#x2F;\\.css&#x2F;, use:[&#39;style-loader&#39;,&#39;css-loader&#39;,&#39;postcss-loader&#39;]] Electron 使用开发WEB的技术跨平台的桌面端应用 main.js 123456789101112131415161718192021222324252627282930313233const &#123; app, BrowserWindow &#125; &#x3D; require(&#39;electron&#39;)&#x2F;&#x2F; 保持一个对于 window 对象的全局引用，如果你不这样做，&#x2F;&#x2F; 当 JavaScript 对象被垃圾回收， window 会被自动地关闭let win&#x2F;&#x2F; 打开主窗口function createWindow() &#123; &#x2F;&#x2F; 创建浏览器窗口 win &#x3D; new BrowserWindow(&#123; width: 800, height: 600 &#125;) &#x2F;&#x2F; 加载应用的 index.html const indexPageURL &#x3D; &#96;file:&#x2F;&#x2F;$&#123;__dirname&#125;&#x2F;dist&#x2F;index.html&#96;; win.loadURL(indexPageURL); &#x2F;&#x2F; 当 window 被关闭，这个事件会被触发 win.on(&#39;closed&#39;, () &#x3D;&gt; &#123; &#x2F;&#x2F; 取消引用 window 对象 win &#x3D; null &#125;)&#125;&#x2F;&#x2F; Electron 会在创建浏览器窗口时调用这个函数。app.on(&#39;ready&#39;, createWindow)&#x2F;&#x2F; 当全部窗口关闭时退出app.on(&#39;window-all-closed&#39;, () &#x3D;&gt; &#123; &#x2F;&#x2F; 在 macOS 上，除非用户用 Cmd + Q 确定地退出 &#x2F;&#x2F; 否则绝大部分应用会保持激活 if (process.platform !&#x3D;&#x3D; &#39;darwin&#39;) &#123; app.quit() &#125;&#125;) webpack.config.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576const path &#x3D; require(&#39;path&#39;);const UglifyJsPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;optimize&#x2F;UglifyJsPlugin&#39;);const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);const DefinePlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;DefinePlugin&#39;);const &#123; AutoWebPlugin &#125; &#x3D; require(&#39;web-webpack-plugin&#39;);&#x2F;&#x2F; 使用本文的主角 AutoWebPlugin，自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin &#x3D; new AutoWebPlugin(&#39;pages&#39;, &#123; template: &#39;.&#x2F;template.html&#39;, &#x2F;&#x2F; HTML 模版文件所在的文件路径 postEntrys: [&#39;.&#x2F;common.css&#39;],&#x2F;&#x2F; 所有页面都依赖这份通用的 CSS 样式文件 &#x2F;&#x2F; 提取出所有页面公共的代码 commonsChunk: &#123; name: &#39;common&#39;,&#x2F;&#x2F; 提取出公共代码 Chunk 的名称 &#125;,&#125;);module.exports &#x3D; &#123; &#x2F;&#x2F; AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， &#x2F;&#x2F; autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; &#x2F;&#x2F; 这里可以加入你额外需要的 Chunk 入口 &#125;), &#x2F;&#x2F; 构建出用于 Electron 渲染进程用的 JavaScript 代码，也就是这2个窗口需要的代码 target: &#39;electron-renderer&#39;, output: &#123; filename: &#39;[name]_[chunkhash:8].js&#39;,&#x2F;&#x2F; 给输出的文件名称加上 hash 值 path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;), &#125;, module: &#123; rules: [ &#123; test: &#x2F;\\.js$&#x2F;, use: [&#39;babel-loader&#39;], &#x2F;&#x2F; 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 exclude: path.resolve(__dirname, &#39;node_modules&#39;), &#125;, &#123; test: &#x2F;\\.css&#x2F;,&#x2F;&#x2F; 增加对 CSS 文件的支持 &#x2F;&#x2F; 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: [&#39;css-loader?minimize&#39;] &#x2F;&#x2F; 压缩 CSS 代码 &#125;), &#125;, ] &#125;, plugins: [ autoWebPlugin, new ExtractTextPlugin(&#123; filename: &#96;[name]_[contenthash:8].css&#96;,&#x2F;&#x2F; 给输出的 CSS 文件名称加上 hash 值 &#125;), new DefinePlugin(&#123; &#x2F;&#x2F; 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分 &#39;process.env&#39;: &#123; NODE_ENV: JSON.stringify(&#39;production&#39;) &#125; &#125;), &#x2F;&#x2F; 压缩输出的 JS 代码 new UglifyJsPlugin(&#123; &#x2F;&#x2F; 最紧凑的输出 beautify: false, &#x2F;&#x2F; 删除所有的注释 comments: false, compress: &#123; &#x2F;&#x2F; 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, &#x2F;&#x2F; 删除所有的 &#96;console&#96; 语句，可以兼容ie浏览器 drop_console: true, &#x2F;&#x2F; 内嵌定义了但是只用到一次的变量 collapse_vars: true, &#x2F;&#x2F; 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;), ], devtool: &#39;source-map&#39;,&#125;; 三、优化一）、缩小文件的搜索范围1 - 优化Loader配置由于Loader对文件的转换很耗时，尽可能减少文件被Loader处理 1234567rules:[ &#123; test:&#x2F;\\.js$&#x2F;,&#x2F;&#x2F; 如果只有JS文件，就不要写成.jsx$，提升正则的性能 user:[&#39;babel-loader?cacheDirectory&#39;],&#x2F;&#x2F; babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启 include:path.resolve(_dirname,&#39;src&#39;)&#x2F;&#x2F; 只对项目根目录下的src采用babel-loader 通过include缩小命中范围 &#125;] 2 - 优化resolve.modules配置指明存放第三方模块的绝对路径，以减少寻找 12345resolve: &#123; &#x2F;&#x2F; 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 &#x2F;&#x2F; __dirname 项目根目录 modules:[ path.resolve(__dirname,&#39;node_modules&#39;) ] &#125;, 3 - 优化resolve.mainFields配置配置第三方模块使用哪个入口文件 1234&#123; &quot;browser&quot;:&quot;fetch-npm-browserify.js&quot;, &quot;main&quot;:&quot;fetch-npm-node.js&quot;&#125; 12345resolve: &#123; &#x2F;&#x2F; mainFields:[&#39;browser&#39;,&#39;module&#39;,&#39;main&#39;] &#x2F;&#x2F; 只使用main字段作为入口文件的描述字段 以减少搜索的步骤 mainFields:[&#39;main&#39;]&#125; 4 - 优化resolve.alias配置通过别名来将原导入路么映射成一个新的导入路径除了react库，大多数库都会有完整文件，对于这些库，可以单独配置alias 12345678910resolve: &#123; alias: &#123; &#39;react&#39;: path.resolve(_dirname, &#39;.&#x2F;node_modules&#x2F;react&#x2F;dist&#x2F;react.min.js&#39;), &#39;vue$&#39;: &#39;vue&#x2F;dist&#x2F;vue.esm.js&#39;, &#39;@&#39;: resolve(&#39;src&#39;), &#39;src&#39;: path.resolve(__dirname, &#39;..&#x2F;src&#39;), &#39;assets&#39;: path.resolve(__dirname, &#39;..&#x2F;src&#x2F;assets&#39;) &#x2F;&#x2F; ... &#125;&#125; 5 - 优化resolve.extensions配置在导入语句没带后缀时，会自动带上后缀去尝试此配置会降低构建性能，尝试次数过多后缀尝试列表尽量可能小，不存在的后缀就不要设置频率出现最高的后缀要优先放在最前面在源码中导入语句时，尽可能的带上后缀 1234resolve: &#123; &#x2F;&#x2F; 尽可能减少后缀尝试的可能 extensions: [&#39;js&#39;]&#125; 6 - 优化module.noParse配置忽略对部份没采用模块化的文件进行递归解析处理，这样做可以提高构建性能比如一些jQuery Chart库 解析没有任何意义被忽略的文件不应该包含import require define 等模块化语句 123module: &#123; noParse: [&#x2F;react\\.min\\.js$&#x2F;]&#125; 二）、动态连接库 DllPlugin三）、使用HappyPack 多进程 webpack是单线程 HappyPack将任务分解给多个子进程去并发执行，子进程处理完后会将结果发给主进程 最耗时的流程是loader对文件的转换 核心调度会将一个个任务分配给当前空闲的子进程 1234567891011121314151617181920212223242526272829303132333435363738394041const path &#x3D; require(&#39;path&#39;);const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);const HappyPack &#x3D; require(&#39;happypack&#39;);module.exports &#x3D; &#123; module: &#123; rules: [ &#123; test: &#x2F;\\.js$&#x2F;, &#x2F;&#x2F; 把对 .js 文件的处理转交给 id 为 babel 的 HappyPack 实例 use: [&#39;happypack&#x2F;loader?id&#x3D;babel&#39;], &#x2F;&#x2F; 排除 node_modules 目录下的文件，node_modules 目录下的文件都是采用的 ES5 语法，没必要再通过 Babel 去转换 exclude: path.resolve(__dirname, &#39;node_modules&#39;), &#125;, &#123; &#x2F;&#x2F; 把对 .css 文件的处理转交给 id 为 css 的 HappyPack 实例 test: &#x2F;\\.css$&#x2F;, use: ExtractTextPlugin.extract(&#123; use: [&#39;happypack&#x2F;loader?id&#x3D;css&#39;], &#125;), &#125;, ] &#125;, plugins: [ new HappyPack(&#123; &#x2F;&#x2F; 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: &#39;babel&#39;, &#x2F;&#x2F; 如何处理 .js 文件，用法和 Loader 配置中一样 loaders: [&#39;babel-loader?cacheDirectory&#39;], &#125;), new HappyPack(&#123; id: &#39;css&#39;, &#x2F;&#x2F; 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: [&#39;css-loader&#39;], &#125;), new ExtractTextPlugin(&#123; filename: &#96;[name].css&#96;, &#125;), ], devtool: &#39;source-map&#39; &#x2F;&#x2F; 输出 source-map 方便直接调试 ES6 源码&#125;; 四）、使用ParallelUglifyPlugin 最常见的是UglifyJS,但是其是去一个一个压缩再输出 使用ParallelUglifyPlugin是会开启多个子进程 其它还有UglifyES一般用于较新的es6 react 五）、使用自动刷新 webpack有两大功能webpack和webpack-dev-server 内置了文件监听功能 webpack模块负责监听文件 webpack-dev-server模块负责刷新浏览器 123456789101112&#x2F;&#x2F; - webpack模块负责监听文件&#123; watch:true,&#x2F;&#x2F; 监听开启 watchOptions:&#123; &#x2F;&#x2F;只有在监听开启时watchOptions才有意义 ignored:&#x2F;node_modules&#x2F;,&#x2F;&#x2F;不监听的文件目录 aggregateTimeout:300,&#x2F;&#x2F;监听到变化发生后300ms再去执行，截流，默认300ms 值越大越好，降低重构的频率 poll:1000 &#x2F;&#x2F;判断文件是否变化是通过不停的询问系统指定文件有没有变化实现的 值越小越好，降低检查的频率 &#125;&#125;&#x2F;&#x2F;webpack-dev-server模块负责刷新浏览器webpack-dev-server --inline false关闭 六）、开启模块热替换1234567891011121314&#x2F;&#x2F; 开启webpack-dev-server --hot&#x2F;&#x2F; 配置const HotModuleReplacementPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;HotModuleReplacementPlugin&#39;)&#123; plugins:[ &#x2F;&#x2F; 该插件实现模块热替换， 生成.hot-update.json文件 new HotModuleReplacementPlugin(), ], devServer:&#123; &#x2F;&#x2F;告诉DEVSERVER要开启模块热替换模式 hot:true &#125;&#125; 七）、区分环境1process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &#39;production&#39; 八）、压缩代码 压缩JS UglifyJS ParallelUglifyPlugin UglifyES 压缩CSS cssnano 九）、CDN加速12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const path &#x3D; require(&#39;path&#39;);const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);const &#123;WebPlugin&#125; &#x3D; require(&#39;web-webpack-plugin&#39;);module.exports &#x3D; &#123; &#x2F;&#x2F; 省略 entry 配置... output: &#123; &#x2F;&#x2F; 给输出的 JavaScript 文件名称加上 Hash 值 filename: &#39;[name]_[chunkhash:8].js&#39;, path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;), &#x2F;&#x2F; 指定存放 JavaScript 文件的 CDN 目录 URL publicPath: &#39;&#x2F;&#x2F;js.cdn.com&#x2F;id&#x2F;&#39;, &#125;, module: &#123; rules: [ &#123; &#x2F;&#x2F; 增加对 CSS 文件的支持 test: &#x2F;\\.css$&#x2F;, &#x2F;&#x2F; 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; &#x2F;&#x2F; 压缩 CSS 代码 use: [&#39;css-loader?minimize&#39;], &#x2F;&#x2F; 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL publicPath: &#39;&#x2F;&#x2F;img.cdn.com&#x2F;id&#x2F;&#39; &#125;), &#125;, &#123; &#x2F;&#x2F; 增加对 PNG 文件的支持 test: &#x2F;\\.png$&#x2F;, &#x2F;&#x2F; 给输出的 PNG 文件名称加上 Hash 值 use: [&#39;file-loader?name&#x3D;[name]_[hash:8].[ext]&#39;], &#125;, &#x2F;&#x2F; 省略其它 Loader 配置... ] &#125;, plugins: [ &#x2F;&#x2F; 使用 WebPlugin 自动生成 HTML new WebPlugin(&#123; &#x2F;&#x2F; HTML 模版文件所在的文件路径 template: &#39;.&#x2F;template.html&#39;, &#x2F;&#x2F; 输出的 HTML 的文件名称 filename: &#39;index.html&#39;, &#x2F;&#x2F; 指定存放 CSS 文件的 CDN 目录 URL stylePublicPath: &#39;&#x2F;&#x2F;css.cdn.com&#x2F;id&#x2F;&#39;, &#125;), new ExtractTextPlugin(&#123; &#x2F;&#x2F; 给输出的 CSS 文件名称加上 Hash 值 filename: &#96;[name]_[contenthash:8].css&#96;, &#125;), &#x2F;&#x2F; 省略代码压缩插件配置... ],&#125;; 十）、使用tree shaking 剔除JS中用不上的死代码 十一）、提取公共代码12345const CommonsChunkPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;optimize&#x2F;CommonsChunkPlugin&#39;)new CommonsChunkPlugin(&#123; chunks:[&#39;common&#39;,&#39;base&#39;], name:&#39;base&#39;&#125;) 十二）、按需加载··· 十三）、使用prepack 优化代码在运行时的效率 prepack-webpack-plugin123456const PrepackWebpackPlugin &#x3D; require(&#39;prepack-webpack-plugin&#39;)module.exports &#x3D; &#123; plugins:[ new PrepackWebpackPlugin() ]&#125; 十四）、开启scope hoisting 打包出来的代码文件更小、运行更快、又被译作作用域提升 原理：分析模块之间的依赖关系，打散模块合并到一个函数中。 只有被引用一次的模块才能被合并 源码必须采用ES6来写 123456789const ModuleConcatenationPlugin&#x3D;require(&#39;webpack&#x2F;lib&#x2F;optimize&#x2F;ModuleConcatenationPlugin&#39;)module.exports &#x3D; &#123; plugins:[ new ModuleConcatenationPlugin() ], resolve:&#123; mainFields:[&#39;jsnext:main&#39;,&#39;browser&#39;,&#39;main&#39;] &#125;&#125; 十五）、其它优化 webpack –profile –json 记录构建过程中的耗时信息，以JSON的格式输出结果，会生成stats.json 将文件上传官方分析(webpack analyse) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const path = require('path');const DefinePlugin = require('webpack/lib/DefinePlugin');const ModuleConcatenationPlugin = require('webpack/lib/optimize/ModuleConcatenationPlugin');const CommonsChunkPlugin = require('webpack/lib/optimize/CommonsChunkPlugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');const &#123;AutoWebPlugin&#125; = require('web-webpack-plugin');const HappyPack = require('happypack');const ParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');// 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin = new AutoWebPlugin('./src/pages', &#123; // HTML 模版文件所在的文件路径 template: './template.html', // 提取出所有页面公共的代码 commonsChunk: &#123; // 提取出公共代码 Chunk 的名称 name: 'common', &#125;, // 指定存放 CSS 文件的 CDN 目录 URL stylePublicPath: '//css.cdn.com/id/',&#125;);module.exports = &#123; // AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， // autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; // 这里可以加入你额外需要的 Chunk 入口 base: './src/base.js', &#125;), output: &#123; // 给输出的文件名称加上 hash 值 filename: '[name]_[chunkhash:8].js', path: path.resolve(__dirname, './dist'), // 指定存放 JavaScript 文件的 CDN 目录 URL publicPath: '//js.cdn.com/id/', &#125;, resolve: &#123; // 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 // 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, 'node_modules')], // 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: ['jsnext:main', 'main'], &#125;, module: &#123; rules: [ &#123; // 如果项目源码中只有 js 文件就不要写成 /\\.jsx?$/，提升正则表达式性能 test: /\\.js$/, use: ['happypack/loader?id=babel'], // 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, 'src'), &#125;, &#123; test: /\\.js$/, use: ['happypack/loader?id=ui-component'], include: path.resolve(__dirname, 'src'), &#125;, &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: ['happypack/loader?id=css'], // 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL publicPath: '//img.cdn.com/id/' &#125;), &#125;, ] &#125;, plugins: [ autoWebPlugin, // 4-14开启ScopeHoisting new ModuleConcatenationPlugin(), // 4-3使用HappyPack new HappyPack(&#123; // 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: 'babel', // babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: ['babel-loader?cacheDirectory'], &#125;), new HappyPack(&#123; // UI 组件加载拆分 id: 'ui-component', loaders: [&#123; loader: 'ui-component-loader', options: &#123; lib: 'antd', style: 'style/index.css', camel2: '-' &#125; &#125;], &#125;), new HappyPack(&#123; id: 'css', // 如何处理 .css 文件，用法和 Loader 配置中一样 // 通过 minimize 选项压缩 CSS 代码 loaders: ['css-loader?minimize'], &#125;), new ExtractTextPlugin(&#123; // 给输出的 CSS 文件名称加上 hash 值 filename: `[name]_[contenthash:8].css`, &#125;), // 4-11提取公共代码 new CommonsChunkPlugin(&#123; // 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: ['common', 'base'], // 把公共的部分放到 base 中 name: 'base' &#125;), new DefinePlugin(&#123; // 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分 'process.env': &#123; NODE_ENV: JSON.stringify('production') &#125; &#125;), // 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; // 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; // 最紧凑的输出 beautify: false, // 删除所有的注释 comments: false, &#125;, compress: &#123; // 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, // 删除所有的 `console` 语句，可以兼容ie浏览器 drop_console: true, // 内嵌定义了但是只用到一次的变量 collapse_vars: true, // 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;, &#125;), ]&#125;; 四、优化总结 - webpack-dist.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139const path &#x3D; require(&#39;path&#39;);const DefinePlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;DefinePlugin&#39;);const ModuleConcatenationPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;optimize&#x2F;ModuleConcatenationPlugin&#39;);const CommonsChunkPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;optimize&#x2F;CommonsChunkPlugin&#39;);const ExtractTextPlugin &#x3D; require(&#39;extract-text-webpack-plugin&#39;);const &#123;AutoWebPlugin&#125; &#x3D; require(&#39;web-webpack-plugin&#39;);const HappyPack &#x3D; require(&#39;happypack&#39;);const ParallelUglifyPlugin &#x3D; require(&#39;webpack-parallel-uglify-plugin&#39;);&#x2F;&#x2F; 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin &#x3D; new AutoWebPlugin(&#39;.&#x2F;src&#x2F;pages&#39;, &#123; &#x2F;&#x2F; HTML 模版文件所在的文件路径 template: &#39;.&#x2F;template.html&#39;, &#x2F;&#x2F; 提取出所有页面公共的代码 commonsChunk: &#123; &#x2F;&#x2F; 提取出公共代码 Chunk 的名称 name: &#39;common&#39;, &#125;, &#x2F;&#x2F; 指定存放 CSS 文件的 CDN 目录 URL stylePublicPath: &#39;&#x2F;&#x2F;css.cdn.com&#x2F;id&#x2F;&#39;,&#125;);module.exports &#x3D; &#123; &#x2F;&#x2F; AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， &#x2F;&#x2F; autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; &#x2F;&#x2F; 这里可以加入你额外需要的 Chunk 入口 base: &#39;.&#x2F;src&#x2F;base.js&#39;, &#125;), output: &#123; &#x2F;&#x2F; 给输出的文件名称加上 hash 值 filename: &#39;[name]_[chunkhash:8].js&#39;, path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;), &#x2F;&#x2F; 指定存放 JavaScript 文件的 CDN 目录 URL publicPath: &#39;&#x2F;&#x2F;js.cdn.com&#x2F;id&#x2F;&#39;, &#125;, resolve: &#123; &#x2F;&#x2F; 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 &#x2F;&#x2F; 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, &#39;node_modules&#39;)], &#x2F;&#x2F; 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: [&#39;jsnext:main&#39;, &#39;main&#39;], &#125;, module: &#123; rules: [ &#123; &#x2F;&#x2F; 如果项目源码中只有 js 文件就不要写成 &#x2F;\\.jsx?$&#x2F;，提升正则表达式性能 test: &#x2F;\\.js$&#x2F;, use: [&#39;happypack&#x2F;loader?id&#x3D;babel&#39;], &#x2F;&#x2F; 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, &#39;src&#39;), &#125;, &#123; test: &#x2F;\\.js$&#x2F;, use: [&#39;happypack&#x2F;loader?id&#x3D;ui-component&#39;], include: path.resolve(__dirname, &#39;src&#39;), &#125;, &#123; &#x2F;&#x2F; 增加对 CSS 文件的支持 test: &#x2F;\\.css&#x2F;, &#x2F;&#x2F; 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: [&#39;happypack&#x2F;loader?id&#x3D;css&#39;], &#x2F;&#x2F; 指定存放 CSS 中导入的资源（例如图片）的 CDN 目录 URL publicPath: &#39;&#x2F;&#x2F;img.cdn.com&#x2F;id&#x2F;&#39; &#125;), &#125;, ] &#125;, plugins: [ autoWebPlugin, &#x2F;&#x2F; 4-14开启ScopeHoisting new ModuleConcatenationPlugin(), &#x2F;&#x2F; 4-3使用HappyPack new HappyPack(&#123; &#x2F;&#x2F; 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件 id: &#39;babel&#39;, &#x2F;&#x2F; babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: [&#39;babel-loader?cacheDirectory&#39;], &#125;), new HappyPack(&#123; &#x2F;&#x2F; UI 组件加载拆分 id: &#39;ui-component&#39;, loaders: [&#123; loader: &#39;ui-component-loader&#39;, options: &#123; lib: &#39;antd&#39;, style: &#39;style&#x2F;index.css&#39;, camel2: &#39;-&#39; &#125; &#125;], &#125;), new HappyPack(&#123; id: &#39;css&#39;, &#x2F;&#x2F; 如何处理 .css 文件，用法和 Loader 配置中一样 &#x2F;&#x2F; 通过 minimize 选项压缩 CSS 代码 loaders: [&#39;css-loader?minimize&#39;], &#125;), new ExtractTextPlugin(&#123; &#x2F;&#x2F; 给输出的 CSS 文件名称加上 hash 值 filename: &#96;[name]_[contenthash:8].css&#96;, &#125;), &#x2F;&#x2F; 4-11提取公共代码 new CommonsChunkPlugin(&#123; &#x2F;&#x2F; 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: [&#39;common&#39;, &#39;base&#39;], &#x2F;&#x2F; 把公共的部分放到 base 中 name: &#39;base&#39; &#125;), new DefinePlugin(&#123; &#x2F;&#x2F; 定义 NODE_ENV 环境变量为 production 去除 react 代码中的开发时才需要的部分 &#39;process.env&#39;: &#123; NODE_ENV: JSON.stringify(&#39;production&#39;) &#125; &#125;), &#x2F;&#x2F; 使用 ParallelUglifyPlugin 并行压缩输出的 JS 代码 new ParallelUglifyPlugin(&#123; &#x2F;&#x2F; 传递给 UglifyJS 的参数 uglifyJS: &#123; output: &#123; &#x2F;&#x2F; 最紧凑的输出 beautify: false, &#x2F;&#x2F; 删除所有的注释 comments: false, &#125;, compress: &#123; &#x2F;&#x2F; 在UglifyJs删除没有用到的代码时不输出警告 warnings: false, &#x2F;&#x2F; 删除所有的 &#96;console&#96; 语句，可以兼容ie浏览器 drop_console: true, &#x2F;&#x2F; 内嵌定义了但是只用到一次的变量 collapse_vars: true, &#x2F;&#x2F; 提取出出现多次但是没有定义成变量去引用的静态值 reduce_vars: true, &#125; &#125;, &#125;), ]&#125;; 五、优化总结 -webpack.config.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293const path &#x3D; require(&#39;path&#39;);const CommonsChunkPlugin &#x3D; require(&#39;webpack&#x2F;lib&#x2F;optimize&#x2F;CommonsChunkPlugin&#39;);const &#123;AutoWebPlugin&#125; &#x3D; require(&#39;web-webpack-plugin&#39;);const HappyPack &#x3D; require(&#39;happypack&#39;);&#x2F;&#x2F; 自动寻找 pages 目录下的所有目录，把每一个目录看成一个单页应用const autoWebPlugin &#x3D; new AutoWebPlugin(&#39;.&#x2F;src&#x2F;pages&#39;, &#123; &#x2F;&#x2F; HTML 模版文件所在的文件路径 template: &#39;.&#x2F;template.html&#39;, &#x2F;&#x2F; 提取出所有页面公共的代码 commonsChunk: &#123; &#x2F;&#x2F; 提取出公共代码 Chunk 的名称 name: &#39;common&#39;, &#125;,&#125;);module.exports &#x3D; &#123; &#x2F;&#x2F; AutoWebPlugin 会找为寻找到的所有单页应用，生成对应的入口配置， &#x2F;&#x2F; autoWebPlugin.entry 方法可以获取到生成入口配置 entry: autoWebPlugin.entry(&#123; &#x2F;&#x2F; 这里可以加入你额外需要的 Chunk 入口 base: &#39;.&#x2F;src&#x2F;base.js&#39;, &#125;), output: &#123; filename: &#39;[name].js&#39;, &#125;, resolve: &#123; &#x2F;&#x2F; 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤 &#x2F;&#x2F; 其中 __dirname 表示当前工作目录，也就是项目根目录 modules: [path.resolve(__dirname, &#39;node_modules&#39;)], &#x2F;&#x2F; 只采用 main 字段作为入口文件描述字段，以减少搜索步骤 mainFields: [&#39;jsnext:main&#39;, &#39;main&#39;], &#125;, module: &#123; rules: [ &#123; &#x2F;&#x2F; 如果项目源码中只有 js 文件就不要写成 &#x2F;\\.jsx?$&#x2F;，提升正则表达式性能 test: &#x2F;\\.js$&#x2F;, use: [&#39;happypack&#x2F;loader?id&#x3D;babel&#39;], &#x2F;&#x2F; 只对项目根目录下的 src 目录中的文件采用 babel-loader include: path.resolve(__dirname, &#39;src&#39;), &#125;, &#123; test: &#x2F;\\.js$&#x2F;, use: [&#39;happypack&#x2F;loader?id&#x3D;ui-component&#39;], include: path.resolve(__dirname, &#39;src&#39;), &#125;, &#123; &#x2F;&#x2F; 增加对 CSS 文件的支持 test: &#x2F;\\.css&#x2F;, &#x2F;&#x2F; 提取出 Chunk 中的 CSS 代码到单独的文件中 use: [&#39;happypack&#x2F;loader?id&#x3D;css&#39;], &#125;, ] &#125;, plugins: [ autoWebPlugin, &#x2F;&#x2F; 使用HappyPack new HappyPack(&#123; id: &#39;babel&#39;, &#x2F;&#x2F; babel-loader 支持缓存转换出的结果，通过 cacheDirectory 选项开启 loaders: [&#39;babel-loader?cacheDirectory&#39;], &#125;), new HappyPack(&#123; &#x2F;&#x2F; UI 组件加载拆分 id: &#39;ui-component&#39;, loaders: [&#123; loader: &#39;ui-component-loader&#39;, options: &#123; lib: &#39;antd&#39;, style: &#39;style&#x2F;index.css&#39;, camel2: &#39;-&#39; &#125; &#125;], &#125;), new HappyPack(&#123; id: &#39;css&#39;, &#x2F;&#x2F; 如何处理 .css 文件，用法和 Loader 配置中一样 loaders: [&#39;style-loader&#39;, &#39;css-loader&#39;], &#125;), &#x2F;&#x2F; 4-11提取公共代码 new CommonsChunkPlugin(&#123; &#x2F;&#x2F; 从 common 和 base 两个现成的 Chunk 中提取公共的部分 chunks: [&#39;common&#39;, &#39;base&#39;], &#x2F;&#x2F; 把公共的部分放到 base 中 name: &#39;base&#39; &#125;), ], watchOptions: &#123; &#x2F;&#x2F; 4-5使用自动刷新：不监听的 node_modules 目录下的文件 ignored: &#x2F;node_modules&#x2F;, &#125;&#125;;","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"Flutter - [未完]","slug":"book/2019/Flutter","date":"2019-06-17T12:42:04.000Z","updated":"2022-06-05T14:08:41.953Z","comments":true,"path":"2019/06/17/book/2019/Flutter/","link":"","permalink":"http://yoursite.com/2019/06/17/book/2019/Flutter/","excerpt":"","text":"Flutter 认识与入门里程碑节点 2014.10 前身sky开源 2015.10 正式更名Flutter 2017.5 Google I/O 正式向外公布Flutter 2018.2 第一个beta版本 2018.12.5 发布1.0 2019.2 发布1.2 支持WEB 2019.5.7 发布1.5 flutter for web 正式成为一个全平台框架 mobile web desktop embedded 嵌入式 Flutter和RN 多平台支持、web desktop embedded 工具链更多全 打包和调式方面 热更新 Flutter还不行 第三方库 Flutter比较少 F发展趋势更好 必备知识 Dart 面向对象、命令式编程概念、移动端开发经验 JAVA ANDROID的开发经验 学习资源 flutter中文网 掘金社区 https://juejin.im/post/5cd9875ae51d453d022cb662 stackoverflow:https://stackoverflow.com/questions/tagged/ Codelabs 云市区 https://cloud.tencent.com/developer/column Dart 官网 dartlang.org 中文网 dart.goodev.org 掘金专栏 Dart dart-china.org 好处 性能优越 开发快速 精美的UI everything is widget widgetStatefullWidget 有状态的StatelessWidget 无状态的","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"}]},{"title":"ReactNative精解与实战","slug":"book/2019/ReactNative精解与实战","date":"2019-06-15T01:00:00.000Z","updated":"2022-06-05T14:08:41.953Z","comments":true,"path":"2019/06/15/book/2019/ReactNative精解与实战/","link":"","permalink":"http://yoursite.com/2019/06/15/book/2019/ReactNative%E7%B2%BE%E8%A7%A3%E4%B8%8E%E5%AE%9E%E6%88%98/","excerpt":"","text":"简介 2015.3正式发布了rn框架 2015.9发布了支持android VirtualDOM、单向数据流 组件通信 父子组件 子父组件 多级组件之间：context global但不推荐 无直接关系组件：AsyncStorage 或 JSON 、EventEmitter/EventTarget/EventDispatcher、Publish/Subscribe广播形式 生命周期 componentWillMount 组件即将要开始加载 componentDidMount 组件已经加载完毕 componentWillReceiveProps 接收到props值更新 会执行 shouldComponentUpdate 用于判断props states变更需不需要UI变更 默认是需要 componentWillUpdate 如果上述返回true 此函数执行 componentDidUpdate 组件更新完毕后执行 componentWillUnmount 组件被卸载和注销前执行 Flex布局 12个属性 justifyContent alignItems alignSelf flexDirection flexBasis flexWrap alignContent flexGrow flexShrink order flexFlow flex 开发调式 软件模拟器 ios c+D android c+M chrome 中远程调试代码 react developer tools ReactNative组件 view TabBar react-navigation TabBarIOS(苹果) react-native-tab-navigator(安卓) Image Text (可以嵌套字符单独控制样式、若需要统一可以统一定义字体样式全局) TextInput 触摸类 TouchableHighlight 触摸类 TouchableNativeFeedback (安卓) 触摸类 TouchableOpacity 触摸类 TouchableWithoutFeedback WebView ScrollView react-native-elements 推荐的其它 API alert AppState 获取运行状态 AsyncStorage介绍 相册 cameraRoll (react-native-image-picker) 地理位置Geolocation 设备网络信息 NetInfo 网络请求所有APP与后台交互都是通过RESTful API进行请求和传输 框架提供fetch 也可以自行封装axios 常用热门组件 热门列表 Awesome React Native 接入微信微博QQ react-native-open-share 图标 react-native-pathjs-charts 功能全的列表 react-native-gifted-listview 图标集合 react-native-vector-icons 运行原理 React Native Packager 控制台 监听与打包，或手动启动npm start 原本属于框架内，2017年，独立出来https://git-hub.com/facebook/metro 初始化环境 1react-native init --verbose IOS平台资源文件加载入口为AppDelegate.m Android平台资源文件加载入口为MainApplication.java IOS Android平台部署与调试P220页 RN消息推送 极光推送jpush-react-native","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"reactnative","slug":"reactnative","permalink":"http://yoursite.com/tags/reactnative/"}]},{"title":"写给大家看的设计书","slug":"book/2019/写给大家看的设计书","date":"2019-06-07T12:42:04.000Z","updated":"2022-06-05T14:08:41.954Z","comments":true,"path":"2019/06/07/book/2019/写给大家看的设计书/","link":"","permalink":"http://yoursite.com/2019/06/07/book/2019/%E5%86%99%E7%BB%99%E5%A4%A7%E5%AE%B6%E7%9C%8B%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B9%A6/","excerpt":"","text":"一、设计原则1.亲密性 将相关的项组织在一起 物理位置越近意味着存在着关联 目的实现组织性 实现视线的移动，页面上的项3-5个 避免的问题 不要仅仅因为有空白 就把元素放在角落或中央 避免一个页面上有太多孤立的元素 不要在元素之间留出同样大小的空白 在有很近亲密性的元素之间建立关系 不同属一组的元素之间不要建立关系 2.对齐 任何元素都不能在页面上随意安放，每一项都应当与页面上的某个内容存在某种视觉联系 打破规则之前必须清楚规则是什么 统一性要让页面上所有元素看上去统一、有联系而且彼此相关，需要在各个单独的元素之间存在某种视觉纽带。 目的使页面统一而且有条理 实现要特别注意元素放在哪里。应当总能在页面上找出与之对齐的元素，尽管这两个对象的物理位置可能相距很远 避免的问题避免在页面上混合使用多种文本对齐方式避免居中对齐 除非创建正式稳重的表示，不要把其作为默认对齐就行。 3.重复 设计的某些方面需要在整个作品中重复 设计中视觉元素的重复可以将作品中的各部份连在一起，从而统一并增强整个作品，否则这些部份都是独立的单元。 目的目的就是统一，增强视觉效果 实现需要把现有的一致性更向前推进一步。 避免的问题避免太多地重复一个元素，太多会起反作用。 4.对比 对比是增强视觉效果的最有效的途径之一 千万不要畏畏缩缩 如果两个项不完全相同，就应当使之不同，而且应当是截然不同 目的增强页面的效果；有助于信息的组织。 实现通过字体选择、线宽、色彩、形状、大小、空间等来增强对比。对比一定要强烈。 避免的问题 不要犹豫 不要将一种粗线和另一种更粗的线对比 避免使用两种或多种类似的字体 干脆让它们截然不同 二、颜色运用 三原色、三间色、第三色、12种基本色形成色轮。 互补色、三色组、分裂互补三色组、类似色。 暗色亮色、暖色冷色。","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1/"}]},{"title":"你不知道的Javascript 上-[未完]","slug":"book/2019/你不知道的JS","date":"2019-05-09T12:42:04.000Z","updated":"2022-06-05T14:08:41.954Z","comments":true,"path":"2019/05/09/book/2019/你不知道的JS/","link":"","permalink":"http://yoursite.com/2019/05/09/book/2019/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS/","excerpt":"","text":"This关于this this 既不指向函数自身，也不指向函数的词法作用域，抛开以前错误的假设和理解 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用 4条规则判断this的绑定，就需要找到函数直接调用位置，有四条规则，优先级如下 new绑定 由new调用，绑定到新创建的对象 显式绑定 由call或者apply调用，绑定到指定的对象 隐式绑定 由上下文对象调用 绑定到那个上下文对象 默认绑定 在严格模式下绑定到undefined 否则绑定到全局对象 es6中不会使用这4条规则 根据当前词法作用域来决定this，箭头函数会继承外层函数调用的this绑定","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"你不知道的","slug":"你不知道的","permalink":"http://yoursite.com/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84/"}]},{"title":"HTTP抓包实战","slug":"book/2019/http抓包实战","date":"2019-04-15T01:00:00.000Z","updated":"2022-06-05T14:08:41.954Z","comments":true,"path":"2019/04/15/book/2019/http抓包实战/","link":"","permalink":"http://yoursite.com/2019/04/15/book/2019/http%E6%8A%93%E5%8C%85%E5%AE%9E%E6%88%98/","excerpt":"","text":"一、Http 协议请求方法和状态码get post方法到区别 get提交到数据会放在url之后，以问号分割url和传输数据。参数之间以&amp;相连，post方法是把提交的数据放在http包的body中 get提交的数据大小有限制url长度限制，而post方法提交数据没有大小限制 get方式需要使用request.querystring来取得变量的值，而post方法提交的数据大小没有限制 get方式提交数据会带来安全问题 200 服务器成功处理了请求204 no content 没有内容 在不获取资源的情况下了解资源的情况 通过查看http响应中状态码看某个对象是否存在 通过查看header测试资源是否被修改 206 partial content 部分内容 ftp 使用206状态码来实现断点续传的 将一个大文档分解为多个下载段同时下载，比如在线视频 流媒体 301 moved permanently 表示请求的网页已经永久性转移到另一个地址 防止用户输错域名 网站更换域名 有多个权重不错的域名，需要把所有的权重都传递到新域名，这就需要301重定向 302 found在未登陆状态下，直接访问需要登录才能访问的页面，会被服务器返回302，跳转到的登录页面。 301 302区别 语法上是一模一样，都是在location中返回新的url，区别在于： 301 表示旧地址的资源已经被永久地移除了，这个资源不可访问了，搜索引擎会把权重算到新地址 302 表示旧地址的资源还在，仍然可以访问，这个重定向只是临时地从旧地址跳转到新地址，搜索引擎会把权重算到旧地址 304 not modified表示上次到文档已经被缓存了，还可以继续使用。 400 bad request表示客户端请求有语法错误，发送到http请求中的数据有错误，不能被服务器所理解。 401 unauthorized是指未授权错误。有些网页采用的是http基本认证，需要在http请求中带上authorization header，否则服务器会返回状态码401 403 forbidden表示web客户端发送的请求被web服务器拒绝了 404 not found访问url，域名是正确的，但是资源不存在，服务器就会返回404，告诉浏览器资源不存在 500 internal server error表示服务器内部错误，出现错误的原因很多，比如代码的错误，数据库连接错误，陈旭内部抛出异常 空指针错误等 503 server unavailable表示服务器暂时不可用。由于服务器维护或者过载，服务器当前无法处理请求：这个状态是临时的，并且将在一段时间以后恢复 二、Http协议第4章 header介绍http请求和http响应中有很多header cache 请求和响应中都有用于缓存的header cookies 请求 cookie:header 响应 set-cookie:headers accept 表示浏览器客户端可以接受的媒体类型 accept-encoding 压缩有关 告诉服务器支持什么压缩 accept-language 声明自己接受的语言 user-agent 告诉服务器，客户端使用的操作系统及版本… 伪装客户端fiddle / rules -&gt; usera-gents referer 让服务器判断来源页面，可做防盗链，不是在范围内，否则就不显示 connerction 系统默认开启connection:keep-alive保持连接特性（不会永久保持连接） host 必须的，指定被请求的主机和端口号 第5章 web抓包和fiddler修改包网页如何打开 浏览器会发送第一个请求 去获取页面布局的html,叫做父请求，然后响应返回浏览器 浏览器分析http响应中的html，自动再次发送很多http请求去获取图片样式脚本等，这些http请求叫做子请求 fiddler 父请求右键select-&gt;child requests 选择所有子请求；子请求右键select-&gt;parent requests选择父请求；选择一个请求右键duplicate requests 就能选择相同请求了。 加载速度 子请求出现404 500之类等错误或子请求响应速度慢 通过statistics（详情和数据统计）面板查看响应时间 查看响应 RAW查看完整的http响应 响应的是http文档 用webview选项卡来查看 图片，用imageview选项卡来查看 json,用json tab选项卡来查看 设置断点来修改http请求 全局断点 rules - automatic breakpoint - before requests F11 // 取消 shift+F11 单个断点 Quickexec命令行输入命令 bqu www.xxx.com // bpu 设置断点来修改http响应 全局断点 rules - automatic breakpoint - after response // disabled 单个断点 quickexec命令行输入命令 bpafter www.xxx.com // bpafter run to completion 按钮放行 // break on response 按钮继续拦截 第6章 http协议中的缓存 cachehttp 具有缓存功能的是浏览器缓存和代理服务器缓存 判断缓存的新鲜度 浏览器把缓存文件的最后修改时间通过header ‘if-modified-since’告诉web服务器 浏览器吧缓存文件的etag通过header ‘if-none-match’告诉web服务器 浏览器通过if-modified-since发送个web服务器，web服务器收到后对比，如果没有改变，返回304，告诉客户端继续使用缓存。若已经改变，则返回200，web服务器将发送最新的文档给浏览器。 浏览器不使用缓存 header cache-control:no-cache // public 说明可以公有缓存 第7章 http协议压缩和URLENCODE压缩http压缩是指web服务器和浏览器之间压缩传输文本内容的方法。比如用gzip来压缩html js css文件,对图片压缩效果不好。fiddler中Decode按钮可以自动解压。http定义了一些标准的内容编码类型：content-encoding gzip(zip) compress(UNIX) deflate(zlib) identity URL Encode只能用英文字母数字或者某些标点符号，不能使用其他文字和符号。fiddler中对textwizard可以进行 encode deconde 第9章 前端快速调试 autoResponder 功能 调试文件保存到本地调试 伪造的http响应 调试js 图片 第10章 script用法可以自动修改http请求和http响应的脚本文件。 修改session 修改http请求 host header cookie 修改http请求中的body 修改http响应 读写txt 可以使用正则表达式 保存session 读取session 并且可以发送 第11 -12 章 深入Cookie http协议是无状态的，每一次请求，服务器都会独立处理。 会话机制，浏览器第一次请求，服务器创建一个会话，浏览器储存会话ID，并在第二三次请求中带上会话ID，服务器就知道是不是同一个用户了。 cookie机制是一种会话机制。 是浏览器用来存储少量数据的一种机制，数据以key=val形式存储，浏览器发送http请求时，自动附带cookie信息 cookie时一小段文本信息 主要用来做用户认证，还可以用于保存用户的一些其他信息。 cookie属性 expire属性：过期时间，过了此时间cookie就失效;若不指定此时间，关闭浏览器就会被删除 path属性：所属路径 HttpOnly属性：安全方面的属性，将cookie设置为httponly后，通过js脚本无法读取cookie信息，有效防止xss攻击。例如登录相关的cookie cookie类型 会话cookie 是一种临时cookie，记录了用户访问时的设置和偏好，关闭浏览器，就会被删除。 持久cookie存储在硬盘上，不管浏览器退出或电脑重启，都会存在，有过期时间。 cookie 保存的位置 根据浏览器不一样保存的地址也不一样cookie 和缓存的区别：完全不一样的东西，相同点都存在硬盘上和存在同一个文件夹下获取cookie冒充别人 cookie欺骗或者会话劫持 通过跨站脚本攻击xss获取他人的cookie 想办法获取别人电脑上保存的cookie文件 cookie是非常重要的，网站登录后都会有一个退出的登录，是告诉服务器立即删除服务器端端session对象，这样客户端登录的cookie就失效了 第13章 HTTP基本认证 两种认证方式：基本认证和摘要认证 基本认证：桌面程序不会使用COOKIE，而是把用户名冒号密码用BASE64编码放在HTTP请求中的Header Authorization中发送给服务器。 基本认证优点：简单明了。缺点：一定要用HTTPS稍微安全一点。BASE64编码是可逆编码，容易破解，相当于明文传输。除非关闭浏览器或清除历史记录，否则将无法登出。无法防止重放攻击(通过拦截获取帐密修改后重复多次重放给原始服务器，以获得访问权)。 摘要认证：是针对基本认证的一种改良方案。对用户名密码摘要算法，来解决明文传输的问题。通过服务器产生随机娄nonce防止重放的握手过程 cnonce支持客户端对服务器的认证。对内容也加入摘要计算的方式，可以有选择地防止 对报文内容的篡改。 第14章 手机抓包 作用：开发调试程序；做接口和安全测试；可以下载请求和响应。 设置“允许远程连接connections allow remote computers to connect”；手机设置代理IP；HTTPS需要手机安装证书。 第15章 发送HTTP请求composer 可以发送HTTP请求重放攻击 有一种安全测试叫做重放攻击 replay attacks 重播攻击 回放攻击 重复地向服务器发送请求的行为 解决方案：添加时间戳 stamp （保证时效）和数据签名sign(确保有效性是经过加密的或者KEY，第三方模拟不了) 第16章 实现弱网模式 网速慢和网络中断的情况称之为弱网 带来的问题：操作时间慢；用户体验不好；非正常情况下BUG会可能会存在。 目的：让程序在任何情况下都能表现自如。 场景：网络慢或延迟，导致加载时间长；网络中断，返回500；网络超时，请求发出后没有响应。 fiddler 模拟网络延迟 simulate modem speeds fiddler 模拟网络中断 返回 500 503 fiddler 模拟网络超时 拦截请求，设置断点等 三、自动化测试JMeter的使用 web 自动化测试：用自动化工具把自己伪装成一个浏览器，发送HTTP请求给WEB服务器 性能测试：通过工具模拟出很多虚拟用户，同时发送HTTP请求给WEB服务器","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"}]},{"title":"编写可维护的javascript","slug":"book/2019/编写可维护的javascript","date":"2019-04-05T12:42:04.000Z","updated":"2022-06-05T14:08:41.955Z","comments":true,"path":"2019/04/05/book/2019/编写可维护的javascript/","link":"","permalink":"http://yoursite.com/2019/04/05/book/2019/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84javascript/","excerpt":"","text":"第一章 基本的格式化1.1 缩进层级 使用制表符进行缩进，约等于4个字符 使用空格进行缩进，推荐使用4个空格为一个缩进，相当于一个TAB 1.2 语句结尾推荐不要省略分号，虽然分析器的自动分号插入机制（ASI，Automatic Semicolon Insertion）会正确插入分号，但插入规则非常复杂难以记住。 1.3 行的长度一行代码最长不应当超过80个字符。参考来源（JAVA单行不超过80个字符；安卓不超过100个字符；RUBY不超过80个字符；PYTHON不超过79字符） 1.4 换行当一行长度达到了80个字符，就需要手动将一行拆成两行。在运算符后换行，下一行增加两个层级的缩进。if语句的主题部分依然是一个缩进；变量赋值换行是，第二行的位置应当和赋值运算符的位置保持对齐。 1.5 空行 在方法之间 在方法中局部变量和第一条语句之间 在多行和单行注释之前 在方法内的逻辑片段之间插入空行，提高可读性 1.6 命名2000年流行匈牙利命名法，名字之前冠以类型标识符前缀，比如sName表示字符串。变量名应当以驼峰式大小写Camel case函数名前缀应当是动词 canXX hasXX isXX getXX setXX常量使用大写字母和下划线来命名 var MAX_COUNT=10构造函数 以大驼峰命名法 Pascal case 1.7 直接量字符串 可以用双引号 （JAVA只使用双引号 建议可以容易在上下文之间相互切换）数字 不推荐10. 或 .1 的形式 或 八进制已经废弃null null 用来初始化一个变量，这个变量可能赋值为一个对象。用来和一个已经初始化的变量进行比较，这个变量可以是也可以不是一个对象。当函数的参数期望是对象时，用作参数传入。当函数的返回值期望是对象时，用作返回值传出。 null 不应当使用：不要使用null来检侧是否传入了某个参数。不要使用null来检测一个为初始化的变量。 null 最好的方式将它当作对象的占位符placeholder undefined 代码中避免使用 对象直接量创建对象最流行的一种做法是使用对象直接量对象直接量允许你将所有的属性都括在以对花括号里 数组直接量不赞成显式的使用array构造函数来创建数组 var colors = new Array[…]可以使用两个方括号将数组初始元素括起来 var colors=[…] 第2章 注释2.1 单行注释 // 以两个斜线开始 独占一行的注释，用来解释下一行代码。这行注释之前总是有一个空行，且缩进层级和下一行代码保持一致 在代码行的尾部注释。注释加代码不应超过单行长度限制，否则就放到代码行上方 被注释掉的大段代码 不好的写法注释之前没有空行；错误的缩进；代码和注释之间没有间隔；不能用于多行注释。 2.2 多行注释 /* */ JAVA风格123&#x2F;* ***&#x2F; 不好的写法注释之前没有空行；型号后没有空格；错误的缩进；代码尾部注释不能使用多行注释的方法 2.3 使用注释 添加原则：在需要让代码变得更清晰时添加注释 难于理解的代码 需要根据代码用途添加注释 可能被误认为错误的代码 浏览器特性hack 文档注释：所有方法；所有构造函数；所有包含文档化方法的对象 第3章 语句和表达式所有块语句都应当使用花括号，不能省略。if for while do…while try…catch…finally 3.1 花括号的对齐方式将花括号放置在块语句中第一句代码的末尾。if (…) { //…} 3.2 块语句间隔在左圆括号之前和右圆括号之后个添加一个空格if () {} 3.3 switch语句 保持缩进 switch caseswitch (…) { case ‘’:} case可以连续执行 不需要break default 没有默认行为且写了注释来省略default 3.4 with语句避免使用with语句 3.5 for循环 不建议使用return throw 来结束循环 推荐使用break 不建议使用continue 建议需要时使用条件语句来判断。避免使用continue 3.6 for-in 循环 它不仅遍历实例属性，还遍历从原型继承来的属性 因此所有循环必须使用hasOwnProperty()123for (key in obj) &#123; if(obj.hasOwnProperty(key))&#123;&#125;&#125; 第4章 变量 函数 预算符4.1 变量声明 总是把局部变量的定义作为函数内第一条语句 在函数顶部使用单var语句 4.2 函数声明 函数声明也会被js提前 函数声明不应该在语句块内。if(xxx){function xxx(){}} 4.3 函数调用间隔函数名和左括号之间没有间隔 dosomething(); 4.4 立即调用的函数将函数用一堆圆括号包裹起来 123456var value &#x3D; (function() &#123; &#x2F;&#x2F;... return &#123; message:’hi’; &#125;&#125; 4.5严格模式use strict不推荐用在全局作用域中用在方法体内 4.6 相等由于强制类型转化的缘故，推荐不要使用== !=应当使用===和!== 不推荐使用eval()和Function 也禁止给 setTimeout() setInterval()传入字符串参数 禁止使用原始包装类型 来创建对象。new String new Number new Boolean 第5章5.1 什么是松耦合松耦合：做到修改一个组件而不需要更改其他的组件时。在一起工作的组件无法达到“无耦合”。我们的目标是确保对一个组件的修改不会经常性地影响其它部份。 5.2 将JS从CSS中抽离IE8及以前会存在CSS中使用expression引入JS，已经废弃。 5.3 将CSS从JS中抽离element.style.top = ‘’尽量不使用此种写法但可以添加删除元素className 5.4 将JS从HTML中抽离不好的写法button onclick=”fun()” 最好所有的JS代码都放入外置文件，以确保html有内联的js代码，是出于紧急调试的考虑。 5.5 将HTML从JS中抽离12var div &#x3D; document.getElementById(&#39;key&#39;)div.innerHTML &#x3D; &#39;&#39; 结构复杂不容易可读不好维护 正确的做法： 从服务器加载 XMLHttpRequest 整个HTML 简单客户端模板 复杂客户端模板 tmpl Handlebars 第6章 避免使用全局变量6.1 全局变量 命名冲突 代码脆弱性 （如果环境发生改变，函数就会失效） 难以测试（难以实施一些单元测试） 6.2 意外的全局变量 未被声明的变量赋值时，JS会自动创建一个全局变量 避免意外的全局变量 6.3 单全局变量方式所创建的这个唯一全局对象名是独一无二的（不会和内置API产生冲突）并将你所有功能代码都挂载到这个全局对象上。基于单全局变量的扩充方法 命名空间 使用模块 异步模块定义AMD YUI模块 6.4 零全局变量一般做不到 不创建全局变量 场景不多例如书签 第7章 事件处理7.1 典型用法例如事件对象event 对象包含所有和事件相关的信息暴露 1function key(event)&#123;&#125; 7.2 隔离应用逻辑7.3 不要分发事件对象1234567891011var myAPP &#x3D;&#123; handleClick:function(event)&#123; &#x2F;&#x2F; &#125;, showPopup:function(x,y)&#123; &#x2F;&#x2F; &#125;&#125;addListener(element,&quot;click&quot;,function(event)&#123; myAPP.handleClick(event);&#125; 第8章 避免空比较不应该使用 变量与null的比较 8.1 检测原始值正确和安全的做法 typeof name === ‘string’ typeof count === ‘number’ typeof found === ‘bollean’ typeof myapp === ‘underfined’ 一般不应用于检测语句 8.2 检测引用值杜绝使用typeof 来检测null的类型 检测函数 typeof myfun === ‘function’ 检测数组 Array.isArray() 8.3 检测属性不好的写法 检测假值 if(obj[key]) 和Null比较 if(obj[key]!= null) 和undefined比较 if(obj[key]!= undefined) 好的写法 检测假值 if(‘key’ in obj) 检测是否为Null if(‘val’ in obj)1234var obj &#x3D;&#123; key:0, val:null&#125; 第9章 将配置数据从代码中分享出来配置数据是应用中写死的HARDCODED的值 URL 需要展现给用户的字符吕 重复的值 设置 任何可能发生变更的值 抽离配置数据1234567var config &#x3D; &#123; MSG_URL:&#39;http:&#x2F;&#x2F;&#39;, CSS_SELECTED:&#39;selected&#39;&#125;function val()&#123; &#x2F;&#x2F;...&#125; 保存配置数据最好放在单独的文件中，以便清晰的分割数据和应用逻辑。 第10章在JS中抛出错误是一门艺术，错误是开发者的朋友，不是敌人。 1throw new Error(&#39;...&#39;); 经验法则 一旦修复一个很难调试的错误，尝试增加一两个自定义错误。当再次发生错误，就助于定位解决问题。 如果正在编写代码，思考一下：我希望某些事情不会发生 ，如果发生，那就抛出一个错误。 如果编写别人的代码 ，思考他们的使用方式，在特定的情况下抛出错误。 try-catch1234567try&#123; &#x2F;&#x2F;...&#125;catch(ex)&#123; &#x2F;&#x2F;... 当发生 一个错误程序会立即停止 &#125;finally&#123; &#x2F;&#x2F;... 如果有finally 都会被执行&#125; 7种错误类型ErrorEvalErrorReferenceErrorSyntaxErrorTypeErrorURIError 第11章 不是你的对象不要动原则应该把已存在的JS对象当作一个实用工具函数库来使用 不覆盖方法 不新增方法 不删除方法 更好的途径来使用 继承 基于对象的继承（Object.create）和基于类型的继承（name.prototype） 门面模式：为已存在的对象创建一个新接口（var newD = new DOMWrapper(‘#id’) ） 避免使用polyfills防止对对象的修改 防止扩展 禁止新增 已存在的是可以修改和删除 密封 对禁止的对象删除已经存在的属性和方法 冻结 对已禁止的对象为只读 第12章 浏览器嗅探使用顺序如下优先级 特性检测 if(document.all) //IE 用户代理检测User-Agent检测 特性推断 糟糕做法 浏览器推断 糟糕做法 第13章 文件和目录结构最佳实践 一个文件只包含一个对象 相关的文件用目录分类 保持第三方代码的独立 确定创建的位置 保持测试代码的完整性 基本结构 build 放置最终构建的文件 src 放置所有源文件 test放置测试文件 第17章 文件精简和压缩文件精简是指消除不必要的空格，去除注释，并对文件做一些处理使其体积尽可能的小。压缩是指使用特定的压缩方式进一步缩小文件的体积 文件精简 YUI Compressor Closure Complier UglifyJS 压缩 运行时压缩 构建时压缩 第18章 文档化 JSDoc Toolkit 可能是最常用到的JS文档生成工具 YUI DOC 后面出来运行在NODE上 第19章 自动化测试 YUI Test Selenium Yeti 运行在NODE上 PhantomJS JsTestDriver 第20章 组装到一起 开发 集成 打包 使用CI系统 Jenkins Continuum buildbot cruisecontrol gradle","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"编写可维护的JS","slug":"编写可维护的JS","permalink":"http://yoursite.com/tags/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JS/"}]},{"title":"Javascript高性能","slug":"book/2019/Javascript高性能","date":"2019-03-17T01:00:00.000Z","updated":"2022-06-05T14:08:41.953Z","comments":true,"path":"2019/03/17/book/2019/Javascript高性能/","link":"","permalink":"http://yoursite.com/2019/03/17/book/2019/Javascript%E9%AB%98%E6%80%A7%E8%83%BD/","excerpt":"","text":"一、加载和执行 脚本放到底部 内嵌脚本放到LINK后会先等样式表下载完后才执行，建议不要这样放置。 减少页面中的外链JS会改善性能 无阻塞脚本在于，在页面加载完成后才加载JS代码 defer属性 async defer都是采用并行下载，在下载过程中不会产生阻塞。区别在于执行时机，A是加载完成后自动执行 D是需要等页面完成后执行！ 任何带有defer属性的无论外链内联都是在DOM完成后才会被执行。不会阻塞浏览器的其他进程。 动态脚本加载成为最通用的无阻塞加载解决方案。 小结每次遇到页面都必须停下来等待代码下载并执行，然后再继续处理其它部份。有以下几种方法减少JS对性能的影响。 BODY标签闭合前，将所有标签放到页面的底部。这样能确保在脚本执行前页面已经完成了渲染。 合并脚本。页面中的标签越少，加载也就越快，响应也更迅速。无论外链文件还是内嵌脚本都是如此。 有多种无阻塞下载JS的方法 使用的defer属性 使用动态创建的元素来下载并执行代码 使用xhr对象下载JS代码并注入到页面中 二、数据存取数据存储位置关系到代码执行过程中数据的检索速度！ 字面量字面量只代表自身，不存储在特定位置。字符串，数字布，尔值，对象，数组，函数，正则,null underfined 本地变量使用VAR定义的数据存储单元 数组元素存储在JS数组对象内部，以数字作为索引 对象成员存储在JS对象 内部，以字符串作为索引 小结 访问字面量和局面变量的速度最快，相反相对较慢 由于局部变量存在于作用域链的起始位置，因此访问局面变量比访问跨域作用域变量更快，变量在作用域链中的位置越深，访问所需时间就越长，由于全局变量总处在作用域的最末端，因此访问速度最慢。 避免使用with语句，因为它会改变执行环境作用域链。同样 try-catch语句中的catch子句也有同样的影响 ，因此也要小心使用。 嵌套的对象成员会明显影响性能，尽量少使用。 属性或方法在原型链中的位置越深，访问它的速度也就越慢。 通常来说，你可以通过把常用的对象成员，数组元素，跨域变量保存在局部变量中来改善JS性能，因为局部变量访问最快。 三、DOM编程访问和操作DOM是现代WEB应用的重要组成部分，但每次穿越链接ES和DOM两个岛屿之间的桥梁，都需要被收取过路费，为了减少DOM编程带来的性能损失。 最小化DOM访问次数，尽可能在JS端处理 如果需要多次访问某个DOM节点，请使用局部变量存储它的引用 小心处理HTML集合。因为 它实时系着底层文档。把集合的长度缓存到一个变量中，并在迭代中使用它。如果需要经常操作集合，建议把它拷到一个数组中。 如果可能的话，使用速度更快的API，比如querySelectorAll() firstElementChild 要留意重绘和重排，批量修改样式时，离线操作DOM树，使用缓存，并减少访问布局信息的次数 动画中使用绝对定位，使用拖放代理 使用事件委托来减少事件处理器的数量 四、算法和流程控制JS和其它编程语言一样，代码的写法和算法会影响运行时间，与其它语言不同的是，JS可用资源有限，因此优化技术更为重要。 for while do-while特性差不多，没有明显区别谁快谁慢 避免使用for-in，险非你需要遍历一个属性数量未知的对象 改善循环性能的最佳方式是减少每次迭代的运算量和减少每次迭代的次数 通常来说，switch 总是比if-else快，但不是最佳解决方案 在判断条件比较多时，使用查找表比switch if-else要快 浏览器的调用栈大小限制了递归算法在JS中的应用，栈溢出错误会导致其它代码中断运行 如果你遇到栈溢出错误，可将方法改为迭代算法，或使用Memoization来避免重复运算 五、字符串和正则表达式密集的字符串操作和草率地编写正则表达 式可能产生严重的性能障碍。 当连接数量巨大 或尺寸巨大的字符串时，数组项合并是唯一在IE7及更早版本中性能合理的方法 如果不需考虑IE7以前，数组项合并是最慢的字符串连接方法之一。推荐使用简单的+ +=操作符替代，避免不必要的中间字符串 回溯即是正则表达式匹配功能的基本组成部份，也是正则表达式的低效之源 回溯失控发生在正则表达式本应快速匹配的地方，但因为某些特殊 的字符串匹配动作导致运行缓慢 甚至浏览器崩溃。避免这个问题的办法是：使相邻的字元互斥，避免嵌套量词对同一字符串的相同 部份多次匹配，通过重复利用预查的原子组去除不必要的回溯 提高正则表达式效率的各种技术手段会有助于正则表达式更快地匹配，并在非匹配位置 上花更少的时间 正则表达式并不总是完成工作的最佳工具，尤其当你只搜索字面字符串的时候 尽管有许多方法可以去除字符串的首尾空白，但使用两个简单的正则表达式，一个用来去除头部空白，一个用来去除尾部空白，来处理大量字符串内容能提供一个简洁而跨浏览器的方法。从字符串末尾开始循环向前搜索第一个非空白字符，或者将此技术同正则表达式结合起来，会提供一个更好的替代方案，它很少受到字符串长度的影响 六、快速响应的用户界面JS和用户界面更新在同一个进程中运行，因此一次只能处理一件事情。这意味着当JS代码正在运行时，用户界面不能影响输入，反之亦然。高效地管理 UI线程就是要确保JS不能运行太长时间 ，以免影响用户体验。 任何JS任务都不应当执行超过100毫秒。过长的运行时间会导致UI更新出现明显延迟，从而对用户体验产生负面影响 JS运行期间，浏览器响应用户交互的行为存在差异。无论如何，JS长时间运行将导致用户体验变得混乱和脱节 定时器可用来安排代码延迟执行，它使得你可以把长时间运行脚本分解成一系列的小任务 WEB WORKERS是新版浏览器支持的特性，它允许你在UI线程外部执行JS代码 ，从而避免锁定UI。WEB应用越复杂、积极主动地管理 UI线程就越重要，即使JS代码再重要，也不应该影响用户体验。 七、AJAX 高性能的Ajax包括，了解你项目的具体要求，选择正确的数据格式和与之匹配的传输技术。 作为数据格式，纯文本和HTML只适用于特定场合，但它可以节省客户端的CPU周期。XML被广泛应用而且支持良好，但是它十分笨重且解析缓慢。JSON是轻量级的，解析速度快，能用性与XML相当。字符分隔的自定义格式十分轻量，在解析大量数据集时非常快，但需要编写额外的服务端构造程度，并在客户端解析。 当从页面当前所处的域下请求数据时，XHR提供了最完善的控制和灵活性，尽管它会把接收到的所有数据当成一个字符串，且这有可能降低解析速度。另一方面动态脚本注入允许跨域请求和本地执行JS和JSON但是它的接口不那么安全，而且还不能读取头信息或响应代码。Multipart XHR可以用来减少请求数，并处理一个响应中的各种文件类型，但是它不能缓存接收到的响应。 beacons当需要发送数据时，图片信标是一种简单页有效的方法。XHR还可以用POST方法发送大量数据。 减少请求数，可通过合并JS和CSS文件，或使用MXHR 缩短页面的加载时间，页面主要内容加载完成后，用Ajax获取那些次要的文件 确保你的代码错误不会输出给用户，并在服务端处理错误 知道何时使用成熟的AJAX类库，以及何时编写自己的底层AJAX代码 八、编程实践JS提出了一些独一无二的性能挑战，这与你组织代码的方式有关。随着WEB应用变得越来越高级，包含的JS代码也越来越多，各种模式和反模式也逐渐出现。为了编写更高效的代码，请记以下编程实践。 通过避免使用eval() function()构造器来避免双重求值带来的性能消耗，同样的，给setTimeout() setInterval()传递函数而不是字符串为作参数。 尽量使用直接量创建对象和数组。直接量的创建和初始化都比非直接量形式要快 避免做重复的工作。当需要检测浏览器时，可使用延迟加载或条件预加载 在进行数学计算时，考虑使用直接操作数字的二进制开式的位运算 JS的原生方法总会比你写的任何代码都要快。尽量使用原生方法 九、构建并部署高性能JS应用构建和部署的过程对基于JS的WEB应用性能有着巨大的影响。 合并JS文件以减少HTTP请求数 使用YUI COMPRESSOR压缩JS文件 在服务端压缩JS文件 GZIP编码 通过正确设置HTTP响应头来缓存JS文件，通过向文件名增加时间戳来避免缓存问题 使用CDN提供JS文件 不仅可以提升性能，它也为你管理文件的压缩和缓存 使用构建自动化工具 合并多个JS文件 预处理JS文件 JS压缩 构建时处理对比运行时处理 JS的HTTP压缩 缓存JS文件 使用内容分发网络CDN 部署JS资源 敏捷JS构建过程 十、工具当网页或WEB变慢时，分析从网络下载的资源以及分析脚本运行性能，专注优化以下地方： 使用网络分析工具找出加载脚本和页面中其它资源的瓶颈，这会帮助你决定哪些脚本需要延迟加载，或者需要进一步分析。 尽管传统的经验告诉我们要尽量减少HTTP请求数，但把脚本尽可能延迟加载可以加快页面渲染速度，给用户带来更好的体验 使用性能分析工具找出脚本 运行过程中速度慢的地方，检查每个函数所消耗的时间，以及函数被 调用的次数，通过调用栈自身提供的一些线索来找出需要集中精力优化的地方 尽管耗费的时间和调用次数通常是数据中最有价值的部分，但仔细观察函数的调用过程，也许会发现其他优化目标 YUI Profiler - JS性能分析工具Fiddler - http调式代理工具","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]},{"title":"CSS世界-[未完]","slug":"book/2019/CSS世界","date":"2019-01-14T12:42:04.000Z","updated":"2022-06-05T14:08:41.953Z","comments":true,"path":"2019/01/14/book/2019/CSS世界/","link":"","permalink":"http://yoursite.com/2019/01/14/book/2019/CSS%E4%B8%96%E7%95%8C/","excerpt":"","text":"盒尺寸四大家族盒尺寸有四大盒子 content box padding box margin box border box content 替换元素 img object video iframe textarea input select button 内容的外观不受页面上css的影响 有自己的尺寸 在很多css属性上有自己的一套表现规则 所有都是内联水平元素display:inline inline-block 在不同的浏览器上表现不一样 由内而外：固有尺寸（替换内容原本的尺寸）html尺寸（原生属性 img的width height/input的size/textarea的cols rows）css尺寸（通过css的width height max-width min-width max-height min-height设置尺寸，对应盒尺寸的content box） css尺寸 &gt; html尺寸 &gt; 固有尺寸 content生成的都是替换元素 12345678&#x2F;&#x2F; 通过img占位进行滚屏异步加载&#x2F;&#x2F; 这里img直接没有src属性 图片不会有任何请求 是最高校的实现方式&lt;img&gt;img&#123;visibility:hidden&#125;img[src]&#123;visibility:visible&#125;&#x2F;&#x2F; 建议在css重置时进行 因为浏览器firfox下html样式不起作用img&#123;display:inline-block;&#125;","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"CSS世界","slug":"CSS世界","permalink":"http://yoursite.com/tags/CSS%E4%B8%96%E7%95%8C/"},{"name":"张鑫旭","slug":"张鑫旭","permalink":"http://yoursite.com/tags/%E5%BC%A0%E9%91%AB%E6%97%AD/"}]},{"title":"ReactNative基础","slug":"frame/react/ReactNative基础","date":"2018-12-28T01:00:00.000Z","updated":"2022-06-05T14:08:41.963Z","comments":true,"path":"2018/12/28/frame/react/ReactNative基础/","link":"","permalink":"http://yoursite.com/2018/12/28/frame/react/ReactNative%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一、基础Props 属性 用于定制组件的参数称为属性props style source就是属性 ios 上使用http连接图片不会显示 123456789101112131415161718192021222324252627282930313233export default class Bananas extends Component &#123; render() &#123; let pic = &#123; uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;Image source=&#123;pic&#125; style=&#123;&#123;width: 193, height: 110&#125;&#125; /&gt; // &#123;pic&#125; &#123;&#125;内部为一个变量或一个表达式 执行后取值 ); &#125;&#125;// 自定义的组件也可以使用props 只需在render函数中引用this.propsclass Greeting extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125; State 状态 两种数据来控制一个组件：props和state props是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变 对于需要改变的数据，我们需要使用state 123456789101112class Blink extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isShowingText: true &#125;; // 每1000毫秒对showText状态做一次取反操作 setInterval(() =&gt; &#123; this.setState(previousState =&gt; &#123; return &#123; isShowingText: !previousState.isShowingText &#125;; &#125;); &#125;, 1000); &#125; 一切界面变化都是状态state变化 state的修改必须通过setState()方法 this.state.likes = 100; // 这样的直接赋值修改无效！ setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性 setState 是异步操作，修改不会马上生效 样式 核心组件都接受名为style的属性,JS 的语法要求使用了驼峰命名法 StyleSheet.create来集中定义组件的样式 1234567891011121314151617181920212223export default class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigblue&#125;&gt;just bigblue&lt;/Text&gt; &lt;Text style=&#123;[styles.bigblue, styles.red]&#125;&gt;bigblue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigblue]&#125;&gt;red, then bigblue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; bigblue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;); 高度与宽度指定宽高RN 中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点 1234567891011export default class FixedDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 弹性（Flex）宽高 flex:1来指定某个组件扩张以撑满所有剩余的空间 有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间 这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大 1234567891011121314export default class FlexDimensionsBasics extends Component &#123; render() &#123; return ( // 试试去掉父View中的`flex: 1`。 // 则父View不再具有尺寸，因此子组件也无法再撑开。 // 然后再用`height: 300`来代替父View的`flex: 1`试试看？ &lt;View style=&#123;&#123;flex: 1&#125;&#125;&gt; &lt;View style=&#123;&#123;flex: 1, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 2, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;flex: 3, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 使用Flexbox布局 使用 flexDirection alignItems justifyContent 三个样式属性就已经能满足大多数布局需求 flexDirection 布局的主轴12style=&#123;&#123;flexDirection: 'row' &#125;&#125; 水平轴style=&#123;&#123;flexDirection: 'column' &#125;&#125; 竖直轴 默认 12345&lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt;&lt;/View&gt; justifyContent 排列方式flex-start、center、flex-end、space-around、space-between以及space-evenly 123456789&lt;View style&#x3D;&#123;&#123; flex: 1, flexDirection: &#39;row&#39;, justifyContent: &#39;center&#39;, &#125;&#125;&gt; &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;powderblue&#39;&#125;&#125; &#x2F;&gt; &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;skyblue&#39;&#125;&#125; &#x2F;&gt; &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;steelblue&#39;&#125;&#125; &#x2F;&gt; &lt;&#x2F;View&gt; alignItems 决定其子元素沿着次轴的排列方式flex-start、center、flex-end以及stretch 12345678910&lt;View style&#x3D;&#123;&#123; flex: 1, flexDirection: &#39;column&#39;, justifyContent: &#39;center&#39;, alignItems: &#39;stretch&#39;, &#125;&#125;&gt; &lt;View style&#x3D;&#123;&#123;width: 50, height: 50, backgroundColor: &#39;powderblue&#39;&#125;&#125; &#x2F;&gt; &lt;View style&#x3D;&#123;&#123;height: 50, backgroundColor: &#39;skyblue&#39;&#125;&#125; &#x2F;&gt; &lt;View style&#x3D;&#123;&#123;height: 100, backgroundColor: &#39;steelblue&#39;&#125;&#125; &#x2F;&gt; &lt;&#x2F;View&gt; 处理文本输入 TextInput onChangeText 函数会在文本变化时被调用 onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用 12345678910&lt;View style&#x3D;&#123;&#123;padding: 10&#125;&#125;&gt;&lt;TextInput style&#x3D;&#123;&#123;height: 40&#125;&#125; placeholder&#x3D;&quot;Type here to translate!&quot; onChangeText&#x3D;&#123;(text) &#x3D;&gt; this.setState(&#123;text&#125;)&#125;&#x2F;&gt;&lt;Text style&#x3D;&#123;&#123;padding: 10, fontSize: 42&#125;&#125;&gt; &#123;this.state.text.split(&#39; &#39;).map((word) &#x3D;&gt; word &amp;&amp; &#39;🍕&#39;).join(&#39; &#39;)&#125;&lt;&#x2F;Text&gt;&lt;&#x2F;View&gt; 处理触摸事件显示一个简单的按钮Button是一个简单的跨平台的按钮组件 123456&lt;Button onPress&#x3D;&#123;() &#x3D;&gt; &#123; Alert.alert(&quot;你点击了按钮！&quot;); &#125;&#125; title&#x3D;&quot;点我！&quot;&#x2F;&gt; Touchable 系列组件 一般来说，你可以使用TouchableHighlight来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。 在 Android 上还可以使用TouchableNativeFeedback，它会在用户手指按下时形成类似墨水涟漪的视觉效果。 TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。 如果你想在处理点击事件的同时不显示任何视觉反馈，则需要使用TouchableWithoutFeedback。 https://v.youku.com/v_show/id_XMTQ5OTE3MjkzNg==.html?f=26822355&amp;from=y1.7-1.3 使用滚动视图 ScrollView ScrollView是一个通用的可滚动的容器 通过horizontal属性来设置 适合用来显示数量不多的滚动元素123456789export default class IScrolledDownAndWhatHappenedNextShockedMe extends Component &#123; render() &#123; return ( &lt;ScrollView&gt; //... &lt;/ScrollView&gt; ); &#125;&#125; 使用长列表 ScrollView 适用于展示长列表数据的组件 和ScrollView不同的是，FlatList并不立即渲染所有元素，而是优先渲染屏幕上可见的元素 必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。 123456789101112131415161718192021export default class FlatListBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123;[ &#123;key: 'Devin'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Julie'&#125;, ]&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item.key&#125;&lt;/Text&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择 1234567891011121314151617export default class SectionListBasics extends Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;SectionList sections=&#123;[ &#123;title: 'D', data: ['Devin']&#125;, &#123;title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']&#125;, ]&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item&#125;&lt;/Text&gt;&#125; renderSectionHeader=&#123;(&#123;section&#125;) =&gt; &lt;Text style=&#123;styles.sectionHeader&#125;&gt;&#123;section.title&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 网络使用Fetch123456789101112131415161718192021222324252627282930313233343536fetch(\"https://mywebsite.com/endpoint/\", &#123; method: \"POST\", headers: &#123; Accept: \"application/json\", \"Content-Type\": \"application/json\" &#125;, body: JSON.stringify(&#123; firstParam: \"yourValue\", secondParam: \"yourOtherValue\" &#125;)&#125;);export default class FetchExample extends React.Component &#123; constructor(props)&#123; super(props); this.state =&#123; isLoading: true&#125; &#125; componentDidMount()&#123; return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; this.setState(&#123; isLoading: false, dataSource: responseJson.movies, &#125;, function()&#123; &#125;); &#125;) .catch((error) =&gt;&#123; console.error(error); &#125;); &#125; WebSocket 支持123456789101112131415161718192021var ws = new WebSocket(\"ws://host.com/path\");ws.onopen = () =&gt; &#123; // connection opened ws.send(\"something\"); // send a message&#125;;ws.onmessage = e =&gt; &#123; // a message was received console.log(e.data);&#125;;ws.onerror = e =&gt; &#123; // an error occurred console.log(e.message);&#125;;ws.onclose = e =&gt; &#123; // connection closed console.log(e.code, e.reason);&#125;; 二、进阶组件和API基础组件View Text Image TextInput ScrollView StyleSheet 交互控件Button Picker Slider Switch 列表视图FlatList 高性能滚动列表SectionList 比前者多了分组 Platform 模块React Native 提供了一个检测当前运行平台的模块。 123456789101112131415161718192021222324252627import &#123; Platform, StyleSheet &#125; from \"react-native\";// 样式const styles = StyleSheet.create(&#123; height: Platform.OS === \"ios\" ? 200 : 100&#125;);const styles = StyleSheet.create(&#123; container: &#123; flex: 1, ...Platform.select(&#123; ios: &#123; backgroundColor: \"red\" &#125;, android: &#123; backgroundColor: \"blue\" &#125; &#125;) &#125;&#125;);// 组件const Component = Platform.select(&#123; ios: () =&gt; require(\"ComponentIOS\"), android: () =&gt; require(\"ComponentAndroid\")&#125;)();&lt;Component /&gt;; 使用导航器跳转页面 只针对 iOS 平台开发 可以选择NavigatorIOS 同时在iOS和Android上达到看起来像原生 原生导航: react-native-navigation 图片静态图片资源 require 中的图片名字必须是一个静态字符串 123&lt;Image source=&#123;require('./my-icon.png')&#125; /&gt;// Packager 就会去这个组件所在的文件夹下查找 my-icon.png。并且，如果你有my-icon.ios.png和my-icon.android.png，Packager 就会根据平台而选择不同的文件。// 还可以使用@2x，@3x这样的文件名后缀，来为不同的屏幕精度提供图片。 静态的非图片资源require语法也可以用来静态地加载你项目中的声音、视频或者文档文件。大多数常见文件类型都支持，包括.mp3, .wav, .mp4, .mov, .htm 和 .pdf等 使用混合 App 的图片资源 编写一个混合 App，原生+RN ，放置在 Xcode 的 asset 类目中，或是放置在 Android 的 drawable 目录里。 注意此时只使用文件名，不带路径也不带后缀 1234// IOS&lt;Image source=&#123;&#123;uri: 'app_icon'&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt;// Android&lt;Image source=&#123;&#123;uri: 'asset:/app_icon.png'&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt; 网络图片需要手动指定图片的尺寸 123456// 正确&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/logo-og.png'&#125;&#125; style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt;// 错误&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/logo-og.png'&#125;&#125; /&gt; 动画React Native 提供了两个互补的动画系统：用于创建精细的交互控制的动画Animated和用于全局的布局动画LayoutAnimation","categories":[],"tags":[{"name":"reactnative","slug":"reactnative","permalink":"http://yoursite.com/tags/reactnative/"}]},{"title":"深入理解ES6","slug":"book/2018/深入理解ES6","date":"2018-12-12T12:42:04.000Z","updated":"2022-06-05T14:08:41.952Z","comments":true,"path":"2018/12/12/book/2018/深入理解ES6/","link":"","permalink":"http://yoursite.com/2018/12/12/book/2018/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/","excerpt":"","text":"一、块级作用域绑定var 声明及变量提升级hoisting机制1、var 是在函数作用域和全局作用域中声明，无论在哪里声明，都会提升。2、块级声明 let声明变量 不会被提升，放在封闭的代码块顶部 如果是var let声明存在内嵌的作用域中，不会报错 禁止重声明：会抛出错误 const声明常量 其值被设定后不可更改 若为对象不允许修改绑定，允许修改值 必须初始化赋值，否则报错 let const都是块级标识符 作用域相同 并且与var同块内声明 都会报错 临时死区temporal dead zone TDZ 当前作用域，在声明前访问由let定义的变量就会报错，导致let语句放入TDZ中 TDZ只是块级绑定的特色之一，循环中使用块级绑定也是一个特色 1234 if(condition)&#123; console.log(typeof value) &#x2F;&#x2F;引用错误 let value &#x3D; &#39;123&#39;&#125; 三、循环中的块作用域绑定1. for循环中，var声明的，在循环外，仍然可以访问 2. for循环中，let声明的，在循环外，报错，只能在循环内访问 循环中的函数 为了避免循环外不能访问函数，JS原使用了“调用函数表达式IIFE”，以强制生成xx变量的副本 但如果用let const提供的块级绑定，就不需要这样折腾了 循环中的let声明:可以彻底抛弃IIFE了123456789var funcs &#x3D; []for(let i&#x3D;0;i&lt;10;i++)&#123; funcs.push(()&#x3D;&gt;&#123; console.log(i) &#125;)&#125;forcs.forEach(()&#x3D;&gt;&#123; func() &#x2F;&#x2F;输出 0，1，2，3，4...9&#125;) 循环中的const声明 一般来说，没有明确说明不允许使用const声明循环，for i++不适用 for-in for-of则可以使用，因为迭代不会修改已有绑定，而是重新创建一个绑定12345for(const key in obj)&#123; funcs.push(()&#x3D;&gt;&#123; console.log(key) &#125;)&#125; 四、全局块作用域绑定 var作为全局时，会创建一个新的全局变量作为window全局对象 会被覆盖变量 let const 会创建一个新的绑定 但不会添加为全局对象 不会覆盖全局变量 五、块级绑定最佳实践的进化 日益普及的作法：默认使用const，只有确实需要改变变量的值时使用let 因为大多数的变量的值在初始化后不可改变，预料外的变量值的改变是很多bug的源头 二、三、函数函数形参的默认值ES6的默认参数值12345function makeRequest(url,time&#x3D;2000,callback&#x3D;function()&#123;&#125;)&#123; &#x2F;&#x2F; url 是必传参数 &#x2F;&#x2F; 其它不传或传undefined 则会默认传参 &#x2F;&#x2F; null是一个合法值&#125; 默认参数值对 arguments 对象的影响12345678910111213141516function mixArgs(first,second&#x3D;&quot;b&quot;)&#123; console.log(arguments.length) console.log(first &#x3D;&#x3D;&#x3D; arguments[0]) console.log(second &#x3D;&#x3D;&#x3D; arguments[1]) first &#x3D; &#39;c&#39; second &#x3D; &#39;d&#39; console.log(first &#x3D;&#x3D;&#x3D; arguments[0]) console.log(second &#x3D;&#x3D;&#x3D; arguments[1])&#125;mixArgs(&#39;a&#39;)&#x2F;&#x2F; 1&#x2F;&#x2F; true&#x2F;&#x2F; false undefined&#x2F;&#x2F; false&#x2F;&#x2F; false&#x2F;&#x2F; arguments 不会受影响 可以以此将参数恢复为初始值 默认参数表达式 假如 getValue没有写() 则传入的是函数的引用，不是函数调用的结果 建议先定义参数 后定义默认值12345678function getValue()&#123; return 5&#125;function add(first,second&#x3D;getValue())&#123; return first + second&#125;add(1,1) &#x2F;&#x2F;2add(1) &#x2F;&#x2F;6 默认参数临时死区TZD 与let声明类似，定义参数时会为每个参数创建一个新的标识符绑定，在初始化前不可被引用，如果试图访问就会抛出异常 函数参数有自已的作用域和临时死区，其与函数体的作用域是各自独立的，也就是说参数的默认值不可访问函数体内声明的变量12345function add(first &#x3D; second,second)&#123; return first + second&#125;add(1,1) &#x2F;&#x2F;2add(1) &#x2F;&#x2F; error 处理无命名参数不定参数 (…) 每个函数只能定义一个不定参数 一定要放在所有参数的末尾 不能用于对象字面量setter之中 arguments对象包含所有传入参数 无论是否使用不定参数1234567function pick(obj,...keys)&#123; let r &#x3D; obj.create(null) for (let i&#x3D;;i&lt;keys.length;i++)&#123; r[keys[i]] &#x3D; obj[keys[i]] &#125; return r&#125; 增强function构造函数1234567var add &#x3D; new Function(&#39;first&#39;,&#39;first &#x3D; second&#39;,&#39;return first + second&#39;)add(1) &#x2F;&#x2F;2add(1,1) &#x2F;&#x2F;2&#x2F;&#x2F; 定义不定参数 只需在最后一个参数加...var add &#x3D; new Function(&#39;...arg&#39;,&#39;return arg[0]&#39;)add(1,2) &#x2F;&#x2F; 1 展开运算符 指定一个数组，将他们打散后作为各自独立的参数传入函数 12345678910&#x2F;&#x2F;old let v1 &#x3D; 25,v2 &#x3D; 30;Math.max(v1,v2) &#x2F;&#x2F;v2let val &#x3D;[10,20,30,100]Math.max.apply(Math,val) &#x2F;&#x2F;100&#x2F;&#x2F;es6Math.max(...val) &#x2F;&#x2F;100Math.max(...val,1000) &#x2F;&#x2F;1000 设定最小返回值是1000 name属性1234567891011121314var dosomething &#x3D; function dosomethingelse()&#123; &#125;var person &#x3D; &#123; get firstname()&#123; &#125;, sayname:function()&#123; &#125;&#125;dosomething.name &#x2F;&#x2F;dosometingelesperson.sayname.name &#x2F;&#x2F;saynameperson.firstname.name &#x2F;&#x2F; get firstname 明确函数多重用途new.target元属性new.target在函数外使用是一个错误 块级函数在定义函数的代码块内，块级函数会被提升至顶部在非严格模式下，函数会被提升至顶部及外部 12345678&#39;use strict&#39;if(key)&#123; typeof something &#x2F;&#x2F; function function something()&#123; &#125;&#125;typeof something &#x2F;&#x2F; undefined 块级使用场景let定义不会被提升至顶部 1234567&#39;use strict&#39;if(key)&#123; typeof something &#x2F;&#x2F; error let something &#x3D; function()&#123; &#125;&#125; 箭头函数 没有this arguments super new.target绑定 不能通过new关键字调用 没有原型 不存在prototype 不可以改变this的绑定 不支持arguments对象 不支持重复的命名参数 箭头函数也有一个name属性 箭头函数的语法12345678910let r &#x3D; function(val)&#123; return val&#125;let r &#x3D; val &#x3D;&gt; val &#x2F;&#x2F;如果参数只有一个，直接写，后面紧跟箭头let r &#x3D; (n1,n2) &#x3D;&gt; n1+n2 &#x2F;如果有多个，则需要括号let r &#x3D; () &#x3D;&gt; &#39;nick&#39; &#x2F;&#x2F;如果没有参数，直接括号，后面紧跟箭头let r &#x3D; (n1,n2) &#x3D;&gt; &#123; return n1+n2 &#x2F;&#x2F;如果需要完整的函数体，需要加中括号&#125;let r &#x3D; id &#x3D;&gt; (&#123;id:id,name:&#39;temp&#39;&#125;) &#x2F;&#x2F;如果返回对象字面量，则需要包裹在小括号里 创建立即执行的函数表达式 定义一个匿名函数立即执行 箭头函数不包括NIC 与正常函数有所不同12345678let person &#x3D; ((name) &#x3D;&gt; &#123; return&#123; getName:function()&#123; return name &#125; &#125;&#125;)(&#39;nick&#39;)person.getName() &#x2F;&#x2F; &#39;nick&#39; 箭头函数没有this绑定箭头函数与数组 sort() map() reduce()1var r &#x3D; val.sort((a,b) &#x3D;&gt; a-b) 箭头函数没有arguments绑定 箭头函数没有自己的arguments对象 但始终可以访问外围函数的arguments对象 箭头函数的识别方法 typeof instanceof123let r &#x3D; val &#x3D;&gt; valtypeof r &#x2F;&#x2F; functionr instanceof Function &#x2F;&#x2F;true 尾调用优化重点看下RUYIFENG章节 四、扩展对象的功能性对象类别 普通ordinary对象 特异exotic对象 标准standard对象 内建对象 对象字面量的语法扩展属性初始值的简写123456function createPerson(name,age)&#123; return&#123; name, &#x2F;&#x2F;等同于name:name age &#125;&#125; 对象方法的简写语法123456var person &#x3D; &#123; name:&#39;nick&#39;, sayName()&#123; &#x2F;&#x2F;等同于sayNmae:function() console.log(this.name) &#125;&#125; 可计算属性名1234567let lastName &#x3D; &quot;last name&quot;let person &#x3D; &#123; &quot;first name&quot;:&quot;nick&quot;, [lastName]:&quot;zakas&quot;&#125;person[&quot;first name&quot;] &#x2F;&#x2F;nickperson[lastName] &#x2F;&#x2F;zakas 新增方法Object.is() 全等===情况下 +0，-0 NaN对比下JS缺失 从而引入 Object.is(+-,-0) //false Object.assign()12345678910const object1 &#x3D; &#123; a: 1, b: 2, c: 3&#125;;const object2 &#x3D; Object.assign(&#123;c: 4, d: 5&#125;, object1);console.log(object2.c, object2.d);&#x2F;&#x2F; expected output: 3 5 重复的对象字面量属性1234567var person &#x3D; &#123; name:&#39;nick&#39;, name:&#39;key&#39;&#125;person.name &#x2F;&#x2F; key&#x2F;&#x2F; es5严格模式下报错&#x2F;&#x2F; es6 下不会报错 自有属性枚举顺序 Object.getOwnPropertyNames Reflect.ownKeys12345var obj &#x3D; &#123; a:1,0:1,c:1,2:1,b:1,1:1&#125;obj.d &#x3D; 1Object.getOwnPropertyNames(obj).join(&quot;&quot;) &#x2F;&#x2F;012abcd 增强对象原型 改变对象原型 Object.setProtorypeOf() 简化原型访问的Supper引用 正式的方法定义 ES6 中正式定义 getGreeting方法的[[HomeObject]]属性值为person1234567891011121314151617let person &#x3D;&#123; &#x2F;&#x2F;是方法 getGreeting()&#123; return &quot;hello&quot; &#125;&#125;&#x2F;&#x2F; 不是方法function shareGreeting()&#123; return &quot;hi&quot;&#125;let friend &#x3D; &#123; getGreeting()&#123; return super.getGreeting() + &quot;,hi!&quot; &#125;&#125;Object.setProtorypeOf(friend,person)friend.getGreeting() &#x2F;&#x2F;Hello,hi! 五、解构：使数据更便捷解构是一种打破数据解构，将其拆分为更小部份的过程。 对象解构12345678910let node &#x3D;&#123; type:&#39;type111&#39;, name:&#39;name222&#39;&#125;let &#123;type,name&#125;&#x3D;nodeconsole.log(type) &#x2F;&#x2F; type111console.log(name) &#x2F;&#x2F; name222let &#123;type,name&#125; &#x2F;&#x2F;语法错误&#x2F;&#x2F;如果使用 let const var 解构声明变量，则一定要初始化程序，也就是右边的值 对象赋值 一定要用小括号包裹赋值语句，转化为一个表达式 解构赋值表达式的值与表达式右侧的值相等12345678let node&#x3D;&#123; type:&#39;type111&#39;, name:&#39;name222&#39;&#125;,type&#x3D;&#39;type333&#39;,name&#x3D;5&#x2F;&#x2F;解构语法为多个亦是赋值(&#123;type,name&#125;&#x3D;node)console.log(type) &#x2F;&#x2F; type111console.log(name) &#x2F;&#x2F; name222 默认值 如果指定局部变量的值在对象中不存在，那个值就为undefined 可以定一个默认值1234567891011let node&#x3D;&#123; type:&#39;type111&#39;, name:&#39;name222&#39;&#125;let &#123;type,name,value&#125; &#x3D; nodeconsole.log(type) &#x2F;&#x2F; type111console.log(name) &#x2F;&#x2F; name222console.log(value) &#x2F;&#x2F; undefinedlet &#123;type,name,value&#x3D;true&#125; &#x3D; nodeconsole.log(value) &#x2F;&#x2F; true 为非同名局部变量赋值12345678910let node&#x3D;&#123; type:&#39;type111&#39;, name:&#39;name222&#39;&#125;let &#123;type:newtype,name:newname&#125; &#x3D; nodeconsole.log(newtype) &#x2F;&#x2F; type111console.log(newname) &#x2F;&#x2F; name222let &#123;type:newtype,name:newname,value:newvalue&#x3D;&quot;bar&quot;&#125; &#x3D; nodeconsole.log(newvalue) &#x2F;&#x2F; bar 嵌套解构对象12345678910111213let node&#x3D;&#123; type:&#39;type111&#39;, name:&#39;name222&#39;, loc:&#123; start:&#123; line:1 &#125; &#125;&#125;let &#123;loc:&#123;start&#125;&#125; &#x3D; nodeconsole.log(start.line) &#x2F;&#x2F; 1let &#123;loc:&#123;start:newstart&#125;&#125; &#x3D; nodeconsole.log(newstart.line) &#x2F;&#x2F; 1 数组解构12345678let colors &#x3D; [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;]let [frist,second] &#x3D; colorsconsole.log(first) &#x2F;&#x2F;redconsole.log(second) &#x2F;&#x2F;green&#x2F;&#x2F;可以直接省略元素let [,,third] &#x3D; colorsconsole.log(third) &#x2F;&#x2F;blue 解构赋值12345678910let colors &#x3D; [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;],first&#x3D;&#39;other1&#39;,second&#x3D;&#39;other2&#39;let [frist,second] &#x3D; colorsconsole.log(first) &#x2F;&#x2F;redconsole.log(second) &#x2F;&#x2F;green&#x2F;&#x2F;交换两个变量的值let a&#x3D;1,b&#x3D;2[a,b] &#x3D; [b,a]console.log(a) &#x2F;&#x2F;2console.log(b) &#x2F;&#x2F;1 默认值1234let colors &#x3D; [&#39;red&#39;]let [first,second&#x3D;&#39;green&#39;]&#x3D;colorsconsole.log(first) &#x2F;&#x2F;redconsole.log(second) &#x2F;&#x2F; green 嵌套数组解构1234let colors &#x3D; [&#39;red&#39;,[&#39;green&#39;,&#39;light&#39;],&#39;blue&#39;]let [first,[second]]&#x3D;colorsconsole.log(first) &#x2F;&#x2F;redconsole.log(second) &#x2F;&#x2F; green 不定元素123456789let colors &#x3D; [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;]let [first,...group]&#x3D;colorsconsole.log(first) &#x2F;&#x2F;redconsole.log(group.length) &#x2F;&#x2F; 2console.log(group[0]) &#x2F;&#x2F; greenvar group &#x3D; color.concat() &#x2F;&#x2F;es5 链接两个元素let [...group]&#x3D;colors &#x2F;&#x2F;es6 不定元素必须为最后一个元素console.log(group) &#x2F;&#x2F;[&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;] 混合解构123456789101112131415let node&#x3D;&#123; type:&#39;1&#39;, name:&#39;foo&#39;, loc:&#123; start:&#123; line:1 &#125; &#125;, range:[0,3]&#125;let &#123; loc:&#123;start&#125;,range:[startIndex]&#125; &#x3D; nodeconsole.log(start.line) &#x2F;&#x2F;1console.log(startIndex) &#x2F;&#x2F;0 解构参数12345678910111213141516171819202122function setCookie(name,value,&#123;secure,path,domain,expires&#125;)&#123; &#x2F;&#x2F;&#125;setCookie(&#39;type&#39;,&#39;js&#39;,&#123; secure:true, expires:6000&#125;)&#x2F;&#x2F;必须传值的解构参数setCookie(&#39;type&#39;,&#39;js&#39;) &#x2F;&#x2F;error&#x2F;&#x2F;可以这样设置可选function setCookie(name,value,&#123;secure,path,domain,expires&#125;&#x3D;&#123;&#125;)&#123; &#x2F;&#x2F;&#125;&#x2F;&#x2F;解构参数默认值function setCookie(name,value,&#123; secure &#x3D; false, path &#x3D; &#39;&#x2F;&#39;, domain&#x3D;&#39;example.com&#39;, expires &#x3D; &#39;test&#39;&#125;)&#123; &#x2F;&#x2F;&#125; 六、七、Set集合和Map集合Set集合 有序列表 含有一些相互独立的非重复值 new Set()创建 xx.size可以算个数 add() 添加 has() 检测是否存在 delete() 移除元素 clear() 移除所有元素 forEach(下一次索引的位置，与第一个参数一样的值，被遍历的集合本身) array = […set] 转为数组 123456789101112131415161718192021let arr &#x3D; new Set()arr.add(5)arr.size &#x2F;&#x2F;1arr.has(’5’) &#x2F;&#x2F;falsearr.delete(5)arr.clear()let set &#x3D; new Set([1,2])set.forEach(function(val,key,ownerSet)&#123; console.log(val) console.log(key) console.log(ownerSet &#x3D;&#x3D;&#x3D; set)&#125;)&#x2F;&#x2F; 1&#x2F;&#x2F; 1&#x2F;&#x2F; true&#x2F;&#x2F; 2&#x2F;&#x2F; 2&#x2F;&#x2F; truelet arrary &#x3D; [...set] &#x2F;&#x2F;[1,2] Map 集合 存储着许多键值对的有序列表 xx.set(键名，键值) 添加元素 xx.get(键名) 获取元素 如果不存在 undefined has() delete() clear() size // 检测是否存在。删除键值对。删除所有键值对。个数。 forEach(集合中下一次索引的位置，值对应的键名，集合本身) 12345678910111213141516let arr &#x3D; new Map([[‘name’,’nick’],[‘age’,25]])arr.has(’name’) &#x2F;&#x2F; truearr.get(’name’) &#x2F;&#x2F; nickarr.set(‘name2’,’mick’)arr.size &#x2F;&#x2F;3arr.delete(‘name’)arr.clear()arr.forEach(function(val,key,ownerMap)&#123; console.log(val) console.log(key) console.log(ownerMap &#x3D;&#x3D;&#x3D; arr)&#125;&#x2F;&#x2F; name &#x2F;&#x2F; nick&#x2F;&#x2F; true 八、九、es6中的类类的声明 函数声明可以提升 类声明中的所有代码将自动运行在严格模式下；并且无法脱离 类声明中所有方法都是不可枚举的 每个类都有一个名为 contruct的内部方法 通过new字段以外调用的都会报错 在类中修改类名会报错。类外可以修改1234567891011121314class personClass()&#123; constructor(name)&#123; this.name &#x3D; name &#125; sayName()&#123; console.log(this.name) &#125;&#125;let person &#x3D; new PersonClass(’nick’)person.sayName() &#x2F;&#x2F; nickperson instanceof personClass &#x2F;&#x2F;trueperson instanceof object &#x2F;&#x2F;truetypeof personClass &#x2F;&#x2F;functiontypeof personClass.protorype.sayName &#x2F;&#x2F;function 类表达式基本的类表达式语法 let personClass = class{} 命名类表达式 let personClass = class personClass2{} //personClass2 只能在类中使用 作为一等公民的类（头等函数） 一等公民是指一个可以传入函数，可以从函数返回，可以赋值给变量的值1234567891011121314function createObject(classDef)&#123; return new classDef()&#125;let obj &#x3D; createObject(class&#123; sayHi()&#123; console.log(’hi’) &#125;&#125;)obj.sayHi() &#x2F;&#x2F;hilet person &#x3D; new class&#123; &#x2F;&#x2F;...&#125;(’nick’)person.sayName() &#x2F;&#x2F;hi 访问器属性1234567891011121314class CustomHtmlEle&#123; constructor(ele)&#123; this.ele &#x3D; ele &#125; get html()&#123; return this.ele.innerHTML &#125; set html(val)&#123; this.ele.innerHTML &#x3D; val &#125;&#125;var des &#x3D; Object.getOwnPropertyDescriptor(customHtmlEle.protorype,’html’)’get’ in descriptor &#x2F;&#x2F;true‘set‘ in descriptor &#x2F;&#x2F;true 可计算成员的名称1234567891011let method &#x3D; ‘sayName’class person &#123; constructor(name)&#123; this.name &#x3D; name &#125; [method]()&#123; console.log(this.name) &#125;&#125;let me &#x3D; new person(‘nick’)me.sayName() 生成器方法方法名前附加一个星号*来定义生成器 12345678class myclass&#123; *createIterator()&#123; yield 1 yield 2 &#125;&#125;let ins &#x3D; new myclass()let iterator &#x3D; ins.createIterator() 静态成员123456789class person&#123; contructor(name)&#123; this.name &#x3D; name &#125; static create(name)&#123; &#x2F;&#x2F;静态方法 return new person(name) &#125;&#125;let p &#x3D; person.create(‘nick’) 继承与派生类12345678910111213141516171819202122232425262728class rectangle&#123; contructior(length,width)&#123; this.length &#x3D; length this.width &#x3D; width &#125; getArea()&#123; reutrn this.length*this.width &#125;&#125;class Square extends rectangle&#123; constructor(length)&#123; super(length,length) &#125;&#125;var square &#x3D; new Square(3)square.getArea() &#x2F;&#x2F;9squere instanceof square &#x2F;&#x2F;trueclass Square extends rectangle&#123; &#x2F;&#x2F;没有构造函数&#125;&#x2F;&#x2F;等价于class Square extends rectangle&#123; constructor(...args)&#123; super(...args) &#125;&#125; 只可以在派生类的构造函数中使用super() 在构造函数访问this前一定要调用super() 如果不想调用，唯一方法是让类的构造函数返回一个对象 其他 类方法的遮蔽 派生类中的方法总会遮盖基类中的同名方法 静态成员继承 如果基类中有静态成员，派生类中也可以使用 派生自表达式的类 内建对象的继承 在类的构造函数中使用 new.target十、改进数组的功能创建数组Array.of() 原始数组创建ssssss 12345678910111213let item =new Array(2)item.length //2 //传入数值型 length会被设为此值let item =new Array('2')item.length //1item[0] // '2' //传入字符 此值会成为目标数据唯一项 let item = new Array(2,3,'1') item.length //3 item[0] //2 //传入多个 都会变成元素 ES6 Array.of()不存在单一数值型参数值的特例，无论多少参数，无论什么类型，都会创建一个包含所有参数的数组 1234567891011let item = Array.of(1,2)item.length //2item[0] //1let item = Array.of(2)item.length //1item[0] //2let item = Array.of('2')item.length //1item[0] //'2' Array.form() 将对象转为数组 支持可迭代对象或类数组对象作为第一个参数，最终返回一个数组 123function dosomething()&#123; var args &#x3D; Array.form(arguments)&#125; 映射转换 映射函数做为第二个参数 123456789101112131415161718function translate()&#123; return Array.form(arguments,(value) &#x3D;&gt; value+1)&#125;let number translate(1,2,3)&#x2F;&#x2F; 2,3,4&#x2F;&#x2F; helper.add() 作为映射函数let helper &#x3D; &#123; diff:1, add(value)&#123; return value + this.diff &#125;&#125;function translate()&#123; return Array.form(arguments,helper.add,helper)&#125;let number &#x3D; translate(1,2,3)&#x2F;&#x2F; 2,3,4 转换可迭代对象 123456789let numbers &#x3D; &#123; *[symbol.iterator]()&#123; yield 1; yield 2; yield 3; &#125;&#125;let numbers2 &#x3D; Array.form(numbers,(value) &#x3D;&gt; value+1)&#x2F;&#x2F; 2,3,4 为所有数组添加的新方法 indexOf() lastIndexOf() ES5的方法 find() 返回查找的值 findIndex() 返回查找到的值的索引 fill(a,b,c) a值b开始索引c不包含结束索引当前值 copyWithin(a,b,c) a开始填充值的索引b开始复制值的索引c当位于c索引时停止 1234567891011let numbers &#x3D; [35,20,40,50,45]numbers.find(n &#x3D;&gt; n&gt;45) &#x2F;&#x2F;50numbers.findIndex(n &#x3D;&gt; n&gt;45) &#x2F;&#x2F;3let numbers &#x3D; [1,2,3,4]numbers.fill(1) &#x2F;&#x2F; 1,1,1,1numbers.fill(1,2) &#x2F;&#x2F; 1,2,1,1numbers.fill(0,1,3) &#x2F;&#x2F;1,0,0,1numbers.copyWithin(2,0) &#x2F;&#x2F; 1,2,1,2numbers.copyWithin(2,0,1) &#x2F;&#x2F; 1,2,1,4 十一、Promise 与异步编程附录A：ES6一些其它小改动使用整数判断整数型 Number.isInteger()根据IEEE754判断底层存储方式是否为整型 123Number.isInteger(25) &#x2F;&#x2F;tureNumber.isInterger(25.0) &#x2F;&#x2F;true 依旧是25Number.isInterger(25.1) &#x2F;&#x2F;false 安全整数 Number.isSafeInterger()确保是整数，并且处于安全范围内。IEEE754范围是-2（53次方） — 2（53次方） 1Number.isSafeInterger() 新的Math方法增加游戏和图型体验 Unicode标识符ES6通过Unicode31号标准附录http://unicode.org/reports/tr31/ 第一个字符必须是$、_ 或任何带有ID_Start的派生核心属性的Unicode符号 后续的每个字符必须是$、_ 、\\u200c、\\u200d 或任何带有ID_Continue派生核心属性的Unicode符号 正式化_proto_属性，但不建议使用建议使用 Object.getPrototypeof() Object.setPrototypeof() 附录B：初识ES7（2016）ES6发展历经4年时间，后面版本更换为一年一个版本，因此ES6成为改动最大的一个版本。新版本规范命名以年份来命名。ES7被正式命名为ES2016。 指数运算符 求幂运算符是两个星号 ** 左边是基数 右边是指数 ** 左边基数 右边指数 等价于 Math.pow() ** 在JS中二进制运算符中优先级最高 一元运算符 高于 ** 左侧的一元运算符只能使用++ – 前缀运算符会在所有操作前操作数，后缀运算符会在所有操作后操作数12345678910111213141516Math.pow(5,2) &#x2F;&#x2F;js老方法let result 5 ** 2 &#x2F;&#x2F; 25 上下两种等价let result 2 * 5 ** 2 &#x2F;&#x2F;50 优先级最高let r &#x3D; -5 ** 2&#x2F;&#x2F;错误语法let r &#x3D; (-5) ** 2 &#x2F;&#x2F; 25let r &#x3D; - (5 ** 2) &#x2F;&#x2F; -25let num1 &#x3D;2 ,num2 &#x3D; 2;console.log(++num1 ** 2) &#x2F;&#x2F;9console.log(num1) &#x2F;&#x2F;3console.log(num1-- ** 2) &#x2F;&#x2F;4console.log(num1) &#x2F;&#x2F; 1 es2016中完善了 Array.prototype.includes() 第一个必填 第二个非必填 Array.prototype.includes(值,开始搜索的索引值)1234let values &#x3D; [1,2,3]values.includes(1) &#x2F;&#x2F;truevalues.includes(0) &#x2F;&#x2F;falsevaluse.includes(1,2) &#x2F;&#x2F;false val.includes() val.indexOf() 比较 若检查数组中是否有值 使用includes() 因为NaN值indexOf()不能匹配 若想知道某个值的索引 使用indexOf() 函数作用域 严格模式的一处改动ES2016规定参数被解构或有默认参数的函数中禁止使用use strict指令。只有参数不包含解构或默认值的简单参数列表时才可以在函数体中使用use strict 12345678910&#x2F;&#x2F; 错误function do(first &#x3D; this)&#123; &#39;use strict&#39; return first&#125;&#x2F;&#x2F; 正确function do(first,second)&#123; &#39;use strict&#39; return first&#125;","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"深入理解ES6","slug":"深入理解ES6","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"},{"name":"阮一峰","slug":"阮一峰","permalink":"http://yoursite.com/tags/%E9%98%AE%E4%B8%80%E5%B3%B0/"}]},{"title":"WEB前端开发最佳实践","slug":"book/2018/WEB前端开发最佳实践","date":"2018-10-09T12:42:04.000Z","updated":"2022-06-05T14:08:41.952Z","comments":true,"path":"2018/10/09/book/2018/WEB前端开发最佳实践/","link":"","permalink":"http://yoursite.com/2018/10/09/book/2018/WEB%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"一、必备技能 页面标记（HTML） 页面样式（CSS） 前端编程（JS） 跨平台浏览器（IE6\\7\\8 移动设备） 沟通能力 前端框架（jQuery、YUI、ExtJs） 调试工具（IE\\Chrome\\Firebug） 二、相关前端框架 G- itHub前三位语言：Javascript 、Ruby 、Python GitHub前端框架：jQuery 、Bootstrape 、Prototype 、ExtJs 、Mootools 轻量级框架：Modernizr 、Underscore.js 、Backbone.js 、Raphael.js 开发工具：Aptana Studio 、 Webstorm 框架html5shiv：（IE78不兼容的新标签可以正常使用）http://github.com/afarkas/html5shiv 框架Modernizr：（封装了对HTML5新特性的判断）http://modernizr.com 网站CanIuse：查询html5新特性浏览器兼容情况 三、web前端分析工具 YSlow http://yslow.org PageSpeed http://developers.google.com/speed/pagespeed 四、结构组织12345678910111213- js - lib 放置框架JS custom.js - css - lib 放置框架样式 - images 放置样式中的背景图 reset.css 统一元素默认初始化样式 custom.css 业务相关样式 - resource 放置页面图片文件及其他类型的图片index.html 五、代码和资源的压缩与合并 web服务器开启Gzip压缩 ：http://zh.wikipedia.org/wiki/Gzip JS代码压缩： a. UglifyJS：压缩和编译 https://github.com/mishoo/uglifyjs b. YUI Compressor：仅仅是压缩http://developer.yahoo.com/yui/compressor c. Closure Compiler：压缩和编译 http://developers.google.com/closure/compiler CSS代码压缩：Css Compressor http://www.csscompressor.com HTML代码压缩(很少使用)：HtmlCompressor http://code.google.com/p/htmlcompressor 图片资源压缩a. 在线工具TinyPNG压缩PNG https://tinypng.com/b. 在线工具JPEGmini压缩JPG http://www.jpegmini.com/c. 本地工具ImageOptim压缩JPG PNG GIF https://imageoptim.com/ ANT是基于java的构建工具，使用YUI压缩程序合并和压缩js和css，使用jpegtran和OptiPng优化JPG和PNG，使用HtmlCompressor压缩HTML和移除调式代码 Grunt前端自动化构建工具：压缩JS的grunt-contrib-uglify插件、压缩css的grunt-contrib-cssmin插件、压缩图片的grunt-contrib-imagemin插件 http://www.gruntjs.net/ https://github.com/gruntjs/grunt-contrib-uglify https://github.com/gruntjs/grunt-contrib-cssmin https://github.com/gruntjs/grunt-contrib-imagemin 六、命名规范id用下划线_ class用中划线- class作为JS的调用勾子的前缀加js-或j- html注释不宜过多、CSS和JS应该注释清楚、js多行用/**/ 单行用// js局部变量用首字母小写其它首字母大写例如 bookName，另：公有接口的命名为首字母大写，私有接口的命名为首字母小写 jQuery的变量名加$ 函数参数的逗号后面使用一个空格 七、标准的html代码 合理使用标题标签到 设置img中的alt属性 验证页面代码工具：html validator和html tidy下划线用删除线用 meta有四个属性 name http-equiv content charsetname和content组合 构成名称值，描述网站信息，有keywords和descriptionhttp-equiv和content 设置特定的http指令 ,其中有content-type 、default-style、refreshcharset设置页面字符编码，必须在title前插入 设置IE浏览器的兼容模式 设置在移动设备中显示 &lt;meat name=“viewport”content=”width=device-width, initial-scale=1,maximum-scale=1”&gt;设置固定网站的功能 浏览器右键弹出 ​ ​","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"WEB前端开发最佳实践","slug":"WEB前端开发最佳实践","permalink":"http://yoursite.com/tags/WEB%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"CSS权威指南 - [未完]","slug":"book/2018/CSS权威指南","date":"2018-04-23T01:00:00.000Z","updated":"2022-06-05T14:08:41.951Z","comments":true,"path":"2018/04/23/book/2018/CSS权威指南/","link":"","permalink":"http://yoursite.com/2018/04/23/book/2018/CSS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/","excerpt":"","text":"第一章CSS和文档一、元素元素是文档结构的基础。如p table span a div 替换元素replaced element 是指用来替换元素内容的部份并非由文档内容直接表示。如img input 非替换元素nonreplaced element 是指其内容由用户代理（通常是一个浏览器）在元素本身生成的框中显示。段落、标题、表单元格、列表和XHTML中的几乎所有都是非替换元素。 块级元素block-level 生成一个元素框，它会填充其父元素的内容区，旁边不能有其他元素。如 p 和 div 行内元素inline-level 在一个文本行内生成元素框，而不会打断这行文本。如a、strong和em 二、CSS和XHTMLlink标记。 style元素。始终要以开头 @import指令。须出现在样式表的开头。@import url(sheet2.css); CSS注释。/* … */ 包围，注释不能嵌套。 第二章 选择器一、基本规则 规则结构 h1{color:red;} h1 选择器 color 属性 red 值 color:red 声明块 元素选择器。文档元素就是最基本的选择器，通常是整个HTML元素，如p h3 em a html。 声明块包含一个或多个声明。 在CSS属性中，使用/来分隔两个特定的关键字。如 h2 {font:large/150% sans-serif;} 二、分组选择器分组。h2,p{color:gray;} 通配选择器。*{} 三、类选择器和ID选择器类选择器class selector 选择器p.warning解释为其class属性包含词warning的所有段落 p.warning.help只匹配class包含词warning和help的那些p元素，IE7以后支持 ID选择器ID selector，会使用一次而且仅一次，ID选择器不能结合使用。 类选择器和ID选择器可能是区分大小写的。 四、属性选择器简单的属性选择器，h1[class]{color:red;} 根据具体属性值选择，planet[moons=”1”]{…;} 选择moons属性值为1的那些planet元素 [~=]根据部份属性值选择，p[class~=”warning”]{…;} 选择class属性中包含warning的元素 特定属性选择类型，p[lang|=”en”]{…;}选择lang属性等于en或者以en-开头的所有元素 ^=”key” 以key开头 $=”key” 以key结尾 *=”key” 包含key的所有 只有safari 基于Gecko的浏览器、opera和IE7/WIN对子串选择器提供了支持 五、使用文档结构后代选择器descendant selector 上下文选择器contextual selector 选择子元素，h1 &gt; strong{} 选择相邻兄弟元素，h1 + p {} IE6之前不支持子选择器和相邻兄弟选择器 六、伪类和伪元素a标签，两种基本的锚类型：已访问和未访问，这些类型称为伪类pseudo-class，使用这些伪类的选择器则称为伪类选择器pseudo-class selector 链接伪类： :link :visited 动态伪类： :focus :hover :active 伪类顺序很重要：link-visited-focus-hover-active 其它静态伪类：选择第一个子元素 :first-child，设置首字母样式:first-letter，设置第一行样式:first-line first-letter和first-line只能应于于标记或段落之类的块级元素 根据语言选择 *:lang(fr){…;} 结合伪类 a:visited:hover{…;} 设置之前和之后的元素的样式 h2:before{} h2:after{} 第三章 结构和层叠第四章 值和单位第五章 字体第六章 文本属性","categories":[],"tags":[{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"javascript 高级程序设计 - [未完]","slug":"book/2018/JS基础","date":"2016-07-01T01:00:00.000Z","updated":"2022-06-05T14:08:41.952Z","comments":true,"path":"2016/07/01/book/2018/JS基础/","link":"","permalink":"http://yoursite.com/2016/07/01/book/2018/JS%E5%9F%BA%E7%A1%80/","excerpt":"","text":"JS基础 一、JavaScript 语句 ​ JavaScript 语句向浏览器发出的命令。语句的作用是告诉浏览器应该做什么。 二、分号 ​ 语句之间的分割是分号； ​ 注意：分号是可选项，有时候看到不以分号隔开的。 三、JavaScript代码 ​ 按照编写顺序依次执行 四、标识符 ​ JS标识符必须以字母、下划线或美元符号开始 ​ JS关键字 ​ 五、JS同样对大小写很敏感 六、注释 ​ 单行注释 //… ​ 多行注释 /* … */ 七、变量 1、变量是用来储存信息的容器 ​ var a =”1”; 八、数据类型 ​ 字符串 String var string = “hello”; ​ 数字 Number var i= 10; ​ 布尔Boolean var flag= true; ​ 数组Array var arr=[1,2,3,4]; ​ var arr=[“hello”,”world”,”jike”,”xueyuan”]; ​ var arr=new Arry(“hello”,”world”,”jike”,”xueyuan”); ​ 对象Object ​ 空null ​ 未定义 ​ 可以通过赋值为空null的方式定义对象 九、转换类型 type of (); 操作符 判断类型 value of(); 操作符 直接返回值（数值、字符串或布尔值的true或false） 1、转为字符串 toString(); 不必传参，传参可以转为二进制、八进制等等 ；string(变量) 可以转换任何类型的值为字符串 2、转为数值：number() 转数值 parseInt()转整数 parseFloat() 转浮点 ​ JS语法讲解 一、运算符 1、算数运算符 + - * % / ++ – ​ 先运算再加i++ ​ 先加再运算++i = i+1 2、赋值运算符 = += -= *= /= %= ​ i+=j 等于 i=i+j 3、字符串操作 4、比较运算符 == ===（值和类型都要一样） != !==(值和类型都要不一样) &gt; &lt; &gt;= &lt;= 5、逻辑运算符 &amp;&amp;(and) ||(or) !(相反) 6、条件运算符 二、条件语句 1、if..else ​ if (条件){ ​ 执行语句; ​ }else{ ​ 执行语句; ​ } 或 嵌套循环 ​ if (条件){ ​ 执行语句; ​ }else if{ ​ 执行语句; ​ }else if{ ​ 执行语句; ​ } 2、switch ​ switch(条件){ ​ case 1: //注意此处是冒号 ​ 执行语句; ​ break; //跳出判断 ​ case 2: ​ 执行语句; ​ break; ​ default: //当条件不满足以上case 都会执行default ​ 执行语句; ​ break; ​ } ​ 三、循环语句 1、for循环 ​ var i=[1、2、3、4、5]; ​ var j; ​ for(j in i){ //如果j是i里面的元素 ​ 执行语句; ​ } 2、while循环 do..while ​ while (条件){ //先判断再执行 判断有效才会被执行 ​ //执行 ​ } 或 ​ do{ //先执行再判断 至少要被执行一次 ​ // 执行 ​ }while(条件){ ​ } 四、跳转语句 1、break; 跳出当前循环 2、continue; 结束当循环 进行下一次循环 JS函数 一、什么是函数 函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。 var a=10; var b=a+1; a是变量，b是a的函数 function name(){} name是函数名 二、**定义函数** function 函数名(){ ​ 函数体; (代码块) } 三、**函数调用** 1、在script里调用 2、在html中调用 四、**带参数的函数** 1、函数参数 在函数的调用中，也可以传值，这个值被称为参数 例 demo(arg1,arg2); 2、参数的个数可以任意多，每个参数通过“，”隔开 3、参数在传递时，顺序必须一致 4、意义：通过传递参数的个数以及参数的类型不同完成不同的功能 例 ​ function demo(a,b){ ​ var sum = a+b; ​ alert(sum); ​ } ​ demo(10,20); 五**、带**返回值的函数 1、返回值 ​ 有时，我们需要将函数的值返回给调用他的地方 ​ 通过return语句实现 ​ 使用return时，函数会停止，同时返回值 2、局部变量和全局变量 var a = 10; //全局变量 任何地方都可以使用 function demo(){ ​ var i = 0; //局部变量 只能在当前函数中使用 ​ x =10; //全局变量 } JavaScript异常处理和事件处理 一、异常捕获 1、异常：当js执行出现错误，导致程序停止运行 2、当异常发生时，并且将这个异常生成一个错误信息 3、异常捕获 try{ ​ 发生异常的代码块 }catch(err){ } 二、事件 DOM Doucument Object Model 一、**DOM元素 控制 HTML** 1、改变html的输出流 document.write() 2、导找元素 通过ID找到HTML元素 document.getElementById(“”) 通过标签名找到HTML元素 document.getElementsByTagName(“”) //相同元素中的第一个标签元素 3、改变HTML内容 document.getElementById(“”).innerHTML=”” 4、改变HTML属性 使用属性attribute 二、DOM元素控制CSS document.getElementById(“”).style 三、DOM句柄 addEventListener removeElentListener document.getElementById(“”).addEventListener(“click”,function(){ alert(“hello”); }); Js事件讲解 一、事件流 二、事件处理 1、HTML事件处理 2、DOM0级事件处理 onclick写入js里 (弊端:只处理最后一个事件 会被覆盖) idname.onclick = function(){…}; 3、DOM2级事件处理 （推荐所有事件按顺序处理 不会被覆盖） addEventListener(“事件名”，”事件处理函数”，”布尔值”) / removeEventListerner true:事件捕获 false:事件冒泡 removeEventListener(); example: var btn1 = document.getElementById(“”).addEventListerner(“click”,function(){ ​ alert(“hello”) ​ }); or: var btn1 = document.getElementById(“btn1”); btn1.addEventListerner(“click”,demo); function demo(){ alert(“hello”) }; 4、IE事件处理程序 兼容以前 attachEvent detachEveent 三、事件对象 在触发DOM事件的时候会触发一个事件对象 1）type获取事件类型 2）target获取事件目标 3）stopPropagation(); 阻止事件冒泡 4）preventDefault(); 阻止事件默认行为 example: document.getElementById(“btn1”).addEventListerner(“mouseover”,showtype); function showtype(event){ // alert(event.type); ​ alert(event.target); ​ event.stopPropagation(); //阻止事件冒泡 ​ event.preventDefault(); //阻止事件默认行为 比如A标签的连接指向 } Js内置对象 一、什么是内置对象 js中所有事物都是对象，数组、字符串、日期、函数… 对象都带有属性(图片的长或宽或者A标签的连接…)和方法(对象提供的使用方式例如日期有年月份…) js允许自定义对象：1、定义并创建实例 2、使用函数来定义对象，然后创建新的对象实例 &lt;–创建对象–&gt; 例1 people = new Object(); people.name = “ivy”; people.age = “20”; document.write(“name”+people.name+”age”+people.age); 例2 function people(name,age){ ​ this._name=name; ​ this._age=age; } son = new people(“ivy”,30); document.wirte(“name:”+son._name + “age” + son._age); 二、string字符串对象 1、string用于处理已有的字符串 字符串可以使用单引号或双引号 2、在字符串中查找字符串 indexOf() 3、内容匹配 match() 4、内容替换 replace() 5、字符串大小写转换 toUpperCase() / toLowerCase() 6、字符串转为数组 strong&gt;split() var str = “hello world”; document.write(“字符串长度为”+ str.length); // 字符串长度 document.write(str.indexOf(“hello”)); //当前字符串是否存在 存在1不存在-1 第2点 document.write(str.mach(“hello”)); //是否匹配 是就1 否是null 第3点 document.write(str.replace(“world”,”jikexueyuan”)); //替换字符串 第4点 document.write(str.toUpperCase()); //大小写转换 第5点 //第6点 字符串属性 length、prototype、constructor 字符串方法 charAt()、charCodeAt()、contact()、fromCharCode()、indexOf()、lastIndexOf()、match()、replace()、search()、slice()、substring()、substr()、valueOf()、toLowerCase()、toUpperCase()、split() 三、date日期对象 处理日期和时间 1、常用方法 var date = new Date(); document.write(date); //获得当日日期 document.write(getFullYear()); //获取年份 document.write(getTime()); //获取毫秒 document.write(setFullYear()); //设置具体的日期 document.write(getDay()); //获取星期 2、时钟操作 四、Array数组对象 1、使用单独变量名来存储一系列的值 2、数组的创建 var myArray = [“hello”,”ivy”,”me”] 3、数组的访问 通过指定数组名以及索引号码，你可以访问某个特定的元素 注意：[0]就数组的第一个元素 4、数组常用的方法 concat(); 合并数组 var a = [“hello”,”world”]; var b = [“my”,”name”]; var c = a.contact(b); sort(); 排序 var a = [“5”,”2”,”4”,”3”,”1”]; document.write(a.sort()); //升序 document.write(a.sort(function(){ ​ return b-a; })); //降序 push(); 末尾追加元素 var a = [“a”,”b”]; ​ a.push(“c”); document.write(a); reverse(); 数组元素翻转 首尾翻转 var a = [“c”,”a”,”b”]; document.write(a.reverse()); 五、math对象 执行常见的算数任务 常用方法： round();四舍五入 document.write(Math.round(2.5)); random(); 返回0-1之间的随机数 document.write(Math.random()); document.write(parseInt(Math.random()*10)); max(); 返回最高值 document.write(Math.max(“10”,”3”,”20”,”1”)); min(); 返回最低值 abs();返回绝对值 document.write(Math.abs(10)); DOM对象控制HTML元素详解 方法 getElementByName() 获取name getElementByTagName() 获取元素 getAttribute() 获取元素属性 setAttribute() 设置元素属性 childNodes() 访问子节点 parentNode() 访问父节点 creatElement() 创建元素节点 creatTextNode 创建文本节点 insertBefore() 插入节点 removeChild() 删除节点 offsetHeight 网页尺寸 scrolll leight 网页尺寸 JS浏览器对象 一、windows对象 windows对象 是BOM的核心 ，指当前的浏览器窗口。 所有js的全局对象 、函数、变量均自动 成为windows对象 的成员 。 全局对象是windows对象的属性 函数是windows对象的方法 document也是windows对象的属性之一 windows尺寸 window.innerHeight - 浏览器窗口的内部高度 window.innnerWidth - 浏览器窗口的内部宽度 document.write(window.innerHeight +”,” + window.innerWidth); windows方法 window.open() 打开新窗口 function 函数名(){window.open(“index.html”,”name”,”height=200,width=200,top=100,toolbar=no,menubar=no”);} window.close() 关闭当前窗口 function 函数名(){window.close();} 二、计时器 计时事件 - 设定一个时间间隔后来执行代码 计时方法 - 1）setInerval() 间隔指定毫秒数不停地执行指定的代码 ​ clearInerval() 停止以上执行 按钮 **var** mytime = setInterval(**function**(){ gettime(); },1000); **function** gettime(){ **var** d = **new** Date(); **var** t = d.toLocaleTimeString(); document.getElementById(\"ptime\").innerHTML = t; } **function** stoptime(){ clearInterval(mytime) ​ } 2）setTimeout() 暂停指定毫秒数后执行指定的代码 ​ clearTimeout() 停止以上执行 按钮 **function** mywin(){ win = setTimeout(**function**(){alert(\"hello\")},3000); } **function** stopwin(){ clearTimeout(win); } 三、History对象 对象：window.history 对象包含浏览器的历史(url)的集合 方法： ​ history.back() 与在浏览器点击后退按钮相同 ​ history.forward() 与在浏览器点击前进按钮相同 ​ history.go() 进入历史中的某个页面 按钮 **function** goback(){ history.back(); //后退 history.forward(); //前进 history.go(-1); //进入到历史的某个页面 } 四、Location对象 window.location 对象用于获取当前页面的地址url,并把浏览器重新指向于新的页面。 Location对象属性： location.hostname 返回web主机域名 location.pathname 返回当前页面的路径和文件名 location.port 返回web主机的端口 location.protocol 返回所使用的web协议 http:// location.href 属性返回当前页面的url location.assign() 方法加载新的文档 按钮 **function** getLoc(){ document.getElementById(\"ptime\").innerHTML = window.location.hostname; document.getElementById(\"ptime\").innerHTML = window.location.pathname; document.getElementById(\"ptime\").innerHTML = window.location.port; document.getElementById(\"ptime\").innerHTML = window.location.protocol; document.getElementById(\"ptime\").innerHTML = window.location.href; local.ascent(\"http://www.xxx.com\"); } 五、Screen对象 window.screen 对象包含有关用户屏幕的信息 属性： screen.availWidth - 可用屏幕的宽度 screen.availHeight - 可用屏幕的高度 screen.width - 屏幕宽度 screen.height - 屏幕高度 document.write(“可用高度：”+screen.availHeight +”,可用宽度：”+screen.availWidth); document.write(“屏幕高度：”+screen.height +”,屏幕宽度：”+screen.width); JS面向对象 一、面向对象 1、面向对象中的概念 ​ 1）一切事物皆对象 ​ 2）对象具有封装和继承的特性 ​ 3）信息隐藏","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"}]}],"categories":[],"tags":[{"name":"es","slug":"es","permalink":"http://yoursite.com/tags/es/"},{"name":"elasticsearch","slug":"elasticsearch","permalink":"http://yoursite.com/tags/elasticsearch/"},{"name":"elastic","slug":"elastic","permalink":"http://yoursite.com/tags/elastic/"},{"name":"WebGL","slug":"WebGL","permalink":"http://yoursite.com/tags/WebGL/"},{"name":"TCP","slug":"TCP","permalink":"http://yoursite.com/tags/TCP/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"前端知识体系","slug":"前端知识体系","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"},{"name":"k8s","slug":"k8s","permalink":"http://yoursite.com/tags/k8s/"},{"name":"rust","slug":"rust","permalink":"http://yoursite.com/tags/rust/"},{"name":"webassembly","slug":"webassembly","permalink":"http://yoursite.com/tags/webassembly/"},{"name":"webGL","slug":"webGL","permalink":"http://yoursite.com/tags/webGL/"},{"name":"区块链","slug":"区块链","permalink":"http://yoursite.com/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"},{"name":"书籍","slug":"书籍","permalink":"http://yoursite.com/tags/%E4%B9%A6%E7%B1%8D/"},{"name":"小灰","slug":"小灰","permalink":"http://yoursite.com/tags/%E5%B0%8F%E7%81%B0/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"学习","slug":"学习","permalink":"http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"跨端","slug":"跨端","permalink":"http://yoursite.com/tags/%E8%B7%A8%E7%AB%AF/"},{"name":"数据平台","slug":"数据平台","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"性能","slug":"性能","permalink":"http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"},{"name":"部署","slug":"部署","permalink":"http://yoursite.com/tags/%E9%83%A8%E7%BD%B2/"},{"name":"大前端","slug":"大前端","permalink":"http://yoursite.com/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"weeks","slug":"weeks","permalink":"http://yoursite.com/tags/weeks/"},{"name":"微前端","slug":"微前端","permalink":"http://yoursite.com/tags/%E5%BE%AE%E5%89%8D%E7%AB%AF/"},{"name":"webgl","slug":"webgl","permalink":"http://yoursite.com/tags/webgl/"},{"name":"ES","slug":"ES","permalink":"http://yoursite.com/tags/ES/"},{"name":"自动化测试","slug":"自动化测试","permalink":"http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/"},{"name":"领域模型","slug":"领域模型","permalink":"http://yoursite.com/tags/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B/"},{"name":"源码","slug":"源码","permalink":"http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"},{"name":"组件","slug":"组件","permalink":"http://yoursite.com/tags/%E7%BB%84%E4%BB%B6/"},{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"},{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"},{"name":"react-hooks","slug":"react-hooks","permalink":"http://yoursite.com/tags/react-hooks/"},{"name":"redux","slug":"redux","permalink":"http://yoursite.com/tags/redux/"},{"name":"react-redux","slug":"react-redux","permalink":"http://yoursite.com/tags/react-redux/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"},{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"bbs","slug":"bbs","permalink":"http://yoursite.com/tags/bbs/"},{"name":"forum","slug":"forum","permalink":"http://yoursite.com/tags/forum/"},{"name":"go","slug":"go","permalink":"http://yoursite.com/tags/go/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"进阶","slug":"进阶","permalink":"http://yoursite.com/tags/%E8%BF%9B%E9%98%B6/"},{"name":"敏捷","slug":"敏捷","permalink":"http://yoursite.com/tags/%E6%95%8F%E6%8D%B7/"},{"name":"ie","slug":"ie","permalink":"http://yoursite.com/tags/ie/"},{"name":"节流防抖","slug":"节流防抖","permalink":"http://yoursite.com/tags/%E8%8A%82%E6%B5%81%E9%98%B2%E6%8A%96/"},{"name":"vue2","slug":"vue2","permalink":"http://yoursite.com/tags/vue2/"},{"name":"修饰符","slug":"修饰符","permalink":"http://yoursite.com/tags/%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"覃超","slug":"覃超","permalink":"http://yoursite.com/tags/%E8%A6%83%E8%B6%85/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"nginx","slug":"nginx","permalink":"http://yoursite.com/tags/nginx/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/%E8%BF%90%E7%BB%B4/"},{"name":"curl","slug":"curl","permalink":"http://yoursite.com/tags/curl/"},{"name":"shell","slug":"shell","permalink":"http://yoursite.com/tags/shell/"},{"name":"CMDB","slug":"CMDB","permalink":"http://yoursite.com/tags/CMDB/"},{"name":"K8S","slug":"K8S","permalink":"http://yoursite.com/tags/K8S/"},{"name":"CICD","slug":"CICD","permalink":"http://yoursite.com/tags/CICD/"},{"name":"架构","slug":"架构","permalink":"http://yoursite.com/tags/%E6%9E%B6%E6%9E%84/"},{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/%E7%BC%93%E5%AD%98/"},{"name":"消息队列","slug":"消息队列","permalink":"http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"name":"数据存储","slug":"数据存储","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"},{"name":"vue3","slug":"vue3","permalink":"http://yoursite.com/tags/vue3/"},{"name":"diff","slug":"diff","permalink":"http://yoursite.com/tags/diff/"},{"name":"proxy","slug":"proxy","permalink":"http://yoursite.com/tags/proxy/"},{"name":"UI","slug":"UI","permalink":"http://yoursite.com/tags/UI/"},{"name":"UX","slug":"UX","permalink":"http://yoursite.com/tags/UX/"},{"name":"UED","slug":"UED","permalink":"http://yoursite.com/tags/UED/"},{"name":"rollup","slug":"rollup","permalink":"http://yoursite.com/tags/rollup/"},{"name":"treeshaking","slug":"treeshaking","permalink":"http://yoursite.com/tags/treeshaking/"},{"name":"xlsx","slug":"xlsx","permalink":"http://yoursite.com/tags/xlsx/"},{"name":"JSX","slug":"JSX","permalink":"http://yoursite.com/tags/JSX/"},{"name":"vdom","slug":"vdom","permalink":"http://yoursite.com/tags/vdom/"},{"name":"gzip","slug":"gzip","permalink":"http://yoursite.com/tags/gzip/"},{"name":"single-spa","slug":"single-spa","permalink":"http://yoursite.com/tags/single-spa/"},{"name":"qiankun","slug":"qiankun","permalink":"http://yoursite.com/tags/qiankun/"},{"name":"基础","slug":"基础","permalink":"http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"},{"name":"typescript","slug":"typescript","permalink":"http://yoursite.com/tags/typescript/"},{"name":"vite","slug":"vite","permalink":"http://yoursite.com/tags/vite/"},{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LoianeGroner","slug":"LoianeGroner","permalink":"http://yoursite.com/tags/LoianeGroner/"},{"name":"koa","slug":"koa","permalink":"http://yoursite.com/tags/koa/"},{"name":"egg","slug":"egg","permalink":"http://yoursite.com/tags/egg/"},{"name":"virtualDom","slug":"virtualDom","permalink":"http://yoursite.com/tags/virtualDom/"},{"name":"snabbdom","slug":"snabbdom","permalink":"http://yoursite.com/tags/snabbdom/"},{"name":"RSA","slug":"RSA","permalink":"http://yoursite.com/tags/RSA/"},{"name":"jsencrypt","slug":"jsencrypt","permalink":"http://yoursite.com/tags/jsencrypt/"},{"name":"rem","slug":"rem","permalink":"http://yoursite.com/tags/rem/"},{"name":"postcss","slug":"postcss","permalink":"http://yoursite.com/tags/postcss/"},{"name":"tool","slug":"tool","permalink":"http://yoursite.com/tags/tool/"},{"name":"function","slug":"function","permalink":"http://yoursite.com/tags/function/"},{"name":"uni","slug":"uni","permalink":"http://yoursite.com/tags/uni/"},{"name":"yum","slug":"yum","permalink":"http://yoursite.com/tags/yum/"},{"name":"npm","slug":"npm","permalink":"http://yoursite.com/tags/npm/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"aliyun","slug":"aliyun","permalink":"http://yoursite.com/tags/aliyun/"},{"name":"pm2","slug":"pm2","permalink":"http://yoursite.com/tags/pm2/"},{"name":"nimg","slug":"nimg","permalink":"http://yoursite.com/tags/nimg/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"},{"name":"https","slug":"https","permalink":"http://yoursite.com/tags/https/"},{"name":"resloader","slug":"resloader","permalink":"http://yoursite.com/tags/resloader/"},{"name":"资源预加载","slug":"资源预加载","permalink":"http://yoursite.com/tags/%E8%B5%84%E6%BA%90%E9%A2%84%E5%8A%A0%E8%BD%BD/"},{"name":"canvas","slug":"canvas","permalink":"http://yoursite.com/tags/canvas/"},{"name":"excel","slug":"excel","permalink":"http://yoursite.com/tags/excel/"},{"name":"高性能","slug":"高性能","permalink":"http://yoursite.com/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"},{"name":"响应式","slug":"响应式","permalink":"http://yoursite.com/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"},{"name":"高效","slug":"高效","permalink":"http://yoursite.com/tags/%E9%AB%98%E6%95%88/"},{"name":"优化","slug":"优化","permalink":"http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"},{"name":"Flutter","slug":"Flutter","permalink":"http://yoursite.com/tags/Flutter/"},{"name":"reactnative","slug":"reactnative","permalink":"http://yoursite.com/tags/reactnative/"},{"name":"设计","slug":"设计","permalink":"http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"你不知道的","slug":"你不知道的","permalink":"http://yoursite.com/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84/"},{"name":"抓包","slug":"抓包","permalink":"http://yoursite.com/tags/%E6%8A%93%E5%8C%85/"},{"name":"编写可维护的JS","slug":"编写可维护的JS","permalink":"http://yoursite.com/tags/%E7%BC%96%E5%86%99%E5%8F%AF%E7%BB%B4%E6%8A%A4%E7%9A%84JS/"},{"name":"CSS世界","slug":"CSS世界","permalink":"http://yoursite.com/tags/CSS%E4%B8%96%E7%95%8C/"},{"name":"张鑫旭","slug":"张鑫旭","permalink":"http://yoursite.com/tags/%E5%BC%A0%E9%91%AB%E6%97%AD/"},{"name":"深入理解ES6","slug":"深入理解ES6","permalink":"http://yoursite.com/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6/"},{"name":"阮一峰","slug":"阮一峰","permalink":"http://yoursite.com/tags/%E9%98%AE%E4%B8%80%E5%B3%B0/"},{"name":"WEB前端开发最佳实践","slug":"WEB前端开发最佳实践","permalink":"http://yoursite.com/tags/WEB%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"},{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]}